import aiohttp, asyncio, pprint, yaml, logging, enum, cbor2, time, \
    random, inspect

import zmq.asyncio

from .image import image_unpack

logger = logging.getLogger(__name__)


class DataEvent:
    marker = "n/a"
    
    def __init__(self, e_type=None, e_series_id=None, e_series_unique_id=None, **msg):
        self._mtype = e_type
        self.series_id = e_series_id
        self.series_unique_id = e_series_unique_id
        self.timestamps = {
            'recv': time.time()
        }
        assert self.marker == self._mtype
        
        #print(f'series_id={self._series_id} ts={self._create_ts} type={self._mtype} keys follow')
        #pprint.pprint({k for k in msg.keys()})


class StartDataEvent(DataEvent):
    marker = "start"
    def __init__(self,
                 e_arm_date=None, e_count_time=None,
                 e_image_size_x=None, e_image_size_y=None,
                 e_pixel_size_x=None, e_pixel_size_y=None,
                 e_image_dtype=None,
                 e_number_of_images=None,
                 e_channels=None,
                 **msg):
        super().__init__(**msg)
        self.number_of_images = e_number_of_images
        self.channels = e_channels
        #print(f'series_id={self._series_id} expecting={self._number_of_images} channels={e_channels}')

    
class EndDataEvent(DataEvent):
    marker = "end"
    def __init__(self, **msg):
        super().__init__(**msg)


class ImageDataEvent(DataEvent):
    marker = "image"
    def __init__(self,
                 e_data=None,
                 e_image_id=None,
                 e_start_time=None,
                 e_stop_time=None,
                 e_real_time=None,
                 e_series_date=None,
                 **msg):
        super().__init__(**msg)

        self.image_id = e_image_id
        self.timestamps.update({
            'start':  e_start_time,
            'stop':   e_stop_time,
            'real':   e_real_time,
            'series': e_series_date
        })

        self.images = {
            imgname:image_unpack(e_data[imgname]) \
            for imgname in e_data
        }


class CommandRequest:
    ''' Built by App, transmitted to Eiger '''
    
    subsystem = "detector"
    
    def __init__(self, command, pdict=None, **params):
        self.command = command
        self.params = {}
        self.params.update((pdict if pdict is not None else {}))
        self.params.update(params)


class ArmRequest(CommandRequest):
    def __init__(self):
        super().__init__('command/arm')

class DisarmRequest(CommandRequest):
    def __init__(self):
        super().__init__('command/disarm')

class AbortRequest(CommandRequest):
    def __init__(self):
        super().__init__('command/abort')

class CancelRequest(CommandRequest):
    def __init__(self):
        super().__init__('command/cancel')
        
class TriggerRequest(CommandRequest):
    def __init__(self):
        super().__init__('command/trigger')


#class ConfigRequest(...CommandRequest?): pass

class CommandReplyEvent:
    ''' Received in response to a CommandEvent '''
    pass



class ParameterEvent:
    '''
    Received from Eiger, contains configuration/status data.
    This is more of an "artificial" event where we bundle together
    several HTTP calls to the Eiger API to query information.
    '''
    def __init__(self, request_type, **data):
        '''
        Creates a config-status event based on a status dictionary.
        The dictionary has the key format "{}"
        '''
        self.subsystem = request_type.subsystem
        self.ptype = request_type.ptype
        self.params = data.copy()
        assert request_type.request_keys == set([k for k in data.keys()])


class DetectorConfigEvent(ParameterEvent):
    def __init__(self, **data):
        super().__init__(DetectorConfigRequest, **data)


class DetectorStatusEvent(ParameterEvent):
    def __init__(self, **data):
        super().__init__(DetectorStatusRequest, **data)


class StreamConfigEvent(ParameterEvent):
    def __init__(self, **data):
        super().__init__(StreamConfigRequest, **data)


class ParameterRequest:
    '''
    Event generated by the application to request status/config data from Eiger
    '''
    pass


class DetectorConfigRequest(ParameterRequest):
    subsystem = "detector"
    ptype = "config"
    reply_type = DetectorConfigEvent
    request_keys = { 'auto_sum_strict',
                     'auto_summation',
                     ## 'binning_mode', # cannot be set in gated mode?
                     'bit_depth_image',
                     'bit_depth_readout',
                     'compression',
                     'count_time',
                     'counting_mode',
                     'countrate_correction_applied',
                     'detector_readout_time',
                     'eiger_fw_version',
                     'extg_mode',
                     # 'flatfield',
                     'flatfield_correction_applied',
                     'frame_time',
                     'nexpi',
                     'nimages',
                     'ntrigger',
                     ## 'pixel_format', # cannot be set in gated mode?
                     #'pixel_mask',
                     'pixel_mask_applied',
                     'photon_energy',
                     'test_image_mode',
                     # 'threshold/1/energy', # formatting problem?
                     # 'threshold/2/energy',
                     'trigger_mode',
                     'trigger_start_delay',
                     'x_pixel_size',
                     'y_pixel_size',
                     'x_pixels_in_detector',
                     'y_pixels_in_detector' }
    

class DetectorStatusRequest(ParameterRequest):
    subsystem = "detector"
    ptype = "status"
    reply_type = DetectorStatusEvent
    request_keys = { 'state',
                     'temperature',
                     'humidity',
                     'time' }


class StreamConfigRequest(ParameterRequest):
    subsystem = "stream"
    ptype = "config"
    reply_type = StreamConfigEvent
    request_keys = { 'format',
                     'header_detail',
                     'mode' }

            
class Detector:

    def __init__(self, host):
        self._host = host
        self._api_version = '1.8.0'

        self.images = []

        self.event_queue = []

    async def init(self):
        await self.init_client()
        await self.init_detector()

        
    async def init_detector(self):
        await self._request_json('PUT', 'stream', 'config', mode='enabled', format='cbor')


    async def init_client(self):
        self._http_client = aiohttp.ClientSession()
        logger.info(f'http={self._http_client}')
        
        self._zmq_ctx = zmq.asyncio.Context()
        self._zmq_socket = self._zmq_ctx.socket(zmq.PULL)
        self._zmq_conn = self._zmq_socket.connect(f'tcp://{self._host}:31001')
        logger.info(f'zmq={self._zmq_conn}')


    async def _request_json(self, verb, subsystem, ptype, req=None, **req_kw):
        '''
        Helper to transmit a specific query (PUT, GET, POST, ...) to a specific
        subsystem (detector, stream, ...) for a specific subtype (config, ...)
        and check for success.

        Raises RuntimeError if the query is not successful (currently only
        accepting HTTP code 200).

        Returns the AIOHTTP reply, but that's mostly moot.
        '''
        #if transform is None:
        
        transform = lambda x: { 'value': x }
        
        req_dict = req if req is not None else {}
        req_dict.update({ k:transform(v) for k,v in req_kw.items() })
        q_url = f'http://{self._host}/{subsystem}/api/{self._api_version}/{ptype}'
        reply = await self._http_client.request(verb, q_url, json = req_dict)
        if reply.status not in (200,):
            raise RuntimeError(f'msg="Request failed" code={reply.status} '
                               f'reason="{reply.reason}" url="{q_url}" '
                               f'verb="{verb}"')
        return reply
        

    async def _query_subsystem(self, subsystem, ptype, query_list):
        
        #if transform is None:
        transform=lambda x: x['value'] if hasattr(x, '__getitem__') else x
        url_base = f'http://{self._host}/{subsystem}/api/{self._api_version}/{ptype}'
            
        async def _fetch(cli, cmd):
            url_fetch = f'{url_base}/{cmd}'
            async with cli.get(url_fetch) as response:
                t = await response.text()
                return yaml.safe_load(t)

        reply = await asyncio.gather(*[_fetch(self._http_client, c) \
                                       for c in query_list],
                                     return_exceptions=False)
        
        data = { c:transform(r) for c,r in zip(query_list, reply) }

        return data


    async def abort(self):
        # Abort immediately
        # detector/.../command/cancel
        await self._request_json("PUT", "detector", f"command/abort")


    async def cancel(self):
        # Cancel after next image
        # detector/.../command/cancel
        await self._request_json("PUT", "detector", f"command/cancel")


    async def arm(self):
        # Loads config to detector and arm trigger
        #await self._request_json("PUT", "detector", f"command/arm")
        #self._popped_images_this_frame = 0
        self.event_push(ArmRequest())


    async def disarm(self):
        # Disarms the trigger, writes data (?) to file
        #await self._request_json("PUT", "detector", f"command/disarm")
        self.event_push(DisarmRequest())

    
    async def wait_for_images(self, nimg=1, timeout=0.0, period=0.01):
        # Waits until all (?) expected images have been received
        t0 = time.time()
        while True:
            if hasattr(self, "_incoming_data"):
                if self._incoming_data == False:
                    return
            
            #popped = self._popped_images_this_frame \
            #    if hasattr(self, "_popped_images_this_frame") \
            #       else 0
            
            #if len(self.images)+popped >= nimg:
            #    return
            
            if (timeout > -0.1) and (time.time()-t0) > timeout:
                raise TimeoutError()
            
            await asyncio.sleep(period)

    async def set_count_time(self, t):
        await self._request_json('PUT', 'detector', 'config', count_time=t)


    async def trigger(self, countdown=0):
        await self._request_json("PUT", 'detector', 'command/trigger')

        
    async def set_trigger_mode(self, m):
        assert m.lower() in { "ints", "inte", "exts", "exte", "eies", "extg" }
        
        await self._request_json('PUT', 'detector', 'config', trigger_mode=m)

        # self.events_push(CommandRequest('config', trigger_mode=m))
        # await self.flush_events()


    async def set_extg_mode(self, m):
        assert m.lower() in { "double", "single" }
        await self._request_json('PUT', 'detector', 'config', extg_mode=m)


    async def set_nexpi(self, n):
        await self._request_json('PUT', 'detector', 'config', nexpi=n)


    async def set_threshold_mode(self, mode, threshold=1):
        # Sets mode of threshold `threshold` (detector/config/threshold/{n}/mode)
        # `mode` should be one of: 'enabled', 'disabled'
        if mode in (True, 'enabled'):
            mode = 'enabled'
        elif mode in (False, 'disabled'):
            mode = 'disabled'
        await self._request_json('PUT', 'detector', 'config',\
                                 req={f'threshold/{threshold}/mode': mode})


    async def set_flatfield_correction_applied(self, mode):
        # Sets mode of threshold `threshold` (detector/config/threshold/{n}/mode)
        # `mode` should be one of: 'enabled', 'disabled'
        if mode in (True, 'enabled'):
            mode = 'enabled'
        elif mode in (False, 'disabled'):
            mode = 'disabled'
        await self._request_json('PUT', 'detector', 'config', flatfield_correction_applied=mode)

        
    async def set_pixel_mask_applied(self, mode):
        await self._request_json('PUT', 'detector', 'config',
                                 pixel_mask_applied=bool(mode))


    async def set_nimages(self, n):
        await self._request_json('PUT', 'detector', 'config', nimages=n)

        
    async def set_ntrigger(self, n):
        await self._request_json('PUT', 'detector', 'config', ntrigger=n)

        
    async def set_countrate_correction_applied(self, b):
        assert isinstance(b, bool)
        await self._request_json('PUT', 'detector', 'config', countrate_correction_applied=b)

        
    async def set_counting_mode(self, m):
        await self._request_json('PUT', 'detector', 'config', counting_mode=m)


    async def set_auto_summation(self, b):
        assert isinstance(b, bool)
        await self._request_json('PUT', 'detector', 'config', auto_summation=b)


    def last(self, subsystem_or_prop, ptype=None, prop=None):
        try:
            if ptype is None and prop is None:
                return self._last_status[subsystem_or_prop]
            return self._last_status[f'{subsystem_or_prop}.{ptype}.{prop}']
        except KeyError:
            logger.error(f'subsystem={subsystem_or_prop} '
                         f'ptype={ptype} '
                         f'msg="{prop} available at this time"')


    async def _query_status(self):
        for EventType in (DetectorConfigRequest,
                          DetectorStatusRequest,
                          StreamConfigRequest):
            self.event_push(EventType())


    async def pop_images(self, num_images=1, period=0.01, timeout=0.0):
        t0 = time.time()
        images = []
        while True:
            if len(self.images) >= num_images:
                for x in range(num_images):
                    images.append(self.images.pop(0))
                if hasattr(self, "_popped_images_this_frame"):
                    self._popped_images_this_frame += len(images)
                print(f'popped={len(images)} remain={len(self.images)}')
                return images
            
            if (timeout > -0.1) and (time.time()-t0) > timeout:
                raise TimeoutError()

            await asyncio.sleep(period)
        


    async def _query_events(self):

        event_types = {
            v.marker:v for k,v in globals().items() \
            if inspect.isclass(v) and \
               issubclass(v, DataEvent) and \
               (v not in (DataEvent,))
        }
        
        zpoll = await self._zmq_socket.poll(timeout=0)
        
        if zpoll != 0:
            t0 = time.time()
            zpack = await self._zmq_socket.recv_multipart()
            for i,buf in enumerate(zpack):
                msg = cbor2.loads(buf)
                e_msg = {f'e_{k}':v for k,v in msg.items()}
                EventType = event_types[msg['type']]                
                self.event_push(EventType(**e_msg))


    async def next_test_image(self):
        if not hasattr(self, "_test_image_index"):
            self._test_image_index = 0

        test_images = (
            'value',
            'cal_pulse',
            'mcb_id',
            'chip',
            #'chip_quadrant', # seemingly not supported by EIGER2 X 500k
            #'pattern',       # seemingly not supported by EIGER2 X 500k
            ''
        )
            
        await self.set_test_image(test_images[self._test_image_index])

        self._test_image_index += 1
        self._test_image_index %= len(test_images)
        

    async def set_test_image(self, img=''):
        try:
            await self._request_json('PUT', 'detector', 'config', test_image_mode=img)
            
            if img != '':
                await self._request_json('PUT', 'detector', 'config',
                                         test_image_value=128+random.randint(-64, 64))
        except Exception as e:
            print(f'test_image={img} msg="Failed" reason="{str(e)}"')


    async def set_live_image(self):
        # Enable live-image mode / disable test image mode
        await self.set_test_image('')


    def event_pop(self):
        try:
            return self.event_queue.pop()
        except IndexError:
            pass


    def event_push(self, event):
        self.event_queue.append(event)


    async def event_process(self, event):

        if isinstance(event, DataEvent):
            print(f'Data event: {event}')
        
        if event is None:
            return
        
        elif isinstance(event, StartDataEvent):
            channels = event.channels
            print(f'New series: {event.series_unique_id}')
            self._incoming_data = True

        elif isinstance(event, EndDataEvent):
            self._incoming_data = False

        elif isinstance(event, ImageDataEvent):
            print(f'Images: {len(event.images)} '
                  f'i={event.image_id} s={event.series_id} u={event.series_unique_id}')
            self.images.append(event.images['threshold_1'])

        elif isinstance(event, ParameterRequest):
            reply_dict = await self._query_subsystem(event.subsystem,
                                                     event.ptype,
                                                     query_list=event.request_keys)
            reply_event = event.reply_type(**reply_dict)
            self.event_push(reply_event)

        elif isinstance(event, ParameterEvent):
            #print(f'Param: {event.ptype} {pprint.pformat(event.params)}')
            pass

        elif isinstance(event, CommandRequest):
            await self._request_json("PUT", event.subsystem,
                                     event.command, req=event.params)

        elif isinstance(event, CommandReplyEvent):
            pass


    async def flush_events(self):
        while True:
            ev = self.event_pop()
            if ev is None:
                break
            await self.event_process(ev)
            
    
    async def update(self):
        await asyncio.gather(self._query_status(),
                             self._query_events(),
                             return_exceptions=False)
        await self.flush_events()
