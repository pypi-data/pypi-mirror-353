# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pydddi', 'pydddi.application', 'pydddi.domain', 'pydddi.infrastructure']

package_data = \
{'': ['*']}

install_requires = \
['pydantic>=2.11.5,<3.0.0']

setup_kwargs = {
    'name': 'pydantic-ddd-interface',
    'version': '0.1.1',
    'description': 'A Python library providing interface definitions for Domain-Driven Design (DDD) patterns using Pydantic for type safety and validation.',
    'long_description': '<div align="center">\n\n# ğŸ›ï¸ Pydddi\n\n**Pydantic-powered Domain-Driven Design Interfaces**\n\n*A modern Python library for building clean, type-safe DDD applications*\n\n[![Python](https://img.shields.io/badge/Python-3.12+-blue.svg)](https://python.org)\n[![Pydantic](https://img.shields.io/badge/Pydantic-v2-green.svg)](https://pydantic.dev)\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)\n[![Poetry](https://img.shields.io/badge/Poetry-managed-blue.svg)](https://python-poetry.org)\n\n---\n\n*Transform your Python applications with enterprise-grade DDD patterns* ğŸš€\n\n</div>\n\n## âœ¨ What is Pydddi?\n\nPydddi brings the power of **Domain-Driven Design** to Python with **type safety** at its core. Built on top of Pydantic, it provides clean interfaces and patterns that make your code more maintainable, testable, and scalable.\n\n### ğŸ¯ Why Choose Pydddi?\n\n| Feature | Benefit |\n|---------|---------|\n| ğŸ”’ **Type Safety** | Catch errors at development time with Pydantic validation |\n| ğŸ—ï¸ **Clean Architecture** | Enforce separation of concerns with clear layer boundaries |\n| ğŸ§© **Modular Design** | Mix and match interfaces based on your needs |\n| âš¡ **Modern Python** | Leverages Python 3.12+ features for optimal performance |\n| ğŸ“– **Self-Documenting** | Interfaces serve as living documentation |\n\n## ğŸš€ Features\n\n<table>\n<tr>\n<td width="50%">\n\n### ğŸ›ï¸ **Domain Layer**\n- Type-safe entities with identity\n- Value objects using Pydantic\n- Domain service abstractions\n- Rich domain modeling\n\n</td>\n<td width="50%">\n\n### âš™ï¸ **Application Layer**\n- Command/Result pattern\n- Use case interfaces\n- Structured error handling\n- Business workflow orchestration\n\n</td>\n</tr>\n<tr>\n<td>\n\n### ğŸ—„ï¸ **Infrastructure Layer**\n- Repository patterns (CRUD, Read, Aggregate)\n- Schema-based operations\n- Database abstraction\n- External service integration\n\n</td>\n<td>\n\n### ğŸ§ª **Developer Experience**\n- Full type hints support\n- IDE autocompletion\n- Runtime validation\n- Clear error messages\n\n</td>\n</tr>\n</table>\n\n## ğŸ“¦ Quick Start\n\n```bash\n# Install the package\npip install pydantic-ddd-interface\n```\n\n```python\n# Start building your domain\nfrom pydddi import IEntity, IUseCase, ICrudRepository\n\n# You\'re ready to build enterprise-grade applications! ğŸ‰\n```\n\n---\n\n## ğŸ”§ Usage Examples\n\n> ğŸ’¡ **Tip**: Each layer has a specific responsibility. Start with the domain and work your way out!\n\n### ğŸ›ï¸ Domain Layer\n*Define your business entities and value objects*\n\n```python\nfrom pydddi import IEntity, IModel\n\nclass User(IEntity[int]):\n    """Lightweight user entity - just identity and core attributes"""\n    id: int\n    name: str\n    email: str\n    \n    def get_id(self) -> int:\n        return self.id\n\nclass UserProfile(IModel):\n    """Heavy model with relationships - used in domain logic processing"""\n    user: User\n    posts: List["Post"]\n    followers: List["User"]\n    settings: "UserSettings"\n    activity_history: List["ActivityLog"]\n    \n    # Domain logic methods can access all related data\n    def get_total_engagement(self) -> int:\n        return sum(post.likes + post.comments for post in self.posts)\n```\n\n### âš™ï¸ Application Layer  \n*Orchestrate business workflows with use cases*\n\n```python\nfrom pydddi import IUseCase, IUseCaseCommand, IUseCaseResult\n\nclass CreateUserCommand(IUseCaseCommand):\n    """Command to create a new user"""\n    name: str\n    email: str\n\nclass CreateUserResult(IUseCaseResult):\n    """Result of user creation"""\n    user_id: int\n    success: bool\n    message: str\n\nclass CreateUserUseCase(IUseCase[CreateUserCommand, CreateUserResult]):\n    """Use case for creating users with business validation"""\n    \n    async def execute(self, command: CreateUserCommand) -> CreateUserResult:\n        # Your business logic here\n        # - Validate email uniqueness\n        # - Apply business rules\n        # - Persist user\n        pass\n```\n\n### ğŸ—„ï¸ Infrastructure Layer\n*Handle data persistence and external integrations*\n\n```python\nfrom pydddi import ICrudRepository, IReadRepository, IReadAggregateRepository\nfrom pydddi import ICreateSchema, IUpdateSchema\n\nclass UserCreateSchema(ICreateSchema):\n    """Schema for user creation"""\n    name: str\n    email: str\n\nclass UserUpdateSchema(IUpdateSchema):\n    """Schema for user updates"""\n    name: str | None = None\n    email: str | None = None\n```\n\n<details>\n<summary>ğŸ” <strong>Click to see repository implementations</strong></summary>\n\n```python\n# ğŸ”¨ CRUD Repository - for lightweight entity operations\nclass UserCrudRepository(ICrudRepository[User, UserCreateSchema, User, UserUpdateSchema]):\n    async def create(self, schema: UserCreateSchema) -> User:\n        """Create a new user entity (lightweight)"""\n        pass\n    \n    async def read(self, id: int) -> User:\n        """Get user entity by ID (no relationships)"""\n        pass\n    \n    # ... other CRUD methods\n\n# ğŸ“– Read Repository - for simple read operations on lightweight entities  \nclass UserReadRepository(IReadRepository[User, User]):\n    async def read(self, id: int) -> User:\n        """Get user entity without relationships"""\n        pass\n    \n    async def list(self, limit: int = None, **filters) -> List[User]:\n        """List user entities (lightweight)"""\n        pass\n\n# ğŸ”— Read Aggregate Repository - for heavy models with full relationships\nclass UserProfileRepository(IReadAggregateRepository[UserProfile, User]):\n    async def read(self, id: int) -> UserProfile:\n        """Get heavy UserProfile with all related data (posts, followers, etc.)"""\n        pass\n    \n    async def list(self, limit: int = None, **filters) -> List[UserProfile]:\n        """List UserProfile with full relationship data for domain processing"""\n        pass\n```\n\n</details>\n\n---\n\n## ğŸ—ï¸ Architecture Overview\n\n<div align="center">\n\n```mermaid\ngraph TB\n    subgraph "ğŸ–¥ï¸ Presentation Layer"\n        API[REST API / GraphQL]\n        CLI[CLI Commands]\n    end\n    \n    subgraph "âš™ï¸ Application Layer"\n        UC[Use Cases]\n        CMD[Commands & Results]\n    end\n    \n    subgraph "ğŸ›ï¸ Domain Layer"\n        ENT[Entities]\n        VO[Value Objects]\n        DS[Domain Services]\n    end\n    \n    subgraph "ğŸ—„ï¸ Infrastructure Layer"\n        REPO[Repositories]\n        DB[(Database)]\n        EXT[External APIs]\n    end\n    \n    API --> UC\n    CLI --> UC\n    UC --> ENT\n    UC --> REPO\n    REPO --> DB\n    REPO --> EXT\n    \n    style UC fill:#e1f5fe\n    style ENT fill:#f3e5f5\n    style REPO fill:#e8f5e8\n```\n\n</div>\n\n### ğŸ¯ Design Principles\n\n| Principle | Implementation |\n|-----------|----------------|\n| **ğŸ”’ Dependency Inversion** | Infrastructure depends on domain abstractions |\n| **ğŸ§© Single Responsibility** | Each interface has one clear purpose |\n| **âš¡ Open/Closed** | Extend behavior without modifying existing code |\n| **ğŸ­ Interface Segregation** | Small, focused interfaces over large ones |\n\n---\n\n## ğŸ“š API Reference\n\n<details>\n<summary>ğŸ›ï¸ <strong>Domain Layer APIs</strong></summary>\n\n### Entities & Models\n- **`IEntity`** - Base class for entities with identity and lifecycle\n- **`IModel`** - Base class for value objects using Pydantic validation\n- **`IDomainService`** - Interface for domain services containing business logic\n\n</details>\n\n<details>\n<summary>âš™ï¸ <strong>Application Layer APIs</strong></summary>\n\n### Use Cases & Commands\n- **`IUseCase[TCommand, TResult]`** - Generic interface for business use cases\n- **`IUseCaseCommand`** - Base class for use case input commands\n- **`IUseCaseResult`** - Base class for use case output results\n\n### Exception Handling\n- **`UseCaseError`** - Base exception for use case operations\n- **`UseCaseCommandError`** - Command validation errors\n- **`UseCaseResultError`** - Result validation errors  \n- **`UseCaseExecutionError`** - Execution-time errors\n\n</details>\n\n<details>\n<summary>ğŸ—„ï¸ <strong>Infrastructure Layer APIs</strong></summary>\n\n### Repository Patterns\n- **`ICrudRepository[TEntity, TCreateSchema, TReadSchema, TUpdateSchema]`** - Full CRUD operations\n- **`IReadRepository[TEntity, TReadSchema]`** - Read-only operations for entities\n- **`IReadAggregateRepository[TModel, TReadAggregateSchema]`** - Complex reads with relationships\n\n### Data Schemas\n- **`ICreateSchema`** - Schema for create operations\n- **`IReadSchema`** - Schema for read operations  \n- **`IUpdateSchema`** - Schema for update operations\n- **`IReadAggregateSchema`** - Schema for aggregate read operations\n\n### Exception Handling\n- **`RepositoryError`** - Base repository exception\n- **`RecordNotFoundError`** - Entity not found errors\n- **`DuplicateRecordError`** - Duplicate entity errors\n\n</details>\n\n### ğŸ¯ Repository Usage Guide\n\n| Repository Type | Use Case | Returns | Example | Weight |\n|----------------|----------|---------|---------|--------|\n| **ICrudRepository** | Lightweight entity lifecycle | `IEntity` | User CRUD operations | ğŸª¶ Light |\n| **IReadRepository** | Simple entity queries | `IEntity` | User identity lookup | ğŸª¶ Light |\n| **IReadAggregateRepository** | Heavy models with relationships | `IModel` | UserProfile with posts/followers | ğŸ‹ï¸ Heavy |\n\n---\n\n## ğŸ¤ Contributing\n\nWe welcome contributions! Here\'s how you can help:\n\n<div align="center">\n\n| ğŸ› **Found a Bug?** | ğŸ’¡ **Have an Idea?** | ğŸ“– **Improve Docs?** |\n|:---:|:---:|:---:|\n| [Open an Issue](../../issues) | [Start a Discussion](../../discussions) | [Submit a PR](../../pulls) |\n\n</div>\n\n### ğŸ› ï¸ Development Setup\n\n```bash\n# Clone the repository\ngit clone https://github.com/nodashin/pydantic-ddd-interface.git\ncd pydantic-ddd-interface\n\n# Install dependencies\npoetry install\n\n# Run tests\npoetry run pytest\n\n# Format code\npoetry run black .\n```\n\n---\n\n<div align="center">\n\n## ğŸ“„ License\n\nThis project is licensed under the **MIT License** - see the [LICENSE](LICENSE) file for details.\n\n---\n\n<div align="center">\n  \n**Made with â¤ï¸ for the Python DDD community**\n\n*Star â­ this repo if you find it useful!*\n\n</div>\n\n</div>\n',
    'author': 'nodashin',
    'author_email': 'nodashin.jpn@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/nodashin6/pydantic-ddd-interface',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.12,<4.0',
}


setup(**setup_kwargs)
