// automatically generated by the FlatBuffers compiler, do not modify
//
// To reproduce:
//   flatc version 24.12.23
//   schema.fbs v0.80.0 (2f3f1225db5280209cc42b8564b64c97)
//   sed -i 's/namespace tosa/namespace tosaFb/g' schema.fbs
//   flatc --cpp --scoped-enums --reflect-names schema.fbs
//   clang-format -i tosa_generated.h


#ifndef FLATBUFFERS_GENERATED_SCHEMA_TOSAFB_H_
#define FLATBUFFERS_GENERATED_SCHEMA_TOSAFB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 && FLATBUFFERS_VERSION_MINOR == 12 && FLATBUFFERS_VERSION_REVISION == 23,
    "Non-compatible flatbuffers version included");

namespace tosaFb
{

struct PoolAttribute;
struct PoolAttributeBuilder;

struct ConvAttribute;
struct ConvAttributeBuilder;

struct TransposeConvAttribute;
struct TransposeConvAttributeBuilder;

struct PadAttribute;
struct PadAttributeBuilder;

struct AxisAttribute;
struct AxisAttributeBuilder;

struct ReshapeAttribute;
struct ReshapeAttributeBuilder;

struct SliceAttribute;
struct SliceAttributeBuilder;

struct TileAttribute;
struct TileAttributeBuilder;

struct ResizeAttribute;
struct ResizeAttributeBuilder;

struct ClampAttribute;
struct ClampAttributeBuilder;

struct RescaleAttribute;
struct RescaleAttributeBuilder;

struct MulAttribute;
struct MulAttributeBuilder;

struct ArithmeticRightShiftAttribute;
struct ArithmeticRightShiftAttributeBuilder;

struct CondIfAttribute;
struct CondIfAttributeBuilder;

struct WhileLoopAttribute;
struct WhileLoopAttributeBuilder;

struct TransposeAttribute;
struct TransposeAttributeBuilder;

struct TableAttribute;
struct TableAttributeBuilder;

struct MatMulAttribute;
struct MatMulAttributeBuilder;

struct FullyConnectedAttribute;
struct FullyConnectedAttributeBuilder;

struct NegateAttribute;
struct NegateAttributeBuilder;

struct CustomAttribute;
struct CustomAttributeBuilder;

struct FFTAttribute;
struct FFTAttributeBuilder;

struct Version;
struct VersionBuilder;

struct TosaTensor;
struct TosaTensorBuilder;

struct TosaOperator;
struct TosaOperatorBuilder;

struct TosaBasicBlock;
struct TosaBasicBlockBuilder;

struct TosaRegion;
struct TosaRegionBuilder;

struct TosaGraph;
struct TosaGraphBuilder;

inline const ::flatbuffers::TypeTable *PoolAttributeTypeTable();

inline const ::flatbuffers::TypeTable *ConvAttributeTypeTable();

inline const ::flatbuffers::TypeTable *TransposeConvAttributeTypeTable();

inline const ::flatbuffers::TypeTable *PadAttributeTypeTable();

inline const ::flatbuffers::TypeTable *AxisAttributeTypeTable();

inline const ::flatbuffers::TypeTable *ReshapeAttributeTypeTable();

inline const ::flatbuffers::TypeTable *SliceAttributeTypeTable();

inline const ::flatbuffers::TypeTable *TileAttributeTypeTable();

inline const ::flatbuffers::TypeTable *ResizeAttributeTypeTable();

inline const ::flatbuffers::TypeTable *ClampAttributeTypeTable();

inline const ::flatbuffers::TypeTable *RescaleAttributeTypeTable();

inline const ::flatbuffers::TypeTable *MulAttributeTypeTable();

inline const ::flatbuffers::TypeTable *ArithmeticRightShiftAttributeTypeTable();

inline const ::flatbuffers::TypeTable *CondIfAttributeTypeTable();

inline const ::flatbuffers::TypeTable *WhileLoopAttributeTypeTable();

inline const ::flatbuffers::TypeTable *TransposeAttributeTypeTable();

inline const ::flatbuffers::TypeTable *TableAttributeTypeTable();

inline const ::flatbuffers::TypeTable *MatMulAttributeTypeTable();

inline const ::flatbuffers::TypeTable *FullyConnectedAttributeTypeTable();

inline const ::flatbuffers::TypeTable *NegateAttributeTypeTable();

inline const ::flatbuffers::TypeTable *CustomAttributeTypeTable();

inline const ::flatbuffers::TypeTable *FFTAttributeTypeTable();

inline const ::flatbuffers::TypeTable *VersionTypeTable();

inline const ::flatbuffers::TypeTable *TosaTensorTypeTable();

inline const ::flatbuffers::TypeTable *TosaOperatorTypeTable();

inline const ::flatbuffers::TypeTable *TosaBasicBlockTypeTable();

inline const ::flatbuffers::TypeTable *TosaRegionTypeTable();

inline const ::flatbuffers::TypeTable *TosaGraphTypeTable();

enum class DType : uint32_t
{
    UNKNOWN = 0,
    BOOL = 1,
    UINT8 = 2,
    INT4 = 3,
    INT8 = 4,
    INT16 = 5,
    INT32 = 6,
    INT48 = 7,
    FP32 = 8,
    UINT16 = 9,
    FP16 = 10,
    BF16 = 11,
    SHAPE = 12,
    MIN = UNKNOWN,
    MAX = SHAPE
};

inline const DType (&EnumValuesDType())[13]
{
    static const DType values[] = {DType::UNKNOWN, DType::BOOL, DType::UINT8, DType::INT4, DType::INT8, DType::INT16,
        DType::INT32, DType::INT48, DType::FP32, DType::UINT16, DType::FP16, DType::BF16, DType::SHAPE};
    return values;
}

inline const char *const *EnumNamesDType()
{
    static const char *const names[14] = {"UNKNOWN", "BOOL", "UINT8", "INT4", "INT8", "INT16", "INT32", "INT48", "FP32",
        "UINT16", "FP16", "BF16", "SHAPE", nullptr};
    return names;
}

inline const char *EnumNameDType(DType e)
{
    if ( ::flatbuffers::IsOutRange(e, DType::UNKNOWN, DType::SHAPE) ) return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesDType()[index];
}

enum class ResizeMode : uint32_t
{
    UNKNOWN = 0,
    NEAREST = 1,
    BILINEAR = 2,
    MIN = UNKNOWN,
    MAX = BILINEAR
};

inline const ResizeMode (&EnumValuesResizeMode())[3]
{
    static const ResizeMode values[] = {ResizeMode::UNKNOWN, ResizeMode::NEAREST, ResizeMode::BILINEAR};
    return values;
}

inline const char *const *EnumNamesResizeMode()
{
    static const char *const names[4] = {"UNKNOWN", "NEAREST", "BILINEAR", nullptr};
    return names;
}

inline const char *EnumNameResizeMode(ResizeMode e)
{
    if ( ::flatbuffers::IsOutRange(e, ResizeMode::UNKNOWN, ResizeMode::BILINEAR) ) return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesResizeMode()[index];
}

enum class Op : uint32_t
{
    UNKNOWN = 0,
    ARGMAX = 1,
    AVG_POOL2D = 2,
    CONV2D = 3,
    CONV3D = 4,
    DEPTHWISE_CONV2D = 5,
    FULLY_CONNECTED = 6,
    MATMUL = 7,
    MAX_POOL2D = 8,
    TRANSPOSE_CONV2D = 9,
    CLAMP = 10,
    RESERVED = 11,
    SIGMOID = 12,
    TANH = 13,
    ADD = 14,
    ARITHMETIC_RIGHT_SHIFT = 15,
    BITWISE_AND = 16,
    BITWISE_OR = 17,
    BITWISE_XOR = 18,
    INTDIV = 19,
    LOGICAL_AND = 20,
    LOGICAL_LEFT_SHIFT = 21,
    LOGICAL_RIGHT_SHIFT = 22,
    LOGICAL_OR = 23,
    LOGICAL_XOR = 24,
    MAXIMUM = 25,
    MINIMUM = 26,
    MUL = 27,
    POW = 28,
    SUB = 29,
    TABLE = 30,
    ABS = 31,
    BITWISE_NOT = 32,
    CEIL = 33,
    CLZ = 34,
    EXP = 35,
    FLOOR = 36,
    LOG = 37,
    LOGICAL_NOT = 38,
    NEGATE = 39,
    RECIPROCAL = 40,
    RSQRT = 41,
    SELECT = 42,
    EQUAL = 43,
    GREATER = 44,
    GREATER_EQUAL = 45,
    REDUCE_ANY = 46,
    REDUCE_ALL = 47,
    REDUCE_MAX = 48,
    REDUCE_MIN = 49,
    REDUCE_PRODUCT = 50,
    REDUCE_SUM = 51,
    CONCAT = 52,
    PAD = 53,
    RESHAPE = 54,
    REVERSE = 55,
    SLICE = 56,
    TILE = 57,
    TRANSPOSE = 58,
    GATHER = 59,
    SCATTER = 60,
    RESIZE = 61,
    CAST = 62,
    RESCALE = 63,
    CONST = 64,
    IDENTITY = 65,
    CUSTOM = 66,
    COND_IF = 67,
    WHILE_LOOP = 68,
    FFT2D = 69,
    RFFT2D = 70,
    ERF = 71,
    DIM = 72,
    MIN = UNKNOWN,
    MAX = DIM
};

inline const Op (&EnumValuesOp())[73]
{
    static const Op values[] = {Op::UNKNOWN, Op::ARGMAX, Op::AVG_POOL2D, Op::CONV2D, Op::CONV3D, Op::DEPTHWISE_CONV2D,
        Op::FULLY_CONNECTED, Op::MATMUL, Op::MAX_POOL2D, Op::TRANSPOSE_CONV2D, Op::CLAMP, Op::RESERVED, Op::SIGMOID, Op::TANH,
        Op::ADD, Op::ARITHMETIC_RIGHT_SHIFT, Op::BITWISE_AND, Op::BITWISE_OR, Op::BITWISE_XOR, Op::INTDIV, Op::LOGICAL_AND,
        Op::LOGICAL_LEFT_SHIFT, Op::LOGICAL_RIGHT_SHIFT, Op::LOGICAL_OR, Op::LOGICAL_XOR, Op::MAXIMUM, Op::MINIMUM, Op::MUL,
        Op::POW, Op::SUB, Op::TABLE, Op::ABS, Op::BITWISE_NOT, Op::CEIL, Op::CLZ, Op::EXP, Op::FLOOR, Op::LOG, Op::LOGICAL_NOT,
        Op::NEGATE, Op::RECIPROCAL, Op::RSQRT, Op::SELECT, Op::EQUAL, Op::GREATER, Op::GREATER_EQUAL, Op::REDUCE_ANY,
        Op::REDUCE_ALL, Op::REDUCE_MAX, Op::REDUCE_MIN, Op::REDUCE_PRODUCT, Op::REDUCE_SUM, Op::CONCAT, Op::PAD, Op::RESHAPE,
        Op::REVERSE, Op::SLICE, Op::TILE, Op::TRANSPOSE, Op::GATHER, Op::SCATTER, Op::RESIZE, Op::CAST, Op::RESCALE,
        Op::CONST, Op::IDENTITY, Op::CUSTOM, Op::COND_IF, Op::WHILE_LOOP, Op::FFT2D, Op::RFFT2D, Op::ERF, Op::DIM};
    return values;
}

inline const char *const *EnumNamesOp()
{
    static const char *const names[74] = {"UNKNOWN", "ARGMAX", "AVG_POOL2D", "CONV2D", "CONV3D", "DEPTHWISE_CONV2D",
        "FULLY_CONNECTED", "MATMUL", "MAX_POOL2D", "TRANSPOSE_CONV2D", "CLAMP", "RESERVED", "SIGMOID", "TANH", "ADD",
        "ARITHMETIC_RIGHT_SHIFT", "BITWISE_AND", "BITWISE_OR", "BITWISE_XOR", "INTDIV", "LOGICAL_AND", "LOGICAL_LEFT_SHIFT",
        "LOGICAL_RIGHT_SHIFT", "LOGICAL_OR", "LOGICAL_XOR", "MAXIMUM", "MINIMUM", "MUL", "POW", "SUB", "TABLE", "ABS",
        "BITWISE_NOT", "CEIL", "CLZ", "EXP", "FLOOR", "LOG", "LOGICAL_NOT", "NEGATE", "RECIPROCAL", "RSQRT", "SELECT",
        "EQUAL", "GREATER", "GREATER_EQUAL", "REDUCE_ANY", "REDUCE_ALL", "REDUCE_MAX", "REDUCE_MIN", "REDUCE_PRODUCT",
        "REDUCE_SUM", "CONCAT", "PAD", "RESHAPE", "REVERSE", "SLICE", "TILE", "TRANSPOSE", "GATHER", "SCATTER", "RESIZE",
        "CAST", "RESCALE", "CONST", "IDENTITY", "CUSTOM", "COND_IF", "WHILE_LOOP", "FFT2D", "RFFT2D", "ERF", "DIM", nullptr};
    return names;
}

inline const char *EnumNameOp(Op e)
{
    if ( ::flatbuffers::IsOutRange(e, Op::UNKNOWN, Op::DIM) ) return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesOp()[index];
}

enum class Attribute : uint8_t
{
    NONE = 0,
    PoolAttribute = 1,
    ConvAttribute = 2,
    TransposeConvAttribute = 3,
    PadAttribute = 4,
    AxisAttribute = 5,
    ReshapeAttribute = 6,
    SliceAttribute = 7,
    TileAttribute = 8,
    ResizeAttribute = 9,
    ClampAttribute = 10,
    RescaleAttribute = 11,
    MulAttribute = 12,
    ArithmeticRightShiftAttribute = 13,
    CondIfAttribute = 14,
    WhileLoopAttribute = 15,
    TransposeAttribute = 16,
    TableAttribute = 17,
    MatMulAttribute = 18,
    FullyConnectedAttribute = 19,
    NegateAttribute = 20,
    CustomAttribute = 21,
    FFTAttribute = 22,
    MIN = NONE,
    MAX = FFTAttribute
};

inline const Attribute (&EnumValuesAttribute())[23]
{
    static const Attribute values[] = {Attribute::NONE, Attribute::PoolAttribute, Attribute::ConvAttribute,
        Attribute::TransposeConvAttribute, Attribute::PadAttribute, Attribute::AxisAttribute, Attribute::ReshapeAttribute,
        Attribute::SliceAttribute, Attribute::TileAttribute, Attribute::ResizeAttribute, Attribute::ClampAttribute,
        Attribute::RescaleAttribute, Attribute::MulAttribute, Attribute::ArithmeticRightShiftAttribute, Attribute::CondIfAttribute,
        Attribute::WhileLoopAttribute, Attribute::TransposeAttribute, Attribute::TableAttribute, Attribute::MatMulAttribute,
        Attribute::FullyConnectedAttribute, Attribute::NegateAttribute, Attribute::CustomAttribute, Attribute::FFTAttribute};
    return values;
}

inline const char *const *EnumNamesAttribute()
{
    static const char *const names[24] = {"NONE", "PoolAttribute", "ConvAttribute", "TransposeConvAttribute", "PadAttribute",
        "AxisAttribute", "ReshapeAttribute", "SliceAttribute", "TileAttribute", "ResizeAttribute", "ClampAttribute", "RescaleAttribute",
        "MulAttribute", "ArithmeticRightShiftAttribute", "CondIfAttribute", "WhileLoopAttribute", "TransposeAttribute", "TableAttribute",
        "MatMulAttribute", "FullyConnectedAttribute", "NegateAttribute", "CustomAttribute", "FFTAttribute", nullptr};
    return names;
}

inline const char *EnumNameAttribute(Attribute e)
{
    if ( ::flatbuffers::IsOutRange(e, Attribute::NONE, Attribute::FFTAttribute) ) return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesAttribute()[index];
}

template<typename T>
struct AttributeTraits
{
    static const Attribute enum_value = Attribute::NONE;
};

template<>
struct AttributeTraits<tosaFb::PoolAttribute>
{
    static const Attribute enum_value = Attribute::PoolAttribute;
};

template<>
struct AttributeTraits<tosaFb::ConvAttribute>
{
    static const Attribute enum_value = Attribute::ConvAttribute;
};

template<>
struct AttributeTraits<tosaFb::TransposeConvAttribute>
{
    static const Attribute enum_value = Attribute::TransposeConvAttribute;
};

template<>
struct AttributeTraits<tosaFb::PadAttribute>
{
    static const Attribute enum_value = Attribute::PadAttribute;
};

template<>
struct AttributeTraits<tosaFb::AxisAttribute>
{
    static const Attribute enum_value = Attribute::AxisAttribute;
};

template<>
struct AttributeTraits<tosaFb::ReshapeAttribute>
{
    static const Attribute enum_value = Attribute::ReshapeAttribute;
};

template<>
struct AttributeTraits<tosaFb::SliceAttribute>
{
    static const Attribute enum_value = Attribute::SliceAttribute;
};

template<>
struct AttributeTraits<tosaFb::TileAttribute>
{
    static const Attribute enum_value = Attribute::TileAttribute;
};

template<>
struct AttributeTraits<tosaFb::ResizeAttribute>
{
    static const Attribute enum_value = Attribute::ResizeAttribute;
};

template<>
struct AttributeTraits<tosaFb::ClampAttribute>
{
    static const Attribute enum_value = Attribute::ClampAttribute;
};

template<>
struct AttributeTraits<tosaFb::RescaleAttribute>
{
    static const Attribute enum_value = Attribute::RescaleAttribute;
};

template<>
struct AttributeTraits<tosaFb::MulAttribute>
{
    static const Attribute enum_value = Attribute::MulAttribute;
};

template<>
struct AttributeTraits<tosaFb::ArithmeticRightShiftAttribute>
{
    static const Attribute enum_value = Attribute::ArithmeticRightShiftAttribute;
};

template<>
struct AttributeTraits<tosaFb::CondIfAttribute>
{
    static const Attribute enum_value = Attribute::CondIfAttribute;
};

template<>
struct AttributeTraits<tosaFb::WhileLoopAttribute>
{
    static const Attribute enum_value = Attribute::WhileLoopAttribute;
};

template<>
struct AttributeTraits<tosaFb::TransposeAttribute>
{
    static const Attribute enum_value = Attribute::TransposeAttribute;
};

template<>
struct AttributeTraits<tosaFb::TableAttribute>
{
    static const Attribute enum_value = Attribute::TableAttribute;
};

template<>
struct AttributeTraits<tosaFb::MatMulAttribute>
{
    static const Attribute enum_value = Attribute::MatMulAttribute;
};

template<>
struct AttributeTraits<tosaFb::FullyConnectedAttribute>
{
    static const Attribute enum_value = Attribute::FullyConnectedAttribute;
};

template<>
struct AttributeTraits<tosaFb::NegateAttribute>
{
    static const Attribute enum_value = Attribute::NegateAttribute;
};

template<>
struct AttributeTraits<tosaFb::CustomAttribute>
{
    static const Attribute enum_value = Attribute::CustomAttribute;
};

template<>
struct AttributeTraits<tosaFb::FFTAttribute>
{
    static const Attribute enum_value = Attribute::FFTAttribute;
};

bool VerifyAttribute(::flatbuffers::Verifier &verifier, const void *obj, Attribute type);
bool VerifyAttributeVector(::flatbuffers::Verifier &verifier,
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Attribute> *types);

struct PoolAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef PoolAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return PoolAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_PAD = 4,
        VT_KERNEL = 6,
        VT_STRIDE = 8,
        VT_INPUT_ZP = 10,
        VT_OUTPUT_ZP = 12,
        VT_ACCUM_DTYPE = 14
    };
    const ::flatbuffers::Vector<int32_t> *pad() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PAD);
    }
    const ::flatbuffers::Vector<int32_t> *kernel() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_KERNEL);
    }
    const ::flatbuffers::Vector<int32_t> *stride() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDE);
    }
    int32_t input_zp() const { return GetField<int32_t>(VT_INPUT_ZP, 0); }
    int32_t output_zp() const { return GetField<int32_t>(VT_OUTPUT_ZP, 0); }
    tosaFb::DType accum_dtype() const { return static_cast<tosaFb::DType>(GetField<uint32_t>(VT_ACCUM_DTYPE, 0)); }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_PAD) && verifier.VerifyVector(pad()) && VerifyOffset(verifier, VT_KERNEL) &&
               verifier.VerifyVector(kernel()) && VerifyOffset(verifier, VT_STRIDE) && verifier.VerifyVector(stride()) &&
               VerifyField<int32_t>(verifier, VT_INPUT_ZP, 4) && VerifyField<int32_t>(verifier, VT_OUTPUT_ZP, 4) &&
               VerifyField<uint32_t>(verifier, VT_ACCUM_DTYPE, 4) && verifier.EndTable();
    }
};

struct PoolAttributeBuilder
{
    typedef PoolAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_pad(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad)
    {
        fbb_.AddOffset(PoolAttribute::VT_PAD, pad);
    }
    void add_kernel(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> kernel)
    {
        fbb_.AddOffset(PoolAttribute::VT_KERNEL, kernel);
    }
    void add_stride(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride)
    {
        fbb_.AddOffset(PoolAttribute::VT_STRIDE, stride);
    }
    void add_input_zp(int32_t input_zp) { fbb_.AddElement<int32_t>(PoolAttribute::VT_INPUT_ZP, input_zp, 0); }
    void add_output_zp(int32_t output_zp) { fbb_.AddElement<int32_t>(PoolAttribute::VT_OUTPUT_ZP, output_zp, 0); }
    void add_accum_dtype(tosaFb::DType accum_dtype)
    {
        fbb_.AddElement<uint32_t>(PoolAttribute::VT_ACCUM_DTYPE, static_cast<uint32_t>(accum_dtype), 0);
    }
    explicit PoolAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<PoolAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<PoolAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<PoolAttribute> CreatePoolAttribute(::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad = 0, ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> kernel = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride = 0, int32_t input_zp = 0, int32_t output_zp = 0,
    tosaFb::DType accum_dtype = tosaFb::DType::UNKNOWN)
{
    PoolAttributeBuilder builder_(_fbb);
    builder_.add_accum_dtype(accum_dtype);
    builder_.add_output_zp(output_zp);
    builder_.add_input_zp(input_zp);
    builder_.add_stride(stride);
    builder_.add_kernel(kernel);
    builder_.add_pad(pad);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<PoolAttribute> CreatePoolAttributeDirect(::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *pad = nullptr, const std::vector<int32_t> *kernel = nullptr, const std::vector<int32_t> *stride = nullptr,
    int32_t input_zp = 0, int32_t output_zp = 0, tosaFb::DType accum_dtype = tosaFb::DType::UNKNOWN)
{
    auto pad__ = pad ? _fbb.CreateVector<int32_t>(*pad) : 0;
    auto kernel__ = kernel ? _fbb.CreateVector<int32_t>(*kernel) : 0;
    auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
    return tosaFb::CreatePoolAttribute(_fbb, pad__, kernel__, stride__, input_zp, output_zp, accum_dtype);
}

struct ConvAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef ConvAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return ConvAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_PAD = 4,
        VT_STRIDE = 6,
        VT_DILATION = 8,
        VT_INPUT_ZP = 10,
        VT_WEIGHT_ZP = 12
    };
    const ::flatbuffers::Vector<int32_t> *pad() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PAD);
    }
    const ::flatbuffers::Vector<int32_t> *stride() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDE);
    }
    const ::flatbuffers::Vector<int32_t> *dilation() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_DILATION);
    }
    int32_t input_zp() const { return GetField<int32_t>(VT_INPUT_ZP, 0); }
    int32_t weight_zp() const { return GetField<int32_t>(VT_WEIGHT_ZP, 0); }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_PAD) && verifier.VerifyVector(pad()) &&
               VerifyOffset(verifier, VT_STRIDE) && verifier.VerifyVector(stride()) && VerifyOffset(verifier, VT_DILATION) &&
               verifier.VerifyVector(dilation()) && VerifyField<int32_t>(verifier, VT_INPUT_ZP, 4) &&
               VerifyField<int32_t>(verifier, VT_WEIGHT_ZP, 4) && verifier.EndTable();
    }
};

struct ConvAttributeBuilder
{
    typedef ConvAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_pad(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad)
    {
        fbb_.AddOffset(ConvAttribute::VT_PAD, pad);
    }
    void add_stride(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride)
    {
        fbb_.AddOffset(ConvAttribute::VT_STRIDE, stride);
    }
    void add_dilation(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dilation)
    {
        fbb_.AddOffset(ConvAttribute::VT_DILATION, dilation);
    }
    void add_input_zp(int32_t input_zp) { fbb_.AddElement<int32_t>(ConvAttribute::VT_INPUT_ZP, input_zp, 0); }
    void add_weight_zp(int32_t weight_zp) { fbb_.AddElement<int32_t>(ConvAttribute::VT_WEIGHT_ZP, weight_zp, 0); }
    explicit ConvAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<ConvAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ConvAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<ConvAttribute> CreateConvAttribute(::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pad = 0, ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dilation = 0, int32_t input_zp = 0, int32_t weight_zp = 0)
{
    ConvAttributeBuilder builder_(_fbb);
    builder_.add_weight_zp(weight_zp);
    builder_.add_input_zp(input_zp);
    builder_.add_dilation(dilation);
    builder_.add_stride(stride);
    builder_.add_pad(pad);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<ConvAttribute> CreateConvAttributeDirect(::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *pad = nullptr, const std::vector<int32_t> *stride = nullptr,
    const std::vector<int32_t> *dilation = nullptr, int32_t input_zp = 0, int32_t weight_zp = 0)
{
    auto pad__ = pad ? _fbb.CreateVector<int32_t>(*pad) : 0;
    auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
    auto dilation__ = dilation ? _fbb.CreateVector<int32_t>(*dilation) : 0;
    return tosaFb::CreateConvAttribute(_fbb, pad__, stride__, dilation__, input_zp, weight_zp);
}

struct TransposeConvAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TransposeConvAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return TransposeConvAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_OUT_PAD = 4,
        VT_STRIDE = 6,
        VT_OUTPUT_SHAPE = 8,
        VT_INPUT_ZP = 10,
        VT_WEIGHT_ZP = 12
    };
    const ::flatbuffers::Vector<int32_t> *out_pad() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUT_PAD);
    }
    const ::flatbuffers::Vector<int32_t> *stride() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDE);
    }
    const ::flatbuffers::Vector<int32_t> *output_shape() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUT_SHAPE);
    }
    int32_t input_zp() const { return GetField<int32_t>(VT_INPUT_ZP, 0); }
    int32_t weight_zp() const { return GetField<int32_t>(VT_WEIGHT_ZP, 0); }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_OUT_PAD) && verifier.VerifyVector(out_pad()) &&
               VerifyOffset(verifier, VT_STRIDE) && verifier.VerifyVector(stride()) && VerifyOffset(verifier, VT_OUTPUT_SHAPE) &&
               verifier.VerifyVector(output_shape()) && VerifyField<int32_t>(verifier, VT_INPUT_ZP, 4) &&
               VerifyField<int32_t>(verifier, VT_WEIGHT_ZP, 4) && verifier.EndTable();
    }
};

struct TransposeConvAttributeBuilder
{
    typedef TransposeConvAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_out_pad(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> out_pad)
    {
        fbb_.AddOffset(TransposeConvAttribute::VT_OUT_PAD, out_pad);
    }
    void add_stride(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride)
    {
        fbb_.AddOffset(TransposeConvAttribute::VT_STRIDE, stride);
    }
    void add_output_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> output_shape)
    {
        fbb_.AddOffset(TransposeConvAttribute::VT_OUTPUT_SHAPE, output_shape);
    }
    void add_input_zp(int32_t input_zp) { fbb_.AddElement<int32_t>(TransposeConvAttribute::VT_INPUT_ZP, input_zp, 0); }
    void add_weight_zp(int32_t weight_zp)
    {
        fbb_.AddElement<int32_t>(TransposeConvAttribute::VT_WEIGHT_ZP, weight_zp, 0);
    }
    explicit TransposeConvAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<TransposeConvAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TransposeConvAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TransposeConvAttribute> CreateTransposeConvAttribute(::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> out_pad = 0, ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> output_shape = 0, int32_t input_zp = 0, int32_t weight_zp = 0)
{
    TransposeConvAttributeBuilder builder_(_fbb);
    builder_.add_weight_zp(weight_zp);
    builder_.add_input_zp(input_zp);
    builder_.add_output_shape(output_shape);
    builder_.add_stride(stride);
    builder_.add_out_pad(out_pad);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<TransposeConvAttribute> CreateTransposeConvAttributeDirect(::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *out_pad = nullptr, const std::vector<int32_t> *stride = nullptr,
    const std::vector<int32_t> *output_shape = nullptr, int32_t input_zp = 0, int32_t weight_zp = 0)
{
    auto out_pad__ = out_pad ? _fbb.CreateVector<int32_t>(*out_pad) : 0;
    auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
    auto output_shape__ = output_shape ? _fbb.CreateVector<int32_t>(*output_shape) : 0;
    return tosaFb::CreateTransposeConvAttribute(_fbb, out_pad__, stride__, output_shape__, input_zp, weight_zp);
}

struct PadAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef PadAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return PadAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_PADDING = 4,
        VT_PAD_CONST_INT = 6,
        VT_PAD_CONST_FP = 8
    };
    const ::flatbuffers::Vector<int32_t> *padding() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PADDING);
    }
    int32_t pad_const_int() const { return GetField<int32_t>(VT_PAD_CONST_INT, 0); }
    const ::flatbuffers::Vector<uint8_t> *pad_const_fp() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PAD_CONST_FP);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_PADDING) && verifier.VerifyVector(padding()) &&
               VerifyField<int32_t>(verifier, VT_PAD_CONST_INT, 4) && VerifyOffset(verifier, VT_PAD_CONST_FP) &&
               verifier.VerifyVector(pad_const_fp()) && verifier.EndTable();
    }
};

struct PadAttributeBuilder
{
    typedef PadAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_padding(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> padding)
    {
        fbb_.AddOffset(PadAttribute::VT_PADDING, padding);
    }
    void add_pad_const_int(int32_t pad_const_int)
    {
        fbb_.AddElement<int32_t>(PadAttribute::VT_PAD_CONST_INT, pad_const_int, 0);
    }
    void add_pad_const_fp(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> pad_const_fp)
    {
        fbb_.AddOffset(PadAttribute::VT_PAD_CONST_FP, pad_const_fp);
    }
    explicit PadAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<PadAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<PadAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<PadAttribute> CreatePadAttribute(::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> padding = 0, int32_t pad_const_int = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> pad_const_fp = 0)
{
    PadAttributeBuilder builder_(_fbb);
    builder_.add_pad_const_fp(pad_const_fp);
    builder_.add_pad_const_int(pad_const_int);
    builder_.add_padding(padding);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<PadAttribute> CreatePadAttributeDirect(::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *padding = nullptr, int32_t pad_const_int = 0, const std::vector<uint8_t> *pad_const_fp = nullptr)
{
    auto padding__ = padding ? _fbb.CreateVector<int32_t>(*padding) : 0;
    if ( pad_const_fp )
    {
        _fbb.ForceVectorAlignment(pad_const_fp->size(), sizeof(uint8_t), 8);
    }
    auto pad_const_fp__ = pad_const_fp ? _fbb.CreateVector<uint8_t>(*pad_const_fp) : 0;
    return tosaFb::CreatePadAttribute(_fbb, padding__, pad_const_int, pad_const_fp__);
}

struct AxisAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef AxisAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return AxisAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_AXIS = 4
    };
    int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_AXIS, 4) && verifier.EndTable();
    }
};

struct AxisAttributeBuilder
{
    typedef AxisAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_axis(int32_t axis) { fbb_.AddElement<int32_t>(AxisAttribute::VT_AXIS, axis, 0); }
    explicit AxisAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<AxisAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<AxisAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<AxisAttribute> CreateAxisAttribute(::flatbuffers::FlatBufferBuilder &_fbb, int32_t axis = 0)
{
    AxisAttributeBuilder builder_(_fbb);
    builder_.add_axis(axis);
    return builder_.Finish();
}

struct ReshapeAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef ReshapeAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return ReshapeAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_NEW_SHAPE = 4
    };
    const ::flatbuffers::Vector<int32_t> *new_shape() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NEW_SHAPE) &&
               verifier.VerifyVector(new_shape()) && verifier.EndTable();
    }
};

struct ReshapeAttributeBuilder
{
    typedef ReshapeAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_new_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> new_shape)
    {
        fbb_.AddOffset(ReshapeAttribute::VT_NEW_SHAPE, new_shape);
    }
    explicit ReshapeAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ReshapeAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ReshapeAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<ReshapeAttribute> CreateReshapeAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> new_shape = 0)
{
    ReshapeAttributeBuilder builder_(_fbb);
    builder_.add_new_shape(new_shape);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<ReshapeAttribute>
CreateReshapeAttributeDirect(::flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int32_t> *new_shape = nullptr)
{
    auto new_shape__ = new_shape ? _fbb.CreateVector<int32_t>(*new_shape) : 0;
    return tosaFb::CreateReshapeAttribute(_fbb, new_shape__);
}

struct SliceAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef SliceAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return SliceAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_START = 4,
        VT_SIZE = 6
    };
    const ::flatbuffers::Vector<int32_t> *start() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_START);
    }
    const ::flatbuffers::Vector<int32_t> *size() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SIZE);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_START) && verifier.VerifyVector(start()) &&
               VerifyOffset(verifier, VT_SIZE) && verifier.VerifyVector(size()) && verifier.EndTable();
    }
};

struct SliceAttributeBuilder
{
    typedef SliceAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_start(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> start)
    {
        fbb_.AddOffset(SliceAttribute::VT_START, start);
    }
    void add_size(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> size)
    {
        fbb_.AddOffset(SliceAttribute::VT_SIZE, size);
    }
    explicit SliceAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<SliceAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<SliceAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<SliceAttribute> CreateSliceAttribute(::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> start = 0, ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> size = 0)
{
    SliceAttributeBuilder builder_(_fbb);
    builder_.add_size(size);
    builder_.add_start(start);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<SliceAttribute> CreateSliceAttributeDirect(::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *start = nullptr, const std::vector<int32_t> *size = nullptr)
{
    auto start__ = start ? _fbb.CreateVector<int32_t>(*start) : 0;
    auto size__ = size ? _fbb.CreateVector<int32_t>(*size) : 0;
    return tosaFb::CreateSliceAttribute(_fbb, start__, size__);
}

struct TileAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TileAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return TileAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_MULTIPLES = 4
    };
    const ::flatbuffers::Vector<int32_t> *multiples() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_MULTIPLES);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_MULTIPLES) &&
               verifier.VerifyVector(multiples()) && verifier.EndTable();
    }
};

struct TileAttributeBuilder
{
    typedef TileAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_multiples(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> multiples)
    {
        fbb_.AddOffset(TileAttribute::VT_MULTIPLES, multiples);
    }
    explicit TileAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<TileAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TileAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TileAttribute> CreateTileAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> multiples = 0)
{
    TileAttributeBuilder builder_(_fbb);
    builder_.add_multiples(multiples);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<TileAttribute>
CreateTileAttributeDirect(::flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int32_t> *multiples = nullptr)
{
    auto multiples__ = multiples ? _fbb.CreateVector<int32_t>(*multiples) : 0;
    return tosaFb::CreateTileAttribute(_fbb, multiples__);
}

struct ResizeAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef ResizeAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return ResizeAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_SCALE = 4,
        VT_OFFSET = 6,
        VT_BORDER = 8,
        VT_MODE = 10
    };
    const ::flatbuffers::Vector<int16_t> *scale() const
    {
        return GetPointer<const ::flatbuffers::Vector<int16_t> *>(VT_SCALE);
    }
    const ::flatbuffers::Vector<int16_t> *offset() const
    {
        return GetPointer<const ::flatbuffers::Vector<int16_t> *>(VT_OFFSET);
    }
    const ::flatbuffers::Vector<int16_t> *border() const
    {
        return GetPointer<const ::flatbuffers::Vector<int16_t> *>(VT_BORDER);
    }
    tosaFb::ResizeMode mode() const { return static_cast<tosaFb::ResizeMode>(GetField<uint32_t>(VT_MODE, 0)); }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SCALE) && verifier.VerifyVector(scale()) &&
               VerifyOffset(verifier, VT_OFFSET) && verifier.VerifyVector(offset()) && VerifyOffset(verifier, VT_BORDER) &&
               verifier.VerifyVector(border()) && VerifyField<uint32_t>(verifier, VT_MODE, 4) && verifier.EndTable();
    }
};

struct ResizeAttributeBuilder
{
    typedef ResizeAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_scale(::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> scale)
    {
        fbb_.AddOffset(ResizeAttribute::VT_SCALE, scale);
    }
    void add_offset(::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> offset)
    {
        fbb_.AddOffset(ResizeAttribute::VT_OFFSET, offset);
    }
    void add_border(::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> border)
    {
        fbb_.AddOffset(ResizeAttribute::VT_BORDER, border);
    }
    void add_mode(tosaFb::ResizeMode mode)
    {
        fbb_.AddElement<uint32_t>(ResizeAttribute::VT_MODE, static_cast<uint32_t>(mode), 0);
    }
    explicit ResizeAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<ResizeAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ResizeAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<ResizeAttribute> CreateResizeAttribute(::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> scale = 0, ::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> offset = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> border = 0, tosaFb::ResizeMode mode = tosaFb::ResizeMode::UNKNOWN)
{
    ResizeAttributeBuilder builder_(_fbb);
    builder_.add_mode(mode);
    builder_.add_border(border);
    builder_.add_offset(offset);
    builder_.add_scale(scale);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<ResizeAttribute> CreateResizeAttributeDirect(::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int16_t> *scale = nullptr, const std::vector<int16_t> *offset = nullptr,
    const std::vector<int16_t> *border = nullptr, tosaFb::ResizeMode mode = tosaFb::ResizeMode::UNKNOWN)
{
    auto scale__ = scale ? _fbb.CreateVector<int16_t>(*scale) : 0;
    auto offset__ = offset ? _fbb.CreateVector<int16_t>(*offset) : 0;
    auto border__ = border ? _fbb.CreateVector<int16_t>(*border) : 0;
    return tosaFb::CreateResizeAttribute(_fbb, scale__, offset__, border__, mode);
}

struct ClampAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef ClampAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return ClampAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_MIN_INT = 4,
        VT_MAX_INT = 6,
        VT_MIN_FP = 8,
        VT_MAX_FP = 10
    };
    int32_t min_int() const { return GetField<int32_t>(VT_MIN_INT, 0); }
    int32_t max_int() const { return GetField<int32_t>(VT_MAX_INT, 0); }
    const ::flatbuffers::Vector<uint8_t> *min_fp() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_MIN_FP);
    }
    const ::flatbuffers::Vector<uint8_t> *max_fp() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_MAX_FP);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_MIN_INT, 4) &&
               VerifyField<int32_t>(verifier, VT_MAX_INT, 4) && VerifyOffset(verifier, VT_MIN_FP) && verifier.VerifyVector(min_fp()) &&
               VerifyOffset(verifier, VT_MAX_FP) && verifier.VerifyVector(max_fp()) && verifier.EndTable();
    }
};

struct ClampAttributeBuilder
{
    typedef ClampAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_min_int(int32_t min_int) { fbb_.AddElement<int32_t>(ClampAttribute::VT_MIN_INT, min_int, 0); }
    void add_max_int(int32_t max_int) { fbb_.AddElement<int32_t>(ClampAttribute::VT_MAX_INT, max_int, 0); }
    void add_min_fp(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> min_fp)
    {
        fbb_.AddOffset(ClampAttribute::VT_MIN_FP, min_fp);
    }
    void add_max_fp(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> max_fp)
    {
        fbb_.AddOffset(ClampAttribute::VT_MAX_FP, max_fp);
    }
    explicit ClampAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<ClampAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ClampAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<ClampAttribute> CreateClampAttribute(::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min_int = 0, int32_t max_int = 0, ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> min_fp = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> max_fp = 0)
{
    ClampAttributeBuilder builder_(_fbb);
    builder_.add_max_fp(max_fp);
    builder_.add_min_fp(min_fp);
    builder_.add_max_int(max_int);
    builder_.add_min_int(min_int);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<ClampAttribute> CreateClampAttributeDirect(::flatbuffers::FlatBufferBuilder &_fbb, int32_t min_int = 0,
    int32_t max_int = 0, const std::vector<uint8_t> *min_fp = nullptr, const std::vector<uint8_t> *max_fp = nullptr)
{
    if ( min_fp )
    {
        _fbb.ForceVectorAlignment(min_fp->size(), sizeof(uint8_t), 8);
    }
    auto min_fp__ = min_fp ? _fbb.CreateVector<uint8_t>(*min_fp) : 0;
    if ( max_fp )
    {
        _fbb.ForceVectorAlignment(max_fp->size(), sizeof(uint8_t), 8);
    }
    auto max_fp__ = max_fp ? _fbb.CreateVector<uint8_t>(*max_fp) : 0;
    return tosaFb::CreateClampAttribute(_fbb, min_int, max_int, min_fp__, max_fp__);
}

struct RescaleAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef RescaleAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return RescaleAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_INPUT_ZP = 4,
        VT_OUTPUT_ZP = 6,
        VT_MULTIPLIER = 8,
        VT_SHIFT = 10,
        VT_SCALE32 = 12,
        VT_DOUBLE_ROUND = 14,
        VT_PER_CHANNEL = 16,
        VT_INPUT_UNSIGNED = 18,
        VT_OUTPUT_UNSIGNED = 20
    };
    int32_t input_zp() const { return GetField<int32_t>(VT_INPUT_ZP, 0); }
    int32_t output_zp() const { return GetField<int32_t>(VT_OUTPUT_ZP, 0); }
    const ::flatbuffers::Vector<int32_t> *multiplier() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_MULTIPLIER);
    }
    const ::flatbuffers::Vector<int32_t> *shift() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHIFT);
    }
    bool scale32() const { return GetField<uint8_t>(VT_SCALE32, 0) != 0; }
    bool double_round() const { return GetField<uint8_t>(VT_DOUBLE_ROUND, 0) != 0; }
    bool per_channel() const { return GetField<uint8_t>(VT_PER_CHANNEL, 0) != 0; }
    bool input_unsigned() const { return GetField<uint8_t>(VT_INPUT_UNSIGNED, 0) != 0; }
    bool output_unsigned() const { return GetField<uint8_t>(VT_OUTPUT_UNSIGNED, 0) != 0; }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_INPUT_ZP, 4) &&
               VerifyField<int32_t>(verifier, VT_OUTPUT_ZP, 4) && VerifyOffset(verifier, VT_MULTIPLIER) &&
               verifier.VerifyVector(multiplier()) && VerifyOffset(verifier, VT_SHIFT) && verifier.VerifyVector(shift()) &&
               VerifyField<uint8_t>(verifier, VT_SCALE32, 1) && VerifyField<uint8_t>(verifier, VT_DOUBLE_ROUND, 1) &&
               VerifyField<uint8_t>(verifier, VT_PER_CHANNEL, 1) && VerifyField<uint8_t>(verifier, VT_INPUT_UNSIGNED, 1) &&
               VerifyField<uint8_t>(verifier, VT_OUTPUT_UNSIGNED, 1) && verifier.EndTable();
    }
};

struct RescaleAttributeBuilder
{
    typedef RescaleAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_input_zp(int32_t input_zp) { fbb_.AddElement<int32_t>(RescaleAttribute::VT_INPUT_ZP, input_zp, 0); }
    void add_output_zp(int32_t output_zp) { fbb_.AddElement<int32_t>(RescaleAttribute::VT_OUTPUT_ZP, output_zp, 0); }
    void add_multiplier(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> multiplier)
    {
        fbb_.AddOffset(RescaleAttribute::VT_MULTIPLIER, multiplier);
    }
    void add_shift(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shift)
    {
        fbb_.AddOffset(RescaleAttribute::VT_SHIFT, shift);
    }
    void add_scale32(bool scale32)
    {
        fbb_.AddElement<uint8_t>(RescaleAttribute::VT_SCALE32, static_cast<uint8_t>(scale32), 0);
    }
    void add_double_round(bool double_round)
    {
        fbb_.AddElement<uint8_t>(RescaleAttribute::VT_DOUBLE_ROUND, static_cast<uint8_t>(double_round), 0);
    }
    void add_per_channel(bool per_channel)
    {
        fbb_.AddElement<uint8_t>(RescaleAttribute::VT_PER_CHANNEL, static_cast<uint8_t>(per_channel), 0);
    }
    void add_input_unsigned(bool input_unsigned)
    {
        fbb_.AddElement<uint8_t>(RescaleAttribute::VT_INPUT_UNSIGNED, static_cast<uint8_t>(input_unsigned), 0);
    }
    void add_output_unsigned(bool output_unsigned)
    {
        fbb_.AddElement<uint8_t>(RescaleAttribute::VT_OUTPUT_UNSIGNED, static_cast<uint8_t>(output_unsigned), 0);
    }
    explicit RescaleAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<RescaleAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<RescaleAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<RescaleAttribute> CreateRescaleAttribute(::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t input_zp = 0, int32_t output_zp = 0, ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> multiplier = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shift = 0, bool scale32 = false, bool double_round = false,
    bool per_channel = false, bool input_unsigned = false, bool output_unsigned = false)
{
    RescaleAttributeBuilder builder_(_fbb);
    builder_.add_shift(shift);
    builder_.add_multiplier(multiplier);
    builder_.add_output_zp(output_zp);
    builder_.add_input_zp(input_zp);
    builder_.add_output_unsigned(output_unsigned);
    builder_.add_input_unsigned(input_unsigned);
    builder_.add_per_channel(per_channel);
    builder_.add_double_round(double_round);
    builder_.add_scale32(scale32);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<RescaleAttribute>
CreateRescaleAttributeDirect(::flatbuffers::FlatBufferBuilder &_fbb, int32_t input_zp = 0, int32_t output_zp = 0,
    const std::vector<int32_t> *multiplier = nullptr, const std::vector<int32_t> *shift = nullptr, bool scale32 = false,
    bool double_round = false, bool per_channel = false, bool input_unsigned = false, bool output_unsigned = false)
{
    auto multiplier__ = multiplier ? _fbb.CreateVector<int32_t>(*multiplier) : 0;
    auto shift__ = shift ? _fbb.CreateVector<int32_t>(*shift) : 0;
    return tosaFb::CreateRescaleAttribute(_fbb, input_zp, output_zp, multiplier__, shift__, scale32, double_round,
        per_channel, input_unsigned, output_unsigned);
}

struct MulAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef MulAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return MulAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_SHIFT = 4
    };
    int32_t shift() const { return GetField<int32_t>(VT_SHIFT, 0); }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_SHIFT, 4) && verifier.EndTable();
    }
};

struct MulAttributeBuilder
{
    typedef MulAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_shift(int32_t shift) { fbb_.AddElement<int32_t>(MulAttribute::VT_SHIFT, shift, 0); }
    explicit MulAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<MulAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<MulAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<MulAttribute> CreateMulAttribute(::flatbuffers::FlatBufferBuilder &_fbb, int32_t shift = 0)
{
    MulAttributeBuilder builder_(_fbb);
    builder_.add_shift(shift);
    return builder_.Finish();
}

struct ArithmeticRightShiftAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef ArithmeticRightShiftAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return ArithmeticRightShiftAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_ROUND = 4
    };
    bool round() const { return GetField<uint8_t>(VT_ROUND, 0) != 0; }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_ROUND, 1) && verifier.EndTable();
    }
};

struct ArithmeticRightShiftAttributeBuilder
{
    typedef ArithmeticRightShiftAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_round(bool round)
    {
        fbb_.AddElement<uint8_t>(ArithmeticRightShiftAttribute::VT_ROUND, static_cast<uint8_t>(round), 0);
    }
    explicit ArithmeticRightShiftAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ArithmeticRightShiftAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ArithmeticRightShiftAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<ArithmeticRightShiftAttribute>
CreateArithmeticRightShiftAttribute(::flatbuffers::FlatBufferBuilder &_fbb, bool round = false)
{
    ArithmeticRightShiftAttributeBuilder builder_(_fbb);
    builder_.add_round(round);
    return builder_.Finish();
}

struct CondIfAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef CondIfAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return CondIfAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_THEN_BRANCH = 4,
        VT_ELSE_BRANCH = 6
    };
    const ::flatbuffers::String *then_branch() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_THEN_BRANCH);
    }
    const ::flatbuffers::String *else_branch() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_ELSE_BRANCH);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_THEN_BRANCH) && verifier.VerifyString(then_branch()) &&
               VerifyOffset(verifier, VT_ELSE_BRANCH) && verifier.VerifyString(else_branch()) && verifier.EndTable();
    }
};

struct CondIfAttributeBuilder
{
    typedef CondIfAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_then_branch(::flatbuffers::Offset<::flatbuffers::String> then_branch)
    {
        fbb_.AddOffset(CondIfAttribute::VT_THEN_BRANCH, then_branch);
    }
    void add_else_branch(::flatbuffers::Offset<::flatbuffers::String> else_branch)
    {
        fbb_.AddOffset(CondIfAttribute::VT_ELSE_BRANCH, else_branch);
    }
    explicit CondIfAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<CondIfAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<CondIfAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<CondIfAttribute> CreateCondIfAttribute(::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> then_branch = 0, ::flatbuffers::Offset<::flatbuffers::String> else_branch = 0)
{
    CondIfAttributeBuilder builder_(_fbb);
    builder_.add_else_branch(else_branch);
    builder_.add_then_branch(then_branch);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<CondIfAttribute> CreateCondIfAttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *then_branch = nullptr, const char *else_branch = nullptr)
{
    auto then_branch__ = then_branch ? _fbb.CreateString(then_branch) : 0;
    auto else_branch__ = else_branch ? _fbb.CreateString(else_branch) : 0;
    return tosaFb::CreateCondIfAttribute(_fbb, then_branch__, else_branch__);
}

struct WhileLoopAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef WhileLoopAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return WhileLoopAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_COND_BRANCH = 4,
        VT_BODY_BRANCH = 6
    };
    const ::flatbuffers::String *cond_branch() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_COND_BRANCH);
    }
    const ::flatbuffers::String *body_branch() const
    {
        return GetPointer<const ::flatbuffers::String *>(VT_BODY_BRANCH);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_COND_BRANCH) && verifier.VerifyString(cond_branch()) &&
               VerifyOffset(verifier, VT_BODY_BRANCH) && verifier.VerifyString(body_branch()) && verifier.EndTable();
    }
};

struct WhileLoopAttributeBuilder
{
    typedef WhileLoopAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_cond_branch(::flatbuffers::Offset<::flatbuffers::String> cond_branch)
    {
        fbb_.AddOffset(WhileLoopAttribute::VT_COND_BRANCH, cond_branch);
    }
    void add_body_branch(::flatbuffers::Offset<::flatbuffers::String> body_branch)
    {
        fbb_.AddOffset(WhileLoopAttribute::VT_BODY_BRANCH, body_branch);
    }
    explicit WhileLoopAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<WhileLoopAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<WhileLoopAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<WhileLoopAttribute> CreateWhileLoopAttribute(::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> cond_branch = 0, ::flatbuffers::Offset<::flatbuffers::String> body_branch = 0)
{
    WhileLoopAttributeBuilder builder_(_fbb);
    builder_.add_body_branch(body_branch);
    builder_.add_cond_branch(cond_branch);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<WhileLoopAttribute> CreateWhileLoopAttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *cond_branch = nullptr, const char *body_branch = nullptr)
{
    auto cond_branch__ = cond_branch ? _fbb.CreateString(cond_branch) : 0;
    auto body_branch__ = body_branch ? _fbb.CreateString(body_branch) : 0;
    return tosaFb::CreateWhileLoopAttribute(_fbb, cond_branch__, body_branch__);
}

struct TransposeAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TransposeAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return TransposeAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_PERMS = 4
    };
    const ::flatbuffers::Vector<int32_t> *perms() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PERMS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_PERMS) && verifier.VerifyVector(perms()) &&
               verifier.EndTable();
    }
};

struct TransposeAttributeBuilder
{
    typedef TransposeAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_perms(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> perms)
    {
        fbb_.AddOffset(TransposeAttribute::VT_PERMS, perms);
    }
    explicit TransposeAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<TransposeAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TransposeAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TransposeAttribute> CreateTransposeAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> perms = 0)
{
    TransposeAttributeBuilder builder_(_fbb);
    builder_.add_perms(perms);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<TransposeAttribute>
CreateTransposeAttributeDirect(::flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int32_t> *perms = nullptr)
{
    auto perms__ = perms ? _fbb.CreateVector<int32_t>(*perms) : 0;
    return tosaFb::CreateTransposeAttribute(_fbb, perms__);
}

struct TableAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TableAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return TableAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_TABLE = 4
    };
    const ::flatbuffers::Vector<int16_t> *table() const
    {
        return GetPointer<const ::flatbuffers::Vector<int16_t> *>(VT_TABLE);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TABLE) && verifier.VerifyVector(table()) &&
               verifier.EndTable();
    }
};

struct TableAttributeBuilder
{
    typedef TableAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_table(::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> table)
    {
        fbb_.AddOffset(TableAttribute::VT_TABLE, table);
    }
    explicit TableAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<TableAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TableAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TableAttribute> CreateTableAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> table = 0)
{
    TableAttributeBuilder builder_(_fbb);
    builder_.add_table(table);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<TableAttribute>
CreateTableAttributeDirect(::flatbuffers::FlatBufferBuilder &_fbb, const std::vector<int16_t> *table = nullptr)
{
    auto table__ = table ? _fbb.CreateVector<int16_t>(*table) : 0;
    return tosaFb::CreateTableAttribute(_fbb, table__);
}

struct MatMulAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef MatMulAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return MatMulAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_A_ZP = 4,
        VT_B_ZP = 6
    };
    int32_t a_zp() const { return GetField<int32_t>(VT_A_ZP, 0); }
    int32_t b_zp() const { return GetField<int32_t>(VT_B_ZP, 0); }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_A_ZP, 4) &&
               VerifyField<int32_t>(verifier, VT_B_ZP, 4) && verifier.EndTable();
    }
};

struct MatMulAttributeBuilder
{
    typedef MatMulAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_a_zp(int32_t a_zp) { fbb_.AddElement<int32_t>(MatMulAttribute::VT_A_ZP, a_zp, 0); }
    void add_b_zp(int32_t b_zp) { fbb_.AddElement<int32_t>(MatMulAttribute::VT_B_ZP, b_zp, 0); }
    explicit MatMulAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<MatMulAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<MatMulAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<MatMulAttribute>
CreateMatMulAttribute(::flatbuffers::FlatBufferBuilder &_fbb, int32_t a_zp = 0, int32_t b_zp = 0)
{
    MatMulAttributeBuilder builder_(_fbb);
    builder_.add_b_zp(b_zp);
    builder_.add_a_zp(a_zp);
    return builder_.Finish();
}

struct FullyConnectedAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef FullyConnectedAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return FullyConnectedAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_INPUT_ZP = 4,
        VT_WEIGHT_ZP = 6
    };
    int32_t input_zp() const { return GetField<int32_t>(VT_INPUT_ZP, 0); }
    int32_t weight_zp() const { return GetField<int32_t>(VT_WEIGHT_ZP, 0); }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_INPUT_ZP, 4) &&
               VerifyField<int32_t>(verifier, VT_WEIGHT_ZP, 4) && verifier.EndTable();
    }
};

struct FullyConnectedAttributeBuilder
{
    typedef FullyConnectedAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_input_zp(int32_t input_zp) { fbb_.AddElement<int32_t>(FullyConnectedAttribute::VT_INPUT_ZP, input_zp, 0); }
    void add_weight_zp(int32_t weight_zp)
    {
        fbb_.AddElement<int32_t>(FullyConnectedAttribute::VT_WEIGHT_ZP, weight_zp, 0);
    }
    explicit FullyConnectedAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<FullyConnectedAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<FullyConnectedAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<FullyConnectedAttribute>
CreateFullyConnectedAttribute(::flatbuffers::FlatBufferBuilder &_fbb, int32_t input_zp = 0, int32_t weight_zp = 0)
{
    FullyConnectedAttributeBuilder builder_(_fbb);
    builder_.add_weight_zp(weight_zp);
    builder_.add_input_zp(input_zp);
    return builder_.Finish();
}

struct NegateAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef NegateAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return NegateAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_INPUT1_ZP = 4,
        VT_OUTPUT_ZP = 6
    };
    int32_t input1_zp() const { return GetField<int32_t>(VT_INPUT1_ZP, 0); }
    int32_t output_zp() const { return GetField<int32_t>(VT_OUTPUT_ZP, 0); }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_INPUT1_ZP, 4) &&
               VerifyField<int32_t>(verifier, VT_OUTPUT_ZP, 4) && verifier.EndTable();
    }
};

struct NegateAttributeBuilder
{
    typedef NegateAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_input1_zp(int32_t input1_zp) { fbb_.AddElement<int32_t>(NegateAttribute::VT_INPUT1_ZP, input1_zp, 0); }
    void add_output_zp(int32_t output_zp) { fbb_.AddElement<int32_t>(NegateAttribute::VT_OUTPUT_ZP, output_zp, 0); }
    explicit NegateAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<NegateAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<NegateAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<NegateAttribute>
CreateNegateAttribute(::flatbuffers::FlatBufferBuilder &_fbb, int32_t input1_zp = 0, int32_t output_zp = 0)
{
    NegateAttributeBuilder builder_(_fbb);
    builder_.add_output_zp(output_zp);
    builder_.add_input1_zp(input1_zp);
    return builder_.Finish();
}

struct CustomAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef CustomAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return CustomAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_IDENTIFIER = 4,
        VT_CONFIG = 6,
        VT_IMPLEMENTATION_ATTRS = 8
    };
    const ::flatbuffers::String *identifier() const { return GetPointer<const ::flatbuffers::String *>(VT_IDENTIFIER); }
    const ::flatbuffers::String *config() const { return GetPointer<const ::flatbuffers::String *>(VT_CONFIG); }
    const ::flatbuffers::Vector<uint8_t> *implementation_attrs() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_IMPLEMENTATION_ATTRS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_IDENTIFIER) && verifier.VerifyString(identifier()) &&
               VerifyOffset(verifier, VT_CONFIG) && verifier.VerifyString(config()) && VerifyOffset(verifier, VT_IMPLEMENTATION_ATTRS) &&
               verifier.VerifyVector(implementation_attrs()) && verifier.EndTable();
    }
};

struct CustomAttributeBuilder
{
    typedef CustomAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_identifier(::flatbuffers::Offset<::flatbuffers::String> identifier)
    {
        fbb_.AddOffset(CustomAttribute::VT_IDENTIFIER, identifier);
    }
    void add_config(::flatbuffers::Offset<::flatbuffers::String> config)
    {
        fbb_.AddOffset(CustomAttribute::VT_CONFIG, config);
    }
    void add_implementation_attrs(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> implementation_attrs)
    {
        fbb_.AddOffset(CustomAttribute::VT_IMPLEMENTATION_ATTRS, implementation_attrs);
    }
    explicit CustomAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<CustomAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<CustomAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<CustomAttribute> CreateCustomAttribute(::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> identifier = 0, ::flatbuffers::Offset<::flatbuffers::String> config = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> implementation_attrs = 0)
{
    CustomAttributeBuilder builder_(_fbb);
    builder_.add_implementation_attrs(implementation_attrs);
    builder_.add_config(config);
    builder_.add_identifier(identifier);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<CustomAttribute> CreateCustomAttributeDirect(::flatbuffers::FlatBufferBuilder &_fbb,
    const char *identifier = nullptr, const char *config = nullptr, const std::vector<uint8_t> *implementation_attrs = nullptr)
{
    auto identifier__ = identifier ? _fbb.CreateString(identifier) : 0;
    auto config__ = config ? _fbb.CreateString(config) : 0;
    auto implementation_attrs__ = implementation_attrs ? _fbb.CreateVector<uint8_t>(*implementation_attrs) : 0;
    return tosaFb::CreateCustomAttribute(_fbb, identifier__, config__, implementation_attrs__);
}

struct FFTAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef FFTAttributeBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return FFTAttributeTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_INVERSE = 4
    };
    bool inverse() const { return GetField<uint8_t>(VT_INVERSE, 0) != 0; }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_INVERSE, 1) && verifier.EndTable();
    }
};

struct FFTAttributeBuilder
{
    typedef FFTAttribute Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_inverse(bool inverse)
    {
        fbb_.AddElement<uint8_t>(FFTAttribute::VT_INVERSE, static_cast<uint8_t>(inverse), 0);
    }
    explicit FFTAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<FFTAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<FFTAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<FFTAttribute> CreateFFTAttribute(::flatbuffers::FlatBufferBuilder &_fbb, bool inverse = false)
{
    FFTAttributeBuilder builder_(_fbb);
    builder_.add_inverse(inverse);
    return builder_.Finish();
}

struct Version FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef VersionBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return VersionTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT__MAJOR = 4,
        VT__MINOR = 6,
        VT__PATCH = 8,
        VT__DRAFT = 10
    };
    int32_t _major() const { return GetField<int32_t>(VT__MAJOR, -1); }
    int32_t _minor() const { return GetField<int32_t>(VT__MINOR, -1); }
    int32_t _patch() const { return GetField<int32_t>(VT__PATCH, -1); }
    bool _draft() const { return GetField<uint8_t>(VT__DRAFT, 1) != 0; }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT__MAJOR, 4) && VerifyField<int32_t>(verifier, VT__MINOR, 4) &&
               VerifyField<int32_t>(verifier, VT__PATCH, 4) && VerifyField<uint8_t>(verifier, VT__DRAFT, 1) && verifier.EndTable();
    }
};

struct VersionBuilder
{
    typedef Version Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add__major(int32_t _major) { fbb_.AddElement<int32_t>(Version::VT__MAJOR, _major, -1); }
    void add__minor(int32_t _minor) { fbb_.AddElement<int32_t>(Version::VT__MINOR, _minor, -1); }
    void add__patch(int32_t _patch) { fbb_.AddElement<int32_t>(Version::VT__PATCH, _patch, -1); }
    void add__draft(bool _draft) { fbb_.AddElement<uint8_t>(Version::VT__DRAFT, static_cast<uint8_t>(_draft), 1); }
    explicit VersionBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<Version> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<Version>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<Version> CreateVersion(::flatbuffers::FlatBufferBuilder &_fbb, int32_t _major = -1,
    int32_t _minor = -1, int32_t _patch = -1, bool _draft = true)
{
    VersionBuilder builder_(_fbb);
    builder_.add__patch(_patch);
    builder_.add__minor(_minor);
    builder_.add__major(_major);
    builder_.add__draft(_draft);
    return builder_.Finish();
}

struct TosaTensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TosaTensorBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return TosaTensorTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_NAME = 4,
        VT_SHAPE = 6,
        VT_TYPE = 8,
        VT_DATA = 10,
        VT_VARIABLE = 12,
        VT_IS_UNRANKED = 14
    };
    const ::flatbuffers::String *name() const { return GetPointer<const ::flatbuffers::String *>(VT_NAME); }
    const ::flatbuffers::Vector<int32_t> *shape() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
    }
    tosaFb::DType type() const { return static_cast<tosaFb::DType>(GetField<uint32_t>(VT_TYPE, 0)); }
    const ::flatbuffers::Vector<uint8_t> *data() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
    }
    bool variable() const { return GetField<uint8_t>(VT_VARIABLE, 0) != 0; }
    bool is_unranked() const { return GetField<uint8_t>(VT_IS_UNRANKED, 0) != 0; }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
               VerifyOffset(verifier, VT_SHAPE) && verifier.VerifyVector(shape()) && VerifyField<uint32_t>(verifier, VT_TYPE, 4) &&
               VerifyOffset(verifier, VT_DATA) && verifier.VerifyVector(data()) && VerifyField<uint8_t>(verifier, VT_VARIABLE, 1) &&
               VerifyField<uint8_t>(verifier, VT_IS_UNRANKED, 1) && verifier.EndTable();
    }
};

struct TosaTensorBuilder
{
    typedef TosaTensor Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name) { fbb_.AddOffset(TosaTensor::VT_NAME, name); }
    void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape)
    {
        fbb_.AddOffset(TosaTensor::VT_SHAPE, shape);
    }
    void add_type(tosaFb::DType type)
    {
        fbb_.AddElement<uint32_t>(TosaTensor::VT_TYPE, static_cast<uint32_t>(type), 0);
    }
    void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data)
    {
        fbb_.AddOffset(TosaTensor::VT_DATA, data);
    }
    void add_variable(bool variable)
    {
        fbb_.AddElement<uint8_t>(TosaTensor::VT_VARIABLE, static_cast<uint8_t>(variable), 0);
    }
    void add_is_unranked(bool is_unranked)
    {
        fbb_.AddElement<uint8_t>(TosaTensor::VT_IS_UNRANKED, static_cast<uint8_t>(is_unranked), 0);
    }
    explicit TosaTensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<TosaTensor> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TosaTensor>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TosaTensor>
CreateTosaTensor(::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0, tosaFb::DType type = tosaFb::DType::UNKNOWN,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0, bool variable = false, bool is_unranked = false)
{
    TosaTensorBuilder builder_(_fbb);
    builder_.add_data(data);
    builder_.add_type(type);
    builder_.add_shape(shape);
    builder_.add_name(name);
    builder_.add_is_unranked(is_unranked);
    builder_.add_variable(variable);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<TosaTensor> CreateTosaTensorDirect(::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr, const std::vector<int32_t> *shape = nullptr, tosaFb::DType type = tosaFb::DType::UNKNOWN,
    const std::vector<uint8_t> *data = nullptr, bool variable = false, bool is_unranked = false)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
    if ( data )
    {
        _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 8);
    }
    auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
    return tosaFb::CreateTosaTensor(_fbb, name__, shape__, type, data__, variable, is_unranked);
}

struct TosaOperator FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TosaOperatorBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return TosaOperatorTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_OP = 4,
        VT_ATTRIBUTE_TYPE = 6,
        VT_ATTRIBUTE = 8,
        VT_INPUTS = 10,
        VT_OUTPUTS = 12
    };
    tosaFb::Op op() const { return static_cast<tosaFb::Op>(GetField<uint32_t>(VT_OP, 0)); }
    tosaFb::Attribute attribute_type() const
    {
        return static_cast<tosaFb::Attribute>(GetField<uint8_t>(VT_ATTRIBUTE_TYPE, 0));
    }
    const void *attribute() const { return GetPointer<const void *>(VT_ATTRIBUTE); }
    template<typename T>
    const T *attribute_as() const;
    const tosaFb::PoolAttribute *attribute_as_PoolAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::PoolAttribute ? static_cast<const tosaFb::PoolAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::ConvAttribute *attribute_as_ConvAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::ConvAttribute ? static_cast<const tosaFb::ConvAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::TransposeConvAttribute *attribute_as_TransposeConvAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::TransposeConvAttribute ? static_cast<const tosaFb::TransposeConvAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::PadAttribute *attribute_as_PadAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::PadAttribute ? static_cast<const tosaFb::PadAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::AxisAttribute *attribute_as_AxisAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::AxisAttribute ? static_cast<const tosaFb::AxisAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::ReshapeAttribute *attribute_as_ReshapeAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::ReshapeAttribute ? static_cast<const tosaFb::ReshapeAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::SliceAttribute *attribute_as_SliceAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::SliceAttribute ? static_cast<const tosaFb::SliceAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::TileAttribute *attribute_as_TileAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::TileAttribute ? static_cast<const tosaFb::TileAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::ResizeAttribute *attribute_as_ResizeAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::ResizeAttribute ? static_cast<const tosaFb::ResizeAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::ClampAttribute *attribute_as_ClampAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::ClampAttribute ? static_cast<const tosaFb::ClampAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::RescaleAttribute *attribute_as_RescaleAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::RescaleAttribute ? static_cast<const tosaFb::RescaleAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::MulAttribute *attribute_as_MulAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::MulAttribute ? static_cast<const tosaFb::MulAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::ArithmeticRightShiftAttribute *attribute_as_ArithmeticRightShiftAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::ArithmeticRightShiftAttribute ? static_cast<const tosaFb::ArithmeticRightShiftAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::CondIfAttribute *attribute_as_CondIfAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::CondIfAttribute ? static_cast<const tosaFb::CondIfAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::WhileLoopAttribute *attribute_as_WhileLoopAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::WhileLoopAttribute ? static_cast<const tosaFb::WhileLoopAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::TransposeAttribute *attribute_as_TransposeAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::TransposeAttribute ? static_cast<const tosaFb::TransposeAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::TableAttribute *attribute_as_TableAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::TableAttribute ? static_cast<const tosaFb::TableAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::MatMulAttribute *attribute_as_MatMulAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::MatMulAttribute ? static_cast<const tosaFb::MatMulAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::FullyConnectedAttribute *attribute_as_FullyConnectedAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::FullyConnectedAttribute ? static_cast<const tosaFb::FullyConnectedAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::NegateAttribute *attribute_as_NegateAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::NegateAttribute ? static_cast<const tosaFb::NegateAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::CustomAttribute *attribute_as_CustomAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::CustomAttribute ? static_cast<const tosaFb::CustomAttribute *>(attribute()) : nullptr;
    }
    const tosaFb::FFTAttribute *attribute_as_FFTAttribute() const
    {
        return attribute_type() == tosaFb::Attribute::FFTAttribute ? static_cast<const tosaFb::FFTAttribute *>(attribute()) : nullptr;
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUTS);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUTS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_OP, 4) &&
               VerifyField<uint8_t>(verifier, VT_ATTRIBUTE_TYPE, 1) && VerifyOffset(verifier, VT_ATTRIBUTE) &&
               VerifyAttribute(verifier, attribute(), attribute_type()) && VerifyOffset(verifier, VT_INPUTS) &&
               verifier.VerifyVector(inputs()) && verifier.VerifyVectorOfStrings(inputs()) && VerifyOffset(verifier, VT_OUTPUTS) &&
               verifier.VerifyVector(outputs()) && verifier.VerifyVectorOfStrings(outputs()) && verifier.EndTable();
    }
};

template<>
inline const tosaFb::PoolAttribute *TosaOperator::attribute_as<tosaFb::PoolAttribute>() const
{
    return attribute_as_PoolAttribute();
}

template<>
inline const tosaFb::ConvAttribute *TosaOperator::attribute_as<tosaFb::ConvAttribute>() const
{
    return attribute_as_ConvAttribute();
}

template<>
inline const tosaFb::TransposeConvAttribute *TosaOperator::attribute_as<tosaFb::TransposeConvAttribute>() const
{
    return attribute_as_TransposeConvAttribute();
}

template<>
inline const tosaFb::PadAttribute *TosaOperator::attribute_as<tosaFb::PadAttribute>() const
{
    return attribute_as_PadAttribute();
}

template<>
inline const tosaFb::AxisAttribute *TosaOperator::attribute_as<tosaFb::AxisAttribute>() const
{
    return attribute_as_AxisAttribute();
}

template<>
inline const tosaFb::ReshapeAttribute *TosaOperator::attribute_as<tosaFb::ReshapeAttribute>() const
{
    return attribute_as_ReshapeAttribute();
}

template<>
inline const tosaFb::SliceAttribute *TosaOperator::attribute_as<tosaFb::SliceAttribute>() const
{
    return attribute_as_SliceAttribute();
}

template<>
inline const tosaFb::TileAttribute *TosaOperator::attribute_as<tosaFb::TileAttribute>() const
{
    return attribute_as_TileAttribute();
}

template<>
inline const tosaFb::ResizeAttribute *TosaOperator::attribute_as<tosaFb::ResizeAttribute>() const
{
    return attribute_as_ResizeAttribute();
}

template<>
inline const tosaFb::ClampAttribute *TosaOperator::attribute_as<tosaFb::ClampAttribute>() const
{
    return attribute_as_ClampAttribute();
}

template<>
inline const tosaFb::RescaleAttribute *TosaOperator::attribute_as<tosaFb::RescaleAttribute>() const
{
    return attribute_as_RescaleAttribute();
}

template<>
inline const tosaFb::MulAttribute *TosaOperator::attribute_as<tosaFb::MulAttribute>() const
{
    return attribute_as_MulAttribute();
}

template<>
inline const tosaFb::ArithmeticRightShiftAttribute *TosaOperator::attribute_as<tosaFb::ArithmeticRightShiftAttribute>() const
{
    return attribute_as_ArithmeticRightShiftAttribute();
}

template<>
inline const tosaFb::CondIfAttribute *TosaOperator::attribute_as<tosaFb::CondIfAttribute>() const
{
    return attribute_as_CondIfAttribute();
}

template<>
inline const tosaFb::WhileLoopAttribute *TosaOperator::attribute_as<tosaFb::WhileLoopAttribute>() const
{
    return attribute_as_WhileLoopAttribute();
}

template<>
inline const tosaFb::TransposeAttribute *TosaOperator::attribute_as<tosaFb::TransposeAttribute>() const
{
    return attribute_as_TransposeAttribute();
}

template<>
inline const tosaFb::TableAttribute *TosaOperator::attribute_as<tosaFb::TableAttribute>() const
{
    return attribute_as_TableAttribute();
}

template<>
inline const tosaFb::MatMulAttribute *TosaOperator::attribute_as<tosaFb::MatMulAttribute>() const
{
    return attribute_as_MatMulAttribute();
}

template<>
inline const tosaFb::FullyConnectedAttribute *TosaOperator::attribute_as<tosaFb::FullyConnectedAttribute>() const
{
    return attribute_as_FullyConnectedAttribute();
}

template<>
inline const tosaFb::NegateAttribute *TosaOperator::attribute_as<tosaFb::NegateAttribute>() const
{
    return attribute_as_NegateAttribute();
}

template<>
inline const tosaFb::CustomAttribute *TosaOperator::attribute_as<tosaFb::CustomAttribute>() const
{
    return attribute_as_CustomAttribute();
}

template<>
inline const tosaFb::FFTAttribute *TosaOperator::attribute_as<tosaFb::FFTAttribute>() const
{
    return attribute_as_FFTAttribute();
}

struct TosaOperatorBuilder
{
    typedef TosaOperator Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_op(tosaFb::Op op) { fbb_.AddElement<uint32_t>(TosaOperator::VT_OP, static_cast<uint32_t>(op), 0); }
    void add_attribute_type(tosaFb::Attribute attribute_type)
    {
        fbb_.AddElement<uint8_t>(TosaOperator::VT_ATTRIBUTE_TYPE, static_cast<uint8_t>(attribute_type), 0);
    }
    void add_attribute(::flatbuffers::Offset<void> attribute) { fbb_.AddOffset(TosaOperator::VT_ATTRIBUTE, attribute); }
    void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs)
    {
        fbb_.AddOffset(TosaOperator::VT_INPUTS, inputs);
    }
    void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs)
    {
        fbb_.AddOffset(TosaOperator::VT_OUTPUTS, outputs);
    }
    explicit TosaOperatorBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<TosaOperator> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TosaOperator>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TosaOperator> CreateTosaOperator(::flatbuffers::FlatBufferBuilder &_fbb, tosaFb::Op op = tosaFb::Op::UNKNOWN,
    tosaFb::Attribute attribute_type = tosaFb::Attribute::NONE, ::flatbuffers::Offset<void> attribute = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs = 0)
{
    TosaOperatorBuilder builder_(_fbb);
    builder_.add_outputs(outputs);
    builder_.add_inputs(inputs);
    builder_.add_attribute(attribute);
    builder_.add_op(op);
    builder_.add_attribute_type(attribute_type);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<TosaOperator> CreateTosaOperatorDirect(::flatbuffers::FlatBufferBuilder &_fbb,
    tosaFb::Op op = tosaFb::Op::UNKNOWN, tosaFb::Attribute attribute_type = tosaFb::Attribute::NONE,
    ::flatbuffers::Offset<void> attribute = 0, const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs = nullptr)
{
    auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*inputs) : 0;
    auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*outputs) : 0;
    return tosaFb::CreateTosaOperator(_fbb, op, attribute_type, attribute, inputs__, outputs__);
}

struct TosaBasicBlock FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TosaBasicBlockBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return TosaBasicBlockTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_NAME = 4,
        VT_OPERATORS = 6,
        VT_TENSORS = 8,
        VT_INPUTS = 10,
        VT_OUTPUTS = 12
    };
    const ::flatbuffers::String *name() const { return GetPointer<const ::flatbuffers::String *>(VT_NAME); }
    const ::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaOperator>> *operators() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaOperator>> *>(VT_OPERATORS);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaTensor>> *tensors() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaTensor>> *>(VT_TENSORS);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUTS);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUTS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) && VerifyOffset(verifier, VT_OPERATORS) &&
               verifier.VerifyVector(operators()) && verifier.VerifyVectorOfTables(operators()) && VerifyOffset(verifier, VT_TENSORS) &&
               verifier.VerifyVector(tensors()) && verifier.VerifyVectorOfTables(tensors()) && VerifyOffset(verifier, VT_INPUTS) &&
               verifier.VerifyVector(inputs()) && verifier.VerifyVectorOfStrings(inputs()) && VerifyOffset(verifier, VT_OUTPUTS) &&
               verifier.VerifyVector(outputs()) && verifier.VerifyVectorOfStrings(outputs()) && verifier.EndTable();
    }
};

struct TosaBasicBlockBuilder
{
    typedef TosaBasicBlock Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name) { fbb_.AddOffset(TosaBasicBlock::VT_NAME, name); }
    void add_operators(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaOperator>>> operators)
    {
        fbb_.AddOffset(TosaBasicBlock::VT_OPERATORS, operators);
    }
    void add_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaTensor>>> tensors)
    {
        fbb_.AddOffset(TosaBasicBlock::VT_TENSORS, tensors);
    }
    void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs)
    {
        fbb_.AddOffset(TosaBasicBlock::VT_INPUTS, inputs);
    }
    void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs)
    {
        fbb_.AddOffset(TosaBasicBlock::VT_OUTPUTS, outputs);
    }
    explicit TosaBasicBlockBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<TosaBasicBlock> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TosaBasicBlock>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TosaBasicBlock>
CreateTosaBasicBlock(::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaOperator>>> operators = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaTensor>>> tensors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs = 0)
{
    TosaBasicBlockBuilder builder_(_fbb);
    builder_.add_outputs(outputs);
    builder_.add_inputs(inputs);
    builder_.add_tensors(tensors);
    builder_.add_operators(operators);
    builder_.add_name(name);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<TosaBasicBlock> CreateTosaBasicBlockDirect(::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr, const std::vector<::flatbuffers::Offset<tosaFb::TosaOperator>> *operators = nullptr,
    const std::vector<::flatbuffers::Offset<tosaFb::TosaTensor>> *tensors = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs = nullptr)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto operators__ = operators ? _fbb.CreateVector<::flatbuffers::Offset<tosaFb::TosaOperator>>(*operators) : 0;
    auto tensors__ = tensors ? _fbb.CreateVector<::flatbuffers::Offset<tosaFb::TosaTensor>>(*tensors) : 0;
    auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*inputs) : 0;
    auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*outputs) : 0;
    return tosaFb::CreateTosaBasicBlock(_fbb, name__, operators__, tensors__, inputs__, outputs__);
}

struct TosaRegion FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TosaRegionBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return TosaRegionTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_NAME = 4,
        VT_BLOCKS = 6
    };
    const ::flatbuffers::String *name() const { return GetPointer<const ::flatbuffers::String *>(VT_NAME); }
    const ::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaBasicBlock>> *blocks() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaBasicBlock>> *>(VT_BLOCKS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) && VerifyOffset(verifier, VT_BLOCKS) &&
               verifier.VerifyVector(blocks()) && verifier.VerifyVectorOfTables(blocks()) && verifier.EndTable();
    }
};

struct TosaRegionBuilder
{
    typedef TosaRegion Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name) { fbb_.AddOffset(TosaRegion::VT_NAME, name); }
    void add_blocks(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaBasicBlock>>> blocks)
    {
        fbb_.AddOffset(TosaRegion::VT_BLOCKS, blocks);
    }
    explicit TosaRegionBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<TosaRegion> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TosaRegion>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TosaRegion>
CreateTosaRegion(::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaBasicBlock>>> blocks = 0)
{
    TosaRegionBuilder builder_(_fbb);
    builder_.add_blocks(blocks);
    builder_.add_name(name);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<TosaRegion> CreateTosaRegionDirect(::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr, const std::vector<::flatbuffers::Offset<tosaFb::TosaBasicBlock>> *blocks = nullptr)
{
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto blocks__ = blocks ? _fbb.CreateVector<::flatbuffers::Offset<tosaFb::TosaBasicBlock>>(*blocks) : 0;
    return tosaFb::CreateTosaRegion(_fbb, name__, blocks__);
}

struct TosaGraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TosaGraphBuilder Builder;
    static const ::flatbuffers::TypeTable *MiniReflectTypeTable() { return TosaGraphTypeTable(); }
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_VERSION = 4,
        VT_REGIONS = 6
    };
    const tosaFb::Version *version() const { return GetPointer<const tosaFb::Version *>(VT_VERSION); }
    const ::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaRegion>> *regions() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaRegion>> *>(VT_REGIONS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_VERSION) &&
               verifier.VerifyTable(version()) && VerifyOffset(verifier, VT_REGIONS) &&
               verifier.VerifyVector(regions()) && verifier.VerifyVectorOfTables(regions()) && verifier.EndTable();
    }
};

struct TosaGraphBuilder
{
    typedef TosaGraph Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_version(::flatbuffers::Offset<tosaFb::Version> version) { fbb_.AddOffset(TosaGraph::VT_VERSION, version); }
    void add_regions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaRegion>>> regions)
    {
        fbb_.AddOffset(TosaGraph::VT_REGIONS, regions);
    }
    explicit TosaGraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
    ::flatbuffers::Offset<TosaGraph> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TosaGraph>(end);
        fbb_.Required(o, TosaGraph::VT_VERSION);
        return o;
    }
};

inline ::flatbuffers::Offset<TosaGraph>
CreateTosaGraph(::flatbuffers::FlatBufferBuilder &_fbb, ::flatbuffers::Offset<tosaFb::Version> version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tosaFb::TosaRegion>>> regions = 0)
{
    TosaGraphBuilder builder_(_fbb);
    builder_.add_regions(regions);
    builder_.add_version(version);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<TosaGraph> CreateTosaGraphDirect(::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<tosaFb::Version> version = 0, const std::vector<::flatbuffers::Offset<tosaFb::TosaRegion>> *regions = nullptr)
{
    auto regions__ = regions ? _fbb.CreateVector<::flatbuffers::Offset<tosaFb::TosaRegion>>(*regions) : 0;
    return tosaFb::CreateTosaGraph(_fbb, version, regions__);
}

inline bool VerifyAttribute(::flatbuffers::Verifier &verifier, const void *obj, Attribute type)
{
    switch ( type )
    {
        case Attribute::NONE:
        {
            return true;
        }
        case Attribute::PoolAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::PoolAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::ConvAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::ConvAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::TransposeConvAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::TransposeConvAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::PadAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::PadAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::AxisAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::AxisAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::ReshapeAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::ReshapeAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::SliceAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::SliceAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::TileAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::TileAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::ResizeAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::ResizeAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::ClampAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::ClampAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::RescaleAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::RescaleAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::MulAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::MulAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::ArithmeticRightShiftAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::ArithmeticRightShiftAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::CondIfAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::CondIfAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::WhileLoopAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::WhileLoopAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::TransposeAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::TransposeAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::TableAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::TableAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::MatMulAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::MatMulAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::FullyConnectedAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::FullyConnectedAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::NegateAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::NegateAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::CustomAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::CustomAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        case Attribute::FFTAttribute:
        {
            auto ptr = reinterpret_cast<const tosaFb::FFTAttribute *>(obj);
            return verifier.VerifyTable(ptr);
        }
        default:
            return true;
    }
}

inline bool VerifyAttributeVector(::flatbuffers::Verifier &verifier,
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Attribute> *types)
{
    if ( !values || !types ) return !values && !types;
    if ( values->size() != types->size() ) return false;
    for ( ::flatbuffers::uoffset_t i = 0; i < values->size(); ++i )
    {
        if ( !VerifyAttribute(verifier, values->Get(i), types->GetEnum<Attribute>(i)) )
        {
            return false;
        }
    }
    return true;
}

inline const ::flatbuffers::TypeTable *DTypeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}};
    static const ::flatbuffers::TypeFunction type_refs[] = {tosaFb::DTypeTypeTable};
    static const char *const names[] = {"UNKNOWN", "BOOL", "UINT8", "INT4", "INT8", "INT16", "INT32", "INT48", "FP32",
        "UINT16", "FP16", "BF16", "SHAPE"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_ENUM, 13, type_codes, type_refs, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *ResizeModeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}};
    static const ::flatbuffers::TypeFunction type_refs[] = {tosaFb::ResizeModeTypeTable};
    static const char *const names[] = {"UNKNOWN", "NEAREST", "BILINEAR"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *OpTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0},
        {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UINT, 0, 0}};
    static const ::flatbuffers::TypeFunction type_refs[] = {tosaFb::OpTypeTable};
    static const char *const names[] = {"UNKNOWN", "ARGMAX", "AVG_POOL2D", "CONV2D", "CONV3D", "DEPTHWISE_CONV2D",
        "FULLY_CONNECTED", "MATMUL", "MAX_POOL2D", "TRANSPOSE_CONV2D", "CLAMP", "RESERVED", "SIGMOID", "TANH", "ADD",
        "ARITHMETIC_RIGHT_SHIFT", "BITWISE_AND", "BITWISE_OR", "BITWISE_XOR", "INTDIV", "LOGICAL_AND", "LOGICAL_LEFT_SHIFT",
        "LOGICAL_RIGHT_SHIFT", "LOGICAL_OR", "LOGICAL_XOR", "MAXIMUM", "MINIMUM", "MUL", "POW", "SUB", "TABLE", "ABS",
        "BITWISE_NOT", "CEIL", "CLZ", "EXP", "FLOOR", "LOG", "LOGICAL_NOT", "NEGATE", "RECIPROCAL", "RSQRT", "SELECT",
        "EQUAL", "GREATER", "GREATER_EQUAL", "REDUCE_ANY", "REDUCE_ALL", "REDUCE_MAX", "REDUCE_MIN", "REDUCE_PRODUCT",
        "REDUCE_SUM", "CONCAT", "PAD", "RESHAPE", "REVERSE", "SLICE", "TILE", "TRANSPOSE", "GATHER", "SCATTER", "RESIZE",
        "CAST", "RESCALE", "CONST", "IDENTITY", "CUSTOM", "COND_IF", "WHILE_LOOP", "FFT2D", "RFFT2D", "ERF", "DIM"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_ENUM, 73, type_codes, type_refs, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *AttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_SEQUENCE, 0, -1}, {::flatbuffers::ET_SEQUENCE, 0, 0},
        {::flatbuffers::ET_SEQUENCE, 0, 1}, {::flatbuffers::ET_SEQUENCE, 0, 2}, {::flatbuffers::ET_SEQUENCE, 0, 3},
        {::flatbuffers::ET_SEQUENCE, 0, 4}, {::flatbuffers::ET_SEQUENCE, 0, 5}, {::flatbuffers::ET_SEQUENCE, 0, 6},
        {::flatbuffers::ET_SEQUENCE, 0, 7}, {::flatbuffers::ET_SEQUENCE, 0, 8}, {::flatbuffers::ET_SEQUENCE, 0, 9},
        {::flatbuffers::ET_SEQUENCE, 0, 10}, {::flatbuffers::ET_SEQUENCE, 0, 11}, {::flatbuffers::ET_SEQUENCE, 0, 12},
        {::flatbuffers::ET_SEQUENCE, 0, 13}, {::flatbuffers::ET_SEQUENCE, 0, 14}, {::flatbuffers::ET_SEQUENCE, 0, 15},
        {::flatbuffers::ET_SEQUENCE, 0, 16}, {::flatbuffers::ET_SEQUENCE, 0, 17}, {::flatbuffers::ET_SEQUENCE, 0, 18},
        {::flatbuffers::ET_SEQUENCE, 0, 19}, {::flatbuffers::ET_SEQUENCE, 0, 20}, {::flatbuffers::ET_SEQUENCE, 0, 21}};
    static const ::flatbuffers::TypeFunction type_refs[] = {tosaFb::PoolAttributeTypeTable, tosaFb::ConvAttributeTypeTable,
        tosaFb::TransposeConvAttributeTypeTable, tosaFb::PadAttributeTypeTable, tosaFb::AxisAttributeTypeTable, tosaFb::ReshapeAttributeTypeTable,
        tosaFb::SliceAttributeTypeTable, tosaFb::TileAttributeTypeTable, tosaFb::ResizeAttributeTypeTable, tosaFb::ClampAttributeTypeTable,
        tosaFb::RescaleAttributeTypeTable, tosaFb::MulAttributeTypeTable, tosaFb::ArithmeticRightShiftAttributeTypeTable,
        tosaFb::CondIfAttributeTypeTable, tosaFb::WhileLoopAttributeTypeTable, tosaFb::TransposeAttributeTypeTable,
        tosaFb::TableAttributeTypeTable, tosaFb::MatMulAttributeTypeTable, tosaFb::FullyConnectedAttributeTypeTable,
        tosaFb::NegateAttributeTypeTable, tosaFb::CustomAttributeTypeTable, tosaFb::FFTAttributeTypeTable};
    static const char *const names[] = {"NONE", "PoolAttribute", "ConvAttribute", "TransposeConvAttribute", "PadAttribute",
        "AxisAttribute", "ReshapeAttribute", "SliceAttribute", "TileAttribute", "ResizeAttribute", "ClampAttribute", "RescaleAttribute",
        "MulAttribute", "ArithmeticRightShiftAttribute", "CondIfAttribute", "WhileLoopAttribute", "TransposeAttribute",
        "TableAttribute", "MatMulAttribute", "FullyConnectedAttribute", "NegateAttribute", "CustomAttribute", "FFTAttribute"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_UNION, 23, type_codes, type_refs, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *PoolAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 1, -1}, {::flatbuffers::ET_INT, 1, -1},
        {::flatbuffers::ET_INT, 1, -1}, {::flatbuffers::ET_INT, 0, -1}, {::flatbuffers::ET_INT, 0, -1}, {::flatbuffers::ET_UINT, 0, 0}};
    static const ::flatbuffers::TypeFunction type_refs[] = {tosaFb::DTypeTypeTable};
    static const char *const names[] = {"pad", "kernel", "stride", "input_zp", "output_zp", "accum_dtype"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *ConvAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 1, -1}, {::flatbuffers::ET_INT, 1, -1},
        {::flatbuffers::ET_INT, 1, -1}, {::flatbuffers::ET_INT, 0, -1}, {::flatbuffers::ET_INT, 0, -1}};
    static const char *const names[] = {"pad", "stride", "dilation", "input_zp", "weight_zp"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *TransposeConvAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 1, -1}, {::flatbuffers::ET_INT, 1, -1},
        {::flatbuffers::ET_INT, 1, -1}, {::flatbuffers::ET_INT, 0, -1}, {::flatbuffers::ET_INT, 0, -1}};
    static const char *const names[] = {"out_pad", "stride", "output_shape", "input_zp", "weight_zp"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *PadAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {
        {::flatbuffers::ET_INT, 1, -1}, {::flatbuffers::ET_INT, 0, -1}, {::flatbuffers::ET_UCHAR, 1, -1}};
    static const char *const names[] = {"padding", "pad_const_int", "pad_const_fp"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *AxisAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 0, -1}};
    static const char *const names[] = {"axis"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *ReshapeAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 1, -1}};
    static const char *const names[] = {"new_shape"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *SliceAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 1, -1}, {::flatbuffers::ET_INT, 1, -1}};
    static const char *const names[] = {"start", "size"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *TileAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 1, -1}};
    static const char *const names[] = {"multiples"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *ResizeAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_SHORT, 1, -1},
        {::flatbuffers::ET_SHORT, 1, -1}, {::flatbuffers::ET_SHORT, 1, -1}, {::flatbuffers::ET_UINT, 0, 0}};
    static const ::flatbuffers::TypeFunction type_refs[] = {tosaFb::ResizeModeTypeTable};
    static const char *const names[] = {"scale", "offset", "border", "mode"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *ClampAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 0, -1}, {::flatbuffers::ET_INT, 0, -1},
        {::flatbuffers::ET_UCHAR, 1, -1}, {::flatbuffers::ET_UCHAR, 1, -1}};
    static const char *const names[] = {"min_int", "max_int", "min_fp", "max_fp"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *RescaleAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 0, -1}, {::flatbuffers::ET_INT, 0, -1},
        {::flatbuffers::ET_INT, 1, -1}, {::flatbuffers::ET_INT, 1, -1}, {::flatbuffers::ET_BOOL, 0, -1}, {::flatbuffers::ET_BOOL, 0, -1},
        {::flatbuffers::ET_BOOL, 0, -1}, {::flatbuffers::ET_BOOL, 0, -1}, {::flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[] = {"input_zp", "output_zp", "multiplier", "shift", "scale32", "double_round",
        "per_channel", "input_unsigned", "output_unsigned"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 9, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *MulAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 0, -1}};
    static const char *const names[] = {"shift"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *ArithmeticRightShiftAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[] = {"round"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *CondIfAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_STRING, 0, -1}, {::flatbuffers::ET_STRING, 0, -1}};
    static const char *const names[] = {"then_branch", "else_branch"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *WhileLoopAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_STRING, 0, -1}, {::flatbuffers::ET_STRING, 0, -1}};
    static const char *const names[] = {"cond_branch", "body_branch"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *TransposeAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 1, -1}};
    static const char *const names[] = {"perms"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *TableAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_SHORT, 1, -1}};
    static const char *const names[] = {"table"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *MatMulAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 0, -1}, {::flatbuffers::ET_INT, 0, -1}};
    static const char *const names[] = {"a_zp", "b_zp"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *FullyConnectedAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 0, -1}, {::flatbuffers::ET_INT, 0, -1}};
    static const char *const names[] = {"input_zp", "weight_zp"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *NegateAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 0, -1}, {::flatbuffers::ET_INT, 0, -1}};
    static const char *const names[] = {"input1_zp", "output_zp"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *CustomAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {
        {::flatbuffers::ET_STRING, 0, -1}, {::flatbuffers::ET_STRING, 0, -1}, {::flatbuffers::ET_UCHAR, 1, -1}};
    static const char *const names[] = {"identifier", "config", "implementation_attrs"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *FFTAttributeTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[] = {"inverse"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *VersionTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_INT, 0, -1}, {::flatbuffers::ET_INT, 0, -1},
        {::flatbuffers::ET_INT, 0, -1}, {::flatbuffers::ET_BOOL, 0, -1}};
    static const char *const names[] = {"_major", "_minor", "_patch", "_draft"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *TosaTensorTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_STRING, 0, -1},
        {::flatbuffers::ET_INT, 1, -1}, {::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UCHAR, 1, -1},
        {::flatbuffers::ET_BOOL, 0, -1}, {::flatbuffers::ET_BOOL, 0, -1}};
    static const ::flatbuffers::TypeFunction type_refs[] = {tosaFb::DTypeTypeTable};
    static const char *const names[] = {"name", "shape", "type", "data", "variable", "is_unranked"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *TosaOperatorTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_UINT, 0, 0}, {::flatbuffers::ET_UTYPE, 0, 1},
        {::flatbuffers::ET_SEQUENCE, 0, 1}, {::flatbuffers::ET_STRING, 1, -1}, {::flatbuffers::ET_STRING, 1, -1}};
    static const ::flatbuffers::TypeFunction type_refs[] = {tosaFb::OpTypeTable, tosaFb::AttributeTypeTable};
    static const char *const names[] = {"op", "attribute_type", "attribute", "inputs", "outputs"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *TosaBasicBlockTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_STRING, 0, -1}, {::flatbuffers::ET_SEQUENCE, 1, 0},
        {::flatbuffers::ET_SEQUENCE, 1, 1}, {::flatbuffers::ET_STRING, 1, -1}, {::flatbuffers::ET_STRING, 1, -1}};
    static const ::flatbuffers::TypeFunction type_refs[] = {tosaFb::TosaOperatorTypeTable, tosaFb::TosaTensorTypeTable};
    static const char *const names[] = {"name", "operators", "tensors", "inputs", "outputs"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *TosaRegionTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_STRING, 0, -1}, {::flatbuffers::ET_SEQUENCE, 1, 0}};
    static const ::flatbuffers::TypeFunction type_refs[] = {tosaFb::TosaBasicBlockTypeTable};
    static const char *const names[] = {"name", "blocks"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
    return &tt;
}

inline const ::flatbuffers::TypeTable *TosaGraphTypeTable()
{
    static const ::flatbuffers::TypeCode type_codes[] = {{::flatbuffers::ET_SEQUENCE, 0, 0}, {::flatbuffers::ET_SEQUENCE, 1, 1}};
    static const ::flatbuffers::TypeFunction type_refs[] = {tosaFb::VersionTypeTable, tosaFb::TosaRegionTypeTable};
    static const char *const names[] = {"version", "regions"};
    static const ::flatbuffers::TypeTable tt = {::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names};
    return &tt;
}

inline const tosaFb::TosaGraph *GetTosaGraph(const void *buf)
{
    return ::flatbuffers::GetRoot<tosaFb::TosaGraph>(buf);
}

inline const tosaFb::TosaGraph *GetSizePrefixedTosaGraph(const void *buf)
{
    return ::flatbuffers::GetSizePrefixedRoot<tosaFb::TosaGraph>(buf);
}

inline const char *TosaGraphIdentifier()
{
    return "TOSA";
}

inline bool TosaGraphBufferHasIdentifier(const void *buf)
{
    return ::flatbuffers::BufferHasIdentifier(buf, TosaGraphIdentifier());
}

inline bool SizePrefixedTosaGraphBufferHasIdentifier(const void *buf)
{
    return ::flatbuffers::BufferHasIdentifier(buf, TosaGraphIdentifier(), true);
}

inline bool VerifyTosaGraphBuffer(::flatbuffers::Verifier &verifier)
{
    return verifier.VerifyBuffer<tosaFb::TosaGraph>(TosaGraphIdentifier());
}

inline bool VerifySizePrefixedTosaGraphBuffer(::flatbuffers::Verifier &verifier)
{
    return verifier.VerifySizePrefixedBuffer<tosaFb::TosaGraph>(TosaGraphIdentifier());
}

inline const char *TosaGraphExtension()
{
    return "tosa";
}

inline void FinishTosaGraphBuffer(::flatbuffers::FlatBufferBuilder &fbb, ::flatbuffers::Offset<tosaFb::TosaGraph> root)
{
    fbb.Finish(root, TosaGraphIdentifier());
}

inline void FinishSizePrefixedTosaGraphBuffer(::flatbuffers::FlatBufferBuilder &fbb, ::flatbuffers::Offset<tosaFb::TosaGraph> root)
{
    fbb.FinishSizePrefixed(root, TosaGraphIdentifier());
}

}  // namespace tosaFb

#endif  // FLATBUFFERS_GENERATED_SCHEMA_TOSAFB_H_
