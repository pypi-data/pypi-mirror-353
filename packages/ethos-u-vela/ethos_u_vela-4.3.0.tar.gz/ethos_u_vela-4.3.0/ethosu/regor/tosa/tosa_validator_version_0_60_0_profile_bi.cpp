//
// SPDX-FileCopyrightText: Copyright 2023-2024 Arm Limited and/or its affiliates <open-source-office@arm.com>
//
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the License); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an AS IS BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Generated by tosaValidationGenerator for TOSA Specification 0.60.0
// Do not edit.

#include "compiler/operation.hpp"
#include "tosa/tosa_argument_checks.hpp"
#include "tosa/tosa_error_checks.hpp"
#include "tosa/tosa_level_checks.hpp"
#include "tosa/tosa_require_checks.hpp"
#include "tosa/tosa_validator.hpp"
using namespace tosa::validator;

using namespace tosa::validator::checks;

#define MAX_RANK (context.level == Level::Level8K ? 6 : (context.level == Level::Levelnone ? 32 : 0))

#define MAX_KERNEL (context.level == Level::Level8K ? 8192 : (context.level == Level::Levelnone ? 2147483647 : 0))

#define MAX_SCALE (context.level == Level::Level8K ? 256 : (context.level == Level::Levelnone ? 2048 : 0))

#define MAX_STRIDE (context.level == Level::Level8K ? 8192 : (context.level == Level::Levelnone ? 2147483647 : 0))

namespace
{
void ValidateOperator_ARGMAX(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_t",
    }; /*Input tensor with rank from 1 to 4 shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "int32_t",
    }; /*Axis in range from 0 to rank(shape1)-1 shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "out_t",
    }; /*Output tensor, with rank = rank(shape1)-1 shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "int8_t"},
            {"out_t", "int32_t"},
        },  // signed 8
        {
            {"in_t", "int16_t"},
            {"out_t", "int32_t"},
        },  // signed 16
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_ai0sdq9wgm72(op, context);
    ErrorIfCheck_gpp861oen43y(op, context);
    LevelCheck_1lz89reckvj8d(op, context);
}

void ValidateOperator_AVG_POOL2D(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_out_t", {4, 4}};      /*Input tensor 4D shape=[N,IH,IW,C]*/
    const Argument kernel = {Category::Attribute, "kernel", "int32_t", {1, 1}}; /*[kernel_y, kernel_x] shape=[2]*/
    const Argument stride = {Category::Attribute, "stride", "int32_t", {1, 1}}; /*[stride_y, stride_x] shape=[2]*/
    const Argument pad = {Category::Attribute, "pad", "int32_t", {1, 1}}; /*[pad_top, pad_bottom, pad_left, pad_right]
                                                                             shape=[4]*/
    const Argument acc_size = {
        Category::Attribute,
        "acc_size",
        "acc_t",
    }; /*Enumerated type, must be one of INT32, FP16, FP32, as defined in the Supported Data Types table for this
        operation shape=-*/
    const Argument input_zp = {
        Category::Attribute,
        "input_zp",
        "in_out_t",
    }; /*Input tensor zero point. Must be zero for non-int8 types. shape=-*/
    const Argument output_zp = {
        Category::Attribute,
        "output_zp",
        "in_out_t",
    }; /*Output tensor zero point. Must be zero for non-int8 types. shape=-*/
    const Argument output = {Category::Output, "output", "in_out_t", {4, 4}}; /*Output tensor 4D shape=[N,OH,OW,C]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &kernel,
        &stride,
        &pad,
        &acc_size,
        &input_zp,
        &output_zp,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int8_t"},
            {"acc_t", "int32_t"},
        },  // signed 8 with int32 accumulate
        {
            {"in_out_t", "int16_t"},
            {"acc_t", "int32_t"},
        },  // signed 16 with int32 accumulate
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1vu5c1tytwmhu(op, context);
    ErrorIfCheck_1n0denkrrrlr1(op, context);
    ErrorIfCheck_36r4wpx3psd81(op, context);
    ErrorIfCheck_1lrylbkd3w7ix(op, context);
    ErrorIfCheck_ojmgqziimenu(op, context);
    ErrorIfCheck_3vqy81ueu5wjk(op, context);
    ErrorIfCheck_125xuezh1964i(op, context);
    ErrorIfCheck_fqta626ku4qe(op, context);
    ErrorIfCheck_ycjhrvf2yigr(op, context);
    ErrorIfCheck_1c57olj698f3d(op, context);
    LevelCheck_2i1ithnrq06wi(op, context);
    LevelCheck_1wobi8axf7z2y(op, context);
    LevelCheck_1xppm0ufw64nq(op, context);
    LevelCheck_as2lzdd5d28b(op, context);
    LevelCheck_2n3xkkz3ip4mz(op, context);
    LevelCheck_3o7qpmmd9ga58(op, context);
    LevelCheck_16lxbjk2bszcz(op, context);
    LevelCheck_2kwfb08mbiwpg(op, context);
}

void ValidateOperator_CONV2D(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {4, 4}};       /*Input tensor shape=[N,IH,IW,IC]*/
    const Argument weight = {Category::Input, "weight", "weight_t", {4, 4}}; /*Weight kernel size KH x KW
                                                                                shape=[OC,KH,KW,IC]*/
    const Argument bias = {Category::Input, "bias", "out_t", {1, 1}};     /*Per output channel bias data. shape=[OC]*/
    const Argument pad = {Category::Attribute, "pad", "int32_t", {1, 1}}; /*[pad_top, pad_bottom, pad_left, pad_right]
                                                                             shape=[4]*/
    const Argument stride = {Category::Attribute, "stride", "int32_t", {1, 1}};     /*[stride_y, stride_x] shape=[2]*/
    const Argument dilation = {Category::Attribute, "dilation", "int32_t", {1, 1}}; /*[dilation_y, dilation_x]
                                                                                       shape=[2]*/
    const Argument input_zp = {
        Category::Attribute,
        "input_zp",
        "in_t",
    }; /*Input tensor zero point. Must be zero for non-int8 types. shape=-*/
    const Argument weight_zp = {
        Category::Attribute,
        "weight_zp",
        "weight_t",
    }; /*Weight zero point. Must be zero for non-int8 types. shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {4, 4}}; /*Output tensor shape=[N,OH,OW,OC]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &weight,
        &bias,
        &pad,
        &stride,
        &dilation,
        &input_zp,
        &weight_zp,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "int8_t"},
            {"weight_t", "int8_t"},
            {"out_t", "int32_t"},
        },  // signed 8x8 with int32 accumulate
        {
            {"in_t", "int8_t"},
            {"weight_t", "int4_t"},
            {"out_t", "int32_t"},
        },  // signed 8x4 with int32 accumulate
        {
            {"in_t", "int16_t"},
            {"weight_t", "int8_t"},
            {"out_t", "int48_t"},
        },  // signed 16x8 with int48 accumulate
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hby1qurzja4f(op, context);
    ErrorIfCheck_1md8k265hfj92(op, context);
    ErrorIfCheck_ojmgqziimenu(op, context);
    ErrorIfCheck_1lrylbkd3w7ix(op, context);
    ErrorIfCheck_3fzsq78v5ypau(op, context);
    ErrorIfCheck_2vhj6e48eyzlr(op, context);
    ErrorIfCheck_147wc580l2tik(op, context);
    ErrorIfCheck_2rm8rnsdfn14h(op, context);
    ErrorIfCheck_36emtx7zwkk96(op, context);
    ErrorIfCheck_2r9jencgka20o(op, context);
    ErrorIfCheck_207p0r46d35m0(op, context);
    ErrorIfCheck_cr43yjpqkcpd(op, context);
    LevelCheck_1l00wczs5w70i(op, context);
    LevelCheck_1hle41fus7cpl(op, context);
    LevelCheck_2n3xkkz3ip4mz(op, context);
    LevelCheck_3o7qpmmd9ga58(op, context);
    LevelCheck_16lxbjk2bszcz(op, context);
    LevelCheck_2kwfb08mbiwpg(op, context);
    LevelCheck_1xppm0ufw64nq(op, context);
    LevelCheck_as2lzdd5d28b(op, context);
}

void ValidateOperator_CONV3D(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {5, 5}};       /*Input tensor shape=[N,ID,IH,IW,IC]*/
    const Argument weight = {Category::Input, "weight", "weight_t", {5, 5}}; /*Weight kernel size KDxKHxKW
                                                                                shape=[OC,KD,KH,KW,IC]*/
    const Argument bias = {Category::Input, "bias", "out_t", {1, 1}};     /*Per output channel bias data. shape=[OC]*/
    const Argument pad = {Category::Attribute, "pad", "int32_t", {1, 1}}; /*[pad_d0, pad_d1, pad_top, pad_bottom,
                                                                             pad_left, pad_right] shape=[6]*/
    const Argument stride = {Category::Attribute, "stride", "int32_t", {1, 1}};     /*[stride_d, stride_y, stride_x]
                                                                                       shape=[3]*/
    const Argument dilation = {Category::Attribute, "dilation", "int32_t", {1, 1}}; /*[dilation_d, dilation_y,
                                                                                       dilation_x] shape=[3]*/
    const Argument input_zp = {
        Category::Attribute,
        "input_zp",
        "in_t",
    }; /*Input tensor zero point. Must be zero for non-int8 types. shape=-*/
    const Argument weight_zp = {
        Category::Attribute,
        "weight_zp",
        "weight_t",
    }; /*Weight zero point. Must be zero for non-int8 types. shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {5, 5}}; /*Output tensor shape=[N,OD,OH,OW,OC]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &weight,
        &bias,
        &pad,
        &stride,
        &dilation,
        &input_zp,
        &weight_zp,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "int8_t"},
            {"weight_t", "int8_t"},
            {"out_t", "int32_t"},
        },  // signed 8x8 with int32 accumulate
        {
            {"in_t", "int8_t"},
            {"weight_t", "int4_t"},
            {"out_t", "int32_t"},
        },  // signed 8x4 with int32 accumulate
        {
            {"in_t", "int16_t"},
            {"weight_t", "int8_t"},
            {"out_t", "int48_t"},
        },  // signed 16x8 with int48 accumulate
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hby1qurzja4f(op, context);
    ErrorIfCheck_1md8k265hfj92(op, context);
    ErrorIfCheck_341t6ysqc16b2(op, context);
    ErrorIfCheck_uqm570jwaqb6(op, context);
    ErrorIfCheck_34iiwt6o66qfa(op, context);
    ErrorIfCheck_llbd3iugmek0(op, context);
    ErrorIfCheck_2vhj6e48eyzlr(op, context);
    ErrorIfCheck_147wc580l2tik(op, context);
    ErrorIfCheck_1w510kxt5b2b2(op, context);
    ErrorIfCheck_27g3t38z1of4h(op, context);
    ErrorIfCheck_95jvn4dzraol(op, context);
    ErrorIfCheck_21377cjnb1ox7(op, context);
    ErrorIfCheck_2cpco8ykx99sa(op, context);
    LevelCheck_1npkwxnbypn8z(op, context);
    LevelCheck_1l00wczs5w70i(op, context);
    LevelCheck_1hle41fus7cpl(op, context);
    LevelCheck_olu6vs8y9f61(op, context);
    LevelCheck_3l4no1w1u6sq4(op, context);
    LevelCheck_2n3xkkz3ip4mz(op, context);
    LevelCheck_3o7qpmmd9ga58(op, context);
    LevelCheck_16lxbjk2bszcz(op, context);
    LevelCheck_2kwfb08mbiwpg(op, context);
    LevelCheck_1xppm0ufw64nq(op, context);
    LevelCheck_as2lzdd5d28b(op, context);
    LevelCheck_1416gon2u3sue(op, context);
}

void ValidateOperator_DEPTHWISE_CONV2D(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {4, 4}};       /*Input tensor shape=[N,H,W,C]*/
    const Argument weight = {Category::Input, "weight", "weight_t", {4, 4}}; /*Weight kernel size KH x KW
                                                                                shape=[KH,KW,C,M]*/
    const Argument bias = {Category::Input, "bias", "out_t", {1, 1}};     /*Per output channel bias data. shape=[C*M]*/
    const Argument pad = {Category::Attribute, "pad", "int32_t", {1, 1}}; /*[pad_top, pad_bottom, pad_left, pad_right]
                                                                             shape=[4]*/
    const Argument stride = {Category::Attribute, "stride", "int32_t", {1, 1}};     /*[stride_y, stride_x] shape=[2]*/
    const Argument dilation = {Category::Attribute, "dilation", "int32_t", {1, 1}}; /*[dilation_y, dilation_x]
                                                                                       shape=[2]*/
    const Argument input_zp = {
        Category::Attribute,
        "input_zp",
        "in_t",
    }; /*Input tensor zero point. Must be zero for non-int8 types. shape=-*/
    const Argument weight_zp = {
        Category::Attribute,
        "weight_zp",
        "weight_t",
    }; /*Weight zero point. Must be zero for non-int8 types. shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {4, 4}}; /*Output tensor shape=[N,OH,OW,C*M]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &weight,
        &bias,
        &pad,
        &stride,
        &dilation,
        &input_zp,
        &weight_zp,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "int8_t"},
            {"weight_t", "int8_t"},
            {"out_t", "int32_t"},
        },  // signed 8x8 with int32 accumulate
        {
            {"in_t", "int8_t"},
            {"weight_t", "int4_t"},
            {"out_t", "int32_t"},
        },  // signed 8x4 with int32 accumulate
        {
            {"in_t", "int16_t"},
            {"weight_t", "int8_t"},
            {"out_t", "int48_t"},
        },  // signed 16x8 with int48 accumulate
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hby1qurzja4f(op, context);
    ErrorIfCheck_1md8k265hfj92(op, context);
    ErrorIfCheck_ojmgqziimenu(op, context);
    ErrorIfCheck_1lrylbkd3w7ix(op, context);
    ErrorIfCheck_3fzsq78v5ypau(op, context);
    ErrorIfCheck_2vhj6e48eyzlr(op, context);
    ErrorIfCheck_147wc580l2tik(op, context);
    ErrorIfCheck_10sexbqileii7(op, context);
    ErrorIfCheck_12rt0p658ac1(op, context);
    ErrorIfCheck_3cem64qtn6ajr(op, context);
    LevelCheck_1l00wczs5w70i(op, context);
    LevelCheck_1hle41fus7cpl(op, context);
    LevelCheck_2n3xkkz3ip4mz(op, context);
    LevelCheck_3o7qpmmd9ga58(op, context);
    LevelCheck_16lxbjk2bszcz(op, context);
    LevelCheck_2kwfb08mbiwpg(op, context);
    LevelCheck_1xppm0ufw64nq(op, context);
    LevelCheck_as2lzdd5d28b(op, context);
}

void ValidateOperator_FULLY_CONNECTED(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {2, 2}};           /*Input tensor shape=[N,IC]*/
    const Argument weight = {Category::Attribute, "weight", "weight_t", {2, 2}}; /*Weights shape=[OC,IC]*/
    const Argument bias = {Category::Attribute, "bias", "out_t", {1, 1}}; /*Per output channel bias data. shape=[OC]*/
    const Argument input_zp = {
        Category::Attribute,
        "input_zp",
        "in_t",
    }; /*Input tensor zero point. Must be zero for non-int8 types. shape=-*/
    const Argument weight_zp = {
        Category::Attribute,
        "weight_zp",
        "weight_t",
    }; /*Weight zero point. Must be zero for non-int8 types. shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {2, 2}}; /*Output tensor shape=[N,OC]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &weight,
        &bias,
        &input_zp,
        &weight_zp,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "int8_t"},
            {"weight_t", "int8_t"},
            {"out_t", "int32_t"},
        },  // signed 8x8 with int32 accumulate
        {
            {"in_t", "int8_t"},
            {"weight_t", "int4_t"},
            {"out_t", "int32_t"},
        },  // signed 8x4 with int32 accumulate
        {
            {"in_t", "int16_t"},
            {"weight_t", "int8_t"},
            {"out_t", "int48_t"},
        },  // signed 16x8 with int48 accumulate
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hby1qurzja4f(op, context);
    ErrorIfCheck_1md8k265hfj92(op, context);
    ErrorIfCheck_3ufiqep5ipuco(op, context);
    ErrorIfCheck_3kcipzq18dxv9(op, context);
    ErrorIfCheck_jcjmr2nnatvv(op, context);
    ErrorIfCheck_qwmo2w7hxola(op, context);
    ErrorIfCheck_c9o11f07skde(op, context);
}

void ValidateOperator_MATMUL(const regor::Operation *op, const Context &context)
{
    const Argument A = {Category::Input, "A", "in_t", {3, 3}}; /*Input tensor A, N matrices of size HxC shape=[N,H,C]*/
    const Argument B = {Category::Input, "B", "in_t", {3, 3}}; /*Input tensor B, N matrices of size CxW shape=[N,C,W]*/
    const Argument A_zp = {
        Category::Attribute,
        "A_zp",
        "in_t",
    }; /*Input tensor A zero point. Must be zero for non-int8 types. shape=-*/
    const Argument B_zp = {
        Category::Attribute,
        "B_zp",
        "in_t",
    }; /*Input tensor B zero point. Must be zero for non-int8 types. shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {3, 3}}; /*Output tensor, N matrices of size HxW
                                                                              shape=[N,H,W]*/
    const std::vector<const Argument *> arguments = {
        &A,
        &B,
        &A_zp,
        &B_zp,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "int8_t"},
            {"out_t", "int32_t"},
        },  // signed 8x8 with int32 accumulate
        {
            {"in_t", "int16_t"},
            {"out_t", "int48_t"},
        },  // signed 16x16 with int48 accumulate
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1ellfcuw76b13(op, context);
    ErrorIfCheck_h1uadv5irsu6(op, context);
    ErrorIfCheck_1kfh97qingywb(op, context);
    ErrorIfCheck_1azcq4511qzyx(op, context);
}

void ValidateOperator_MAX_POOL2D(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_out_t", {4, 4}};      /*Input tensor 4D shape=[N,IH,IW,C]*/
    const Argument kernel = {Category::Attribute, "kernel", "int32_t", {1, 1}}; /*[kernel_y, kernel_x] shape=[2]*/
    const Argument stride = {Category::Attribute, "stride", "int32_t", {1, 1}}; /*[stride_y, stride_x] shape=[2]*/
    const Argument pad = {Category::Attribute, "pad", "int32_t", {1, 1}}; /*[pad_top, pad_bottom, pad_left, pad_right]
                                                                             shape=[4]*/
    const Argument output = {Category::Output, "output", "in_out_t", {4, 4}}; /*Output tensor 4D shape=[N,OH,OW,C]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &kernel,
        &stride,
        &pad,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // 16-bit
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_36r4wpx3psd81(op, context);
    ErrorIfCheck_1lrylbkd3w7ix(op, context);
    ErrorIfCheck_ojmgqziimenu(op, context);
    ErrorIfCheck_3vqy81ueu5wjk(op, context);
    ErrorIfCheck_125xuezh1964i(op, context);
    ErrorIfCheck_fqta626ku4qe(op, context);
    ErrorIfCheck_ycjhrvf2yigr(op, context);
    ErrorIfCheck_1c57olj698f3d(op, context);
    LevelCheck_2i1ithnrq06wi(op, context);
    LevelCheck_1wobi8axf7z2y(op, context);
    LevelCheck_1xppm0ufw64nq(op, context);
    LevelCheck_as2lzdd5d28b(op, context);
    LevelCheck_2n3xkkz3ip4mz(op, context);
    LevelCheck_3o7qpmmd9ga58(op, context);
    LevelCheck_16lxbjk2bszcz(op, context);
    LevelCheck_2kwfb08mbiwpg(op, context);
}

void ValidateOperator_TRANSPOSE_CONV2D(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {4, 4}};       /*Input tensor shape=[N,IH,IW,IC]*/
    const Argument weight = {Category::Input, "weight", "weight_t", {4, 4}}; /*Weight kernel size KH x KW
                                                                                shape=[OC,KH,KW,IC]*/
    const Argument bias = {Category::Input, "bias", "out_t", {1, 1}}; /*Per output channel bias data. shape=[OC]*/
    const Argument out_pad = {Category::Attribute, "out_pad", "int32_t", {1, 1}};     /*[out_pad_top, out_pad_bottom,
                                                                                         out_pad_left, out_pad_right]
                                                                                         shape=[4]*/
    const Argument stride = {Category::Attribute, "stride", "int32_t", {1, 1}};       /*[stride_y, stride_x] shape=[2]*/
    const Argument out_shape = {Category::Attribute, "out_shape", "int32_t", {1, 1}}; /*[N,OH,OW,OC] shape=[4]*/
    const Argument input_zp = {
        Category::Attribute,
        "input_zp",
        "in_t",
    }; /*Input tensor zero point. Must be zero for non-int8 types. shape=-*/
    const Argument weight_zp = {
        Category::Attribute,
        "weight_zp",
        "weight_t",
    }; /*Weight zero point. Must be zero for non-int8 types. shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {4, 4}}; /*Output tensor shape=[N,OH,OW,OC]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &weight,
        &bias,
        &out_pad,
        &stride,
        &out_shape,
        &input_zp,
        &weight_zp,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "int8_t"},
            {"weight_t", "int8_t"},
            {"out_t", "int32_t"},
        },  // signed 8x8 with int32 accumulate
        {
            {"in_t", "int8_t"},
            {"weight_t", "int4_t"},
            {"out_t", "int32_t"},
        },  // signed 8x4 with int32 accumulate
        {
            {"in_t", "int16_t"},
            {"weight_t", "int8_t"},
            {"out_t", "int48_t"},
        },  // signed 16x8 with int48 accumulate
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1hby1qurzja4f(op, context);
    ErrorIfCheck_1md8k265hfj92(op, context);
    ErrorIfCheck_q9dl3x81rc4o(op, context);
    ErrorIfCheck_2rfkujt9lg7eq(op, context);
    ErrorIfCheck_1lrylbkd3w7ix(op, context);
    ErrorIfCheck_3nelbnmxyemot(op, context);
    ErrorIfCheck_24conlof4w8eh(op, context);
    ErrorIfCheck_2rm8rnsdfn14h(op, context);
    ErrorIfCheck_36emtx7zwkk96(op, context);
    ErrorIfCheck_2r9jencgka20o(op, context);
    ErrorIfCheck_207p0r46d35m0(op, context);
    ErrorIfCheck_cr43yjpqkcpd(op, context);
    LevelCheck_17eyg1nicy12g(op, context);
    LevelCheck_6qao6e1mxke0(op, context);
    LevelCheck_pnaf5n03f8jg(op, context);
    LevelCheck_me421i5r5j13(op, context);
    LevelCheck_2ffhdgbz1kvxc(op, context);
    LevelCheck_a0x2apl3zoz(op, context);
    LevelCheck_1xppm0ufw64nq(op, context);
    LevelCheck_as2lzdd5d28b(op, context);
}

void ValidateOperator_CLAMP(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument min_val = {
        Category::Attribute,
        "min_val",
        "in_out_t",
    }; /*Minimum clip value shape=-*/
    const Argument max_val = {
        Category::Attribute,
        "max_val",
        "in_out_t",
    }; /*Maximum clip value shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type and shape as input shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &min_val,
        &max_val,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_xod9coigx1x2(op, context);
    ErrorIfCheck_10u6py7exa66n(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_SIGMOID(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type and shape as input shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_10u6py7exa66n(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_TANH(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type and shape as input shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_10u6py7exa66n(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_ADD(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_ARITHMETIC_RIGHT_SHIFT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument round = {
        Category::Attribute,
        "round",
        "bool_t",
    }; /*If true then the shift is rounded shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &round,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    RequireCheck_25jhgrylo2an5(op, context);
}

void ValidateOperator_BITWISE_AND(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_BITWISE_OR(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_BITWISE_XOR(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_INTDIV(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    RequireCheck_35z4hcgn21c8p(op, context);
    RequireCheck_2v5c1x79g8j7o(op, context);
}

void ValidateOperator_LOGICAL_AND(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // boolean
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_LOGICAL_LEFT_SHIFT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    RequireCheck_3k2pr9vozq62t(op, context);
}

void ValidateOperator_LOGICAL_RIGHT_SHIFT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    RequireCheck_3k2pr9vozq62t(op, context);
}

void ValidateOperator_LOGICAL_OR(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // boolean
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_LOGICAL_XOR(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // boolean
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_MAXIMUM(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_MINIMUM(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_MUL(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument shift = {
        Category::Attribute,
        "shift",
        "uint6_t",
    }; /*Result right shift (int32_t data type only) shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &shift,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "int8_t"},
            {"out_t", "int32_t"},
        },  // signed 8
        {
            {"in_t", "int16_t"},
            {"out_t", "int32_t"},
        },  // signed 16
        {
            {"in_t", "int32_t"},
            {"out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_2gdayq6ofi7wx(op, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    RequireCheck_27adsuj7sthvo(op, context);
}

void ValidateOperator_POW(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_SUB(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_TABLE(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_t",
    };                                                                        /*Input tensor shape=shape*/
    const Argument table = {Category::Attribute, "table", "table_t", {1, 1}}; /*Lookup table tensor shape=[TABLE_SIZE]*/
    const Argument output = {
        Category::Output,
        "output",
        "out_t",
    }; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &table,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "int8_t"},
            {"table_t", "int8_t"},
            {"out_t", "int8_t"},
            {"TABLE_SIZE", "256"},
        },  // signed 8
        {
            {"in_t", "int16_t"},
            {"table_t", "int16_t"},
            {"out_t", "int32_t"},
            {"TABLE_SIZE", "513"},
        },  // signed 16
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_10u6py7exa66n(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
    RequireCheck_3o6eotvyt76cz(op, context);
}

void ValidateOperator_ABS(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, size as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_BITWISE_NOT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, size as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_CEIL(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, size as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_CLZ(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, size as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_EXP(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, size as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_FLOOR(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, size as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_LOG(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, size as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_LOGICAL_NOT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, size as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_NEGATE(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument input1_zp = {
        Category::Attribute,
        "input1_zp",
        "in_out_t",
    }; /*Input 1 zero point. Must be zero for non-int8 types. shape=-*/
    const Argument output_zp = {
        Category::Attribute,
        "output_zp",
        "in_out_t",
    }; /*Output zero point. Must be zero for non-int8 types. shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, size as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input1_zp,
        &output_zp,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int8_t"},
            {"acc_t", "int32_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
            {"acc_t", "int32_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
            {"acc_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_38qvty7pudfz2(op, context);
    ErrorIfCheck_1n0denkrrrlr1(op, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_RECIPROCAL(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, size as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_RSQRT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, size as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_SELECT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "bool_t",
    }; /*Input selector tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_out_t",
    }; /*Input value tensor if input1 is True shape=shape2*/
    const Argument input3 = {
        Category::Input,
        "input3",
        "in_out_t",
    }; /*Input value tensor if input1 is False shape=shape3*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type as input2 and input3, with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &input3,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    ErrorIfCheck_3tccsjner0km9(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_EQUAL(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "int32_t"},
            {"out_t", "bool_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_GREATER(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "int32_t"},
            {"out_t", "bool_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_GREATER_EQUAL(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_t",
    }; /*Input tensor shape=shape1*/
    const Argument input2 = {
        Category::Input,
        "input2",
        "in_t",
    }; /*Input tensor with the same rank as input1 shape=shape2*/
    const Argument output = {
        Category::Output,
        "output",
        "out_t",
    }; /*Output tensor with broadcast shape if necessary shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &input2,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "int32_t"},
            {"out_t", "bool_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1yism57if6v2z(op, context);
    ErrorIfCheck_3k5ug2w7gxc7r(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_REDUCE_ALL(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_out_t",
    }; /*Input tensor with rank from 1 to 4 shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "int32_t",
    }; /*Axis to reduce, in range from 0 to rank(shape1)-1 shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor. Same rank as the input tensor. shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // boolean
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3tg4p2a5te0jy(op, context);
    ErrorIfCheck_33exz9gn2i1wy(op, context);
}

void ValidateOperator_REDUCE_ANY(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_out_t",
    }; /*Input tensor with rank from 1 to 4 shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "int32_t",
    }; /*Axis to reduce, in range from 0 to rank(shape1)-1 shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor. Same rank as the input tensor. shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // boolean
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3tg4p2a5te0jy(op, context);
    ErrorIfCheck_33exz9gn2i1wy(op, context);
}

void ValidateOperator_REDUCE_MAX(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_out_t",
    }; /*Input tensor with rank from 1 to 4 shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "int32_t",
    }; /*Axis to reduce, in range from 0 to rank(shape1)-1 shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor. Same rank as the input tensor. shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3tg4p2a5te0jy(op, context);
    ErrorIfCheck_33exz9gn2i1wy(op, context);
}

void ValidateOperator_REDUCE_MIN(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_out_t",
    }; /*Input tensor with rank from 1 to 4 shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "int32_t",
    }; /*Axis to reduce, in range from 0 to rank(shape1)-1 shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor. Same rank as the input tensor. shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3tg4p2a5te0jy(op, context);
    ErrorIfCheck_33exz9gn2i1wy(op, context);
}

void ValidateOperator_REDUCE_PRODUCT(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_out_t",
    }; /*Input tensor with rank from 1 to 4 shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "int32_t",
    }; /*Axis to reduce, in range from 0 to rank(shape1)-1 shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor. Same rank as the input tensor. shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3tg4p2a5te0jy(op, context);
    ErrorIfCheck_33exz9gn2i1wy(op, context);
}

void ValidateOperator_REDUCE_SUM(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_out_t",
    }; /*Input tensor with rank from 1 to 4 shape=shape1*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "int32_t",
    }; /*Axis to reduce, in range from 0 to rank(shape1)-1 shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor. Same rank as the input tensor. shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3tg4p2a5te0jy(op, context);
    ErrorIfCheck_33exz9gn2i1wy(op, context);
}

void ValidateOperator_CONCAT(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*List of input tensors. All inputs must have the same rank and data type shape=shapes1[]*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "int32_t",
    }; /*Axis along which concatenation is to occur, in range from 0 to rank(shape)-1 shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // boolean
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_14slfd7r77hgh(op, context);
    ErrorIfCheck_1fzhf02pkiw9z(op, context);
    ErrorIfCheck_16s99hvsej4fo(op, context);
    ErrorIfCheck_dctmd6sgn5n0(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_PAD(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor with minimum rank of one. shape=shape1*/
    const Argument padding = {Category::Attribute, "padding", "int32_t", {2, 2}}; /*Number of pad elements at the start
                                                                                     and end of each dimension
                                                                                     shape=[rank(shape1),2]*/
    const Argument pad_const = {
        Category::Attribute,
        "pad_const",
        "in_out_t",
    }; /*Constant value to be used as padding shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &padding,
        &pad_const,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // boolean
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_14z7y0qe9lwps(op, context);
    ErrorIfCheck_2rfef32dgp3be(op, context);
    ErrorIfCheck_2sfcgak3rj1vs(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_RESHAPE(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    };                                                                                /*Input tensor shape=shape1*/
    const Argument new_shape = {Category::Attribute, "new_shape", "int32_t", {1, 1}}; /*List of values, with each
                                                                                       element giving the size of the
                                                                                       result tensor for the given
                                                                                       dimension. At most one dimension
                                                                                       may be given as -1 to
                                                                                       automatically calculate the
                                                                                       dimension size.
                                                                                       shape=[rank(shape)]*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, size as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &new_shape,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // boolean
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_2a1jpygblc07i(op, context);
    LevelCheck_1lz89reckvj8d(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_REVERSE(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_out_t",
    }; /*Input tensor with minimum rank of one. shape=shape*/
    const Argument axis = {
        Category::Attribute,
        "axis",
        "int32_t",
    }; /*Axis to reverse, in range from 0 to rank(shape)-1 shape=-*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor. Same shape as input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &axis,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // boolean
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3hthyoock2ew5(op, context);
    ErrorIfCheck_10u6py7exa66n(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_SLICE(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor with minimum rank of one. shape=shape1*/
    const Argument start = {Category::Attribute, "start", "int32_t", {1, 1}}; /*List of integer coordinates, of length
                                                                               equal to the rank of input1. Start
                                                                               coordinate for slicing.
                                                                               shape=[rank(shape1)]*/
    const Argument size = {Category::Attribute, "size", "int32_t", {1, 1}};   /*List of integer size values, of length
                                                                               equal to the rank of input1. Size of the
                                                                               input to be used.   shape=[rank(shape1)]*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &start,
        &size,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // boolean
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1nifeiq9rvmb8(op, context);
    ErrorIfCheck_21rq6kn6p1yle(op, context);
    ErrorIfCheck_3rghkieqip43o(op, context);
    ErrorIfCheck_1cyv9n59wyyyc(op, context);
    ErrorIfCheck_3oy2tclc6uhsu(op, context);
    ErrorIfCheck_gpp3enlp1ddg(op, context);
    ErrorIfCheck_ix9div4ld46q(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_TILE(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor with minimum rank of one. shape=shape1*/
    const Argument multiplies = {Category::Attribute, "multiplies", "int32_t", {1, 1}}; /*Number of times to replicate
                                                                                           input1 in each dimension
                                                                                           shape=[rank(shape1)]*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, rank as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &multiplies,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // boolean
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_21rq6kn6p1yle(op, context);
    ErrorIfCheck_3estuseky2gm2(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_TRANSPOSE(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor with minimum rank of one. shape=shape1*/
    const Argument perms = {Category::Attribute, "perms", "int32_t", {1, 1}}; /*List of integers of length equal to the
                                                                               rank of input1. Values must be valid
                                                                               dimensions within shape1, and may not be
                                                                               repeated. shape=[rank(shape1)]*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of same type, rank as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &perms,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // boolean
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_21rq6kn6p1yle(op, context);
    ErrorIfCheck_2a1jpygblc07i(op, context);
    ErrorIfCheck_5bq1fx1llv8(op, context);
    ErrorIfCheck_ckwpttzajw06(op, context);
    ErrorIfCheck_2n1ratxgd89tx(op, context);
    ErrorIfCheck_aizwrn95lb0l(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_GATHER(const regor::Operation *op, const Context &context)
{
    const Argument values = {Category::Input, "values", "value_t", {3, 3}};   /*3D value tensor shape=[N,K,C]*/
    const Argument indices = {Category::Input, "indices", "index_t", {2, 2}}; /*2D index tensor shape=[N,W]*/
    const Argument output = {Category::Output, "output", "value_t", {3, 3}};  /*3D output tensor shape=[N,W,C]*/
    const std::vector<const Argument *> arguments = {
        &values,
        &indices,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"value_t", "int8_t"},
        },  // signed 8
        {
            {"value_t", "int16_t"},
        },  // signed 16
        {
            {"value_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_294afuxnedk9i(op, context);
    ErrorIfCheck_27p0n0pjt2bd6(op, context);
    ErrorIfCheck_1uwmsen32dse1(op, context);
    RequireCheck_31n0oq4yculbk(op, context);
}

void ValidateOperator_SCATTER(const regor::Operation *op, const Context &context)
{
    const Argument values_in = {Category::Input, "values_in", "value_t", {3, 3}}; /*3D values in tensor shape=[N,K,C]*/
    const Argument indices = {Category::Input, "indices", "index_t", {2, 2}};     /*2D index tensor shape=[N,W]*/
    const Argument input = {Category::Input, "input", "value_t", {3, 3}};         /*3D input tensor shape=[N,W,C]*/
    const Argument values_out = {Category::Output, "values_out", "value_t", {3, 3}}; /*3D output tensor shape=[N,K,C]*/
    const std::vector<const Argument *> arguments = {
        &values_in,
        &indices,
        &input,
        &values_out,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"value_t", "int8_t"},
        },  // signed 8
        {
            {"value_t", "int16_t"},
        },  // signed 16
        {
            {"value_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3c5bq3iswjd1x(op, context);
    ErrorIfCheck_53yuoon46swi(op, context);
    ErrorIfCheck_q9pgbwuvutqu(op, context);
    ErrorIfCheck_1qdcccs22lqtr(op, context);
    ErrorIfCheck_2azl8wc8mbsrj(op, context);
    ErrorIfCheck_122a36k26p0au(op, context);
    RequireCheck_31n0oq4yculbk(op, context);
    RequireCheck_2apk8ly9uthz6(op, context);
}

void ValidateOperator_RESIZE(const regor::Operation *op, const Context &context)
{
    const Argument input = {Category::Input, "input", "in_t", {4, 4}};          /*Input tensor shape=[N,IH,IW,C]*/
    const Argument scale = {Category::Attribute, "scale", "int16_t", {1, 1}};   /*[scale_y_n, scale_y_d, scale_x_n,
                                                                                   scale_x_d] shape=[4]*/
    const Argument offset = {Category::Attribute, "offset", "int16_t", {1, 1}}; /*[offset_y, offset_x] shape=[2]*/
    const Argument border = {Category::Attribute, "border", "int16_t", {1, 1}}; /*[border_y, border_x] shape=[2]*/
    const Argument mode = {
        Category::Attribute,
        "mode",
        "mode_t",
    };                                                                     /*BILINEAR or NEAREST shape=-*/
    const Argument output = {Category::Output, "output", "out_t", {4, 4}}; /*Output tensor shape=[N,OH,OW,C]*/
    const std::vector<const Argument *> arguments = {
        &input,
        &scale,
        &offset,
        &border,
        &mode,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"resize_t", "int16_t"},
            {"in_t", "int8_t"},
            {"out_t", "int32_t"},
        },  // signed 8, bilinear
        {
            {"resize_t", "int16_t"},
            {"in_t", "int8_t"},
            {"out_t", "int8_t"},
        },  // signed 8, nearest
        {
            {"resize_t", "int16_t"},
            {"in_t", "int16_t"},
            {"out_t", "int48_t"},
        },  // signed 16, bilinear
        {
            {"resize_t", "int16_t"},
            {"in_t", "int16_t"},
            {"out_t", "int16_t"},
        },  // signed 16, nearest
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_3sfcy967j2w8w(op, context);
    ErrorIfCheck_1obslcewwn583(op, context);
    ErrorIfCheck_3oxfjen91qb6l(op, context);
    ErrorIfCheck_1uo0z247e42af(op, context);
    ErrorIfCheck_1eovh9pyc6tyw(op, context);
    ErrorIfCheck_24jsin2zkf4ug(op, context);
    ErrorIfCheck_12uj5fltk5rbo(op, context);
    ErrorIfCheck_1py9f91imwjxe(op, context);
    ErrorIfCheck_fn614zzdrdfd(op, context);
    ErrorIfCheck_338aejy0aeqeg(op, context);
    ErrorIfCheck_1c57olj698f3d(op, context);
    LevelCheck_1r40jc4ashh6o(op, context);
    LevelCheck_1u7rtl141felu(op, context);
}

void ValidateOperator_CAST(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "out_t",
    }; /*Output tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "bool_t"},
            {"out_t", "int8_t"},
        },  // bool to signed 8
        {
            {"in_t", "bool_t"},
            {"out_t", "int16_t"},
        },  // bool to signed 16
        {
            {"in_t", "bool_t"},
            {"out_t", "int32_t"},
        },  // bool to signed 32
        {
            {"in_t", "int8_t"},
            {"out_t", "bool_t"},
        },  // signed 8 to bool
        {
            {"in_t", "int8_t"},
            {"out_t", "int16_t"},
        },  // signed 8 to signed 16
        {
            {"in_t", "int8_t"},
            {"out_t", "int32_t"},
        },  // signed 8 to signed 32
        {
            {"in_t", "int16_t"},
            {"out_t", "bool_t"},
        },  // signed 16 to bool
        {
            {"in_t", "int16_t"},
            {"out_t", "int8_t"},
        },  // signed 16 to signed 8
        {
            {"in_t", "int16_t"},
            {"out_t", "int32_t"},
        },  // signed 16 to signed 32
        {
            {"in_t", "int32_t"},
            {"out_t", "bool_t"},
        },  // signed 32 to bool
        {
            {"in_t", "int32_t"},
            {"out_t", "int8_t"},
        },  // signed 32 to signed 8
        {
            {"in_t", "int32_t"},
            {"out_t", "int16_t"},
        },  // signed 32 to signed 16
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_10u6py7exa66n(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_RESCALE(const regor::Operation *op, const Context &context)
{
    const Argument input = {
        Category::Input,
        "input",
        "in_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "out_t",
    }; /*Output tensor with the same shape as input shape=shape*/
    const Argument input_zp = {
        Category::Attribute,
        "input_zp",
        "in_t",
    }; /*Input tensor zero point. Must be zero for non-int8 types. shape=-*/
    const Argument output_zp = {
        Category::Attribute,
        "output_zp",
        "out_t",
    }; /*Output tensor zero point. Must be zero for non-int8 types. shape=-*/
    const Argument multiplier = {Category::Attribute, "multiplier", "mul_t", {1, 1}}; /*Scaling multiplier array
                                                                                         shape=[NC]*/
    const Argument shift = {Category::Attribute, "shift", "uint6_t", {1, 1}};         /*Scaling shift array shape=[NC]*/
    const Argument scale32 = {
        Category::Attribute,
        "scale32",
        "bool_t",
    }; /*if (scale32) mul_t=int32_t else mul_t=int16_t shape=-*/
    const Argument double_round = {
        Category::Attribute,
        "double_round",
        "bool_t",
    }; /*Select double round mode shape=-*/
    const Argument per_channel = {
        Category::Attribute,
        "per_channel",
        "bool_t",
    }; /*if (per_channel) NC=shape[rank(shape)-1] else NC=1 shape=-*/
    const std::vector<const Argument *> arguments = {
        &input,
        &output,
        &input_zp,
        &output_zp,
        &multiplier,
        &shift,
        &scale32,
        &double_round,
        &per_channel,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_t", "int8_t"},
            {"out_t", "int8_t"},
        },  // signed 8 to signed 8
        {
            {"in_t", "int8_t"},
            {"out_t", "int16_t"},
        },  // signed 8 to signed 16
        {
            {"in_t", "int8_t"},
            {"out_t", "int32_t"},
        },  // signed 8 to signed 32
        {
            {"in_t", "int8_t"},
            {"out_t", "uint8_t"},
        },  // signed 8 to unsigned 8
        {
            {"in_t", "int16_t"},
            {"out_t", "int8_t"},
        },  // signed 16 to signed 8
        {
            {"in_t", "int16_t"},
            {"out_t", "int16_t"},
        },  // signed 16 to signed 16
        {
            {"in_t", "int16_t"},
            {"out_t", "int32_t"},
        },  // signed 16 to signed 32
        {
            {"in_t", "int16_t"},
            {"out_t", "uint8_t"},
        },  // signed 16 to unsigned 8
        {
            {"in_t", "int16_t"},
            {"out_t", "uint16_t"},
        },  // signed 16 to unsigned 16
        {
            {"in_t", "int32_t"},
            {"out_t", "int8_t"},
        },  // signed 32 to signed 8
        {
            {"in_t", "int32_t"},
            {"out_t", "int16_t"},
        },  // signed 32 to signed 16
        {
            {"in_t", "int32_t"},
            {"out_t", "int32_t"},
        },  // signed 32 to signed 32
        {
            {"in_t", "int48_t"},
            {"out_t", "int8_t"},
        },  // signed 48 to signed 8
        {
            {"in_t", "int48_t"},
            {"out_t", "int16_t"},
        },  // signed 48 to signed 16
        {
            {"in_t", "int48_t"},
            {"out_t", "int32_t"},
        },  // signed 48 to signed 32
        {
            {"in_t", "uint8_t"},
            {"out_t", "int8_t"},
        },  // unsigned 8 to signed 8
        {
            {"in_t", "uint8_t"},
            {"out_t", "int16_t"},
        },  // unsigned 8 to signed 16
        {
            {"in_t", "uint16_t"},
            {"out_t", "int16_t"},
        },  // unsigned 16 to signed 16
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_7p5naeft5ga8(op, context);
    ErrorIfCheck_2hqaqrremyime(op, context);
    ErrorIfCheck_1wo90hck51cpk(op, context);
    ErrorIfCheck_v4b9g32rnf6p(op, context);
    ErrorIfCheck_22dev8it3bz2g(op, context);
    ErrorIfCheck_3ms1pbkpa2td9(op, context);
    ErrorIfCheck_31ty7f0kcbfxg(op, context);
    ErrorIfCheck_10u6py7exa66n(op, context);
    LevelCheck_1flzmpv6hubzc(op, context);
}

void ValidateOperator_IDENTITY(const regor::Operation *op, const Context &context)
{
    const Argument input1 = {
        Category::Input,
        "input1",
        "in_out_t",
    }; /*Input tensor shape=shape*/
    const Argument output = {
        Category::Output,
        "output",
        "in_out_t",
    }; /*Output tensor of the same type, size as the input tensor shape=shape*/
    const std::vector<const Argument *> arguments = {
        &input1,
        &output,
    };
    const std::vector<Typesupport> typesupports = {
        {
            {"in_out_t", "bool_t"},
        },  // Boolean
        {
            {"in_out_t", "int8_t"},
        },  // signed 8
        {
            {"in_out_t", "int16_t"},
        },  // signed 16
        {
            {"in_out_t", "int32_t"},
        },  // signed 32
    };
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_396rg8p65j58r(op, context);
}

void ValidateOperator_COND_IF(const regor::Operation *op, const Context &context)
{
    const Argument input_list = {
        Category::Input,
        "input_list",
        "tensor_list_t",
    }; /*List of input tensors shape=-*/
    const Argument condition = {
        Category::Input,
        "condition",
        "bool_t",
    }; /*Input condition as a size 1 tensor shape=shape*/
    const Argument then_graph = {
        Category::Attribute,
        "then_graph",
        "tosa_graph_t",
    }; /*TOSA graph to execute if condition is true shape=-*/
    const Argument else_graph = {
        Category::Attribute,
        "else_graph",
        "tosa_graph_t",
    }; /*TOSA graph to execute if condition is false shape=-*/
    const Argument output_list = {
        Category::Output,
        "output_list",
        "tensor_list_t",
    }; /*List of output tensors shape=-*/
    const std::vector<const Argument *> arguments = {
        &input_list,
        &condition,
        &then_graph,
        &else_graph,
        &output_list,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_1bm39avugkqqd(op, context);
    ErrorIfCheck_3tv3oatlz37e2(op, context);
    ErrorIfCheck_n7biu53x2n6k(op, context);
    ErrorIfCheck_2fd4dk1zw032u(op, context);
    ErrorIfCheck_omgw2xdm6irr(op, context);
}

void ValidateOperator_WHILE_LOOP(const regor::Operation *op, const Context &context)
{
    const Argument input_list = {
        Category::Input,
        "input_list",
        "tensor_list_t",
    }; /*List of input tensors shape=-*/
    const Argument cond_graph = {
        Category::Attribute,
        "cond_graph",
        "tosa_graph_t",
    }; /*TOSA graph to evaluate the condition shape=-*/
    const Argument body_graph = {
        Category::Attribute,
        "body_graph",
        "tosa_graph_t",
    }; /*TOSA graph to execute the loop body shape=-*/
    const Argument output_list = {
        Category::Output,
        "output_list",
        "tensor_list_t",
    }; /*List of output tensors shape=-*/
    const std::vector<const Argument *> arguments = {
        &input_list,
        &cond_graph,
        &body_graph,
        &output_list,
    };
    const std::vector<Typesupport> typesupports = {};
    ValidateArguments(op, arguments, typesupports, context);
    ErrorIfCheck_18hgmc3pexnw4(op, context);
    ErrorIfCheck_12uu5ff3t3lv8(op, context);
    ErrorIfCheck_3puzf7van5acf(op, context);
    ErrorIfCheck_8tihij7a5ep0(op, context);
    ErrorIfCheck_3lu68v2531bjz(op, context);
    ErrorIfCheck_1fzl0zyxyd88z(op, context);
}

}  // namespace
namespace tosa
{
namespace validator
{

void ValidateOperator_Version_0_60_0_Profile_BI(const GraphApi::GraphOperation *graphOp, const Context &context)
{
    const auto *op = static_cast<const regor::Operation *>(graphOp);
    switch ( op->Type() )
    {
        case regor::OpType::ArgMax:
            ValidateOperator_ARGMAX(op, context);
            break;
        case regor::OpType::AvgPool:
            ValidateOperator_AVG_POOL2D(op, context);
            break;
        case regor::OpType::Conv2D:
            ValidateOperator_CONV2D(op, context);
            break;
        case regor::OpType::Conv3D:
            ValidateOperator_CONV3D(op, context);
            break;
        case regor::OpType::DepthwiseConv2D:
            ValidateOperator_DEPTHWISE_CONV2D(op, context);
            break;
        case regor::OpType::FullyConnected:
            ValidateOperator_FULLY_CONNECTED(op, context);
            break;
        case regor::OpType::MatMul:
            ValidateOperator_MATMUL(op, context);
            break;
        case regor::OpType::MaxPool:
            ValidateOperator_MAX_POOL2D(op, context);
            break;
        case regor::OpType::TransposeConv2D:
            ValidateOperator_TRANSPOSE_CONV2D(op, context);
            break;
        case regor::OpType::Clamp:
            ValidateOperator_CLAMP(op, context);
            break;
        case regor::OpType::Sigmoid:
            ValidateOperator_SIGMOID(op, context);
            break;
        case regor::OpType::Tanh:
            ValidateOperator_TANH(op, context);
            break;
        case regor::OpType::Add:
            ValidateOperator_ADD(op, context);
            break;
        case regor::OpType::Asr:
            ValidateOperator_ARITHMETIC_RIGHT_SHIFT(op, context);
            break;
        case regor::OpType::And:
            ValidateOperator_BITWISE_AND(op, context);
            break;
        case regor::OpType::Or:
            ValidateOperator_BITWISE_OR(op, context);
            break;
        case regor::OpType::Xor:
            ValidateOperator_BITWISE_XOR(op, context);
            break;
        case regor::OpType::Div:
            ValidateOperator_INTDIV(op, context);
            break;
        case regor::OpType::LogicalAnd:
            ValidateOperator_LOGICAL_AND(op, context);
            break;
        case regor::OpType::SHL:
            ValidateOperator_LOGICAL_LEFT_SHIFT(op, context);
            break;
        case regor::OpType::SHR:
            ValidateOperator_LOGICAL_RIGHT_SHIFT(op, context);
            break;
        case regor::OpType::LogicalOr:
            ValidateOperator_LOGICAL_OR(op, context);
            break;
        case regor::OpType::LogicalXor:
            ValidateOperator_LOGICAL_XOR(op, context);
            break;
        case regor::OpType::Maximum:
            ValidateOperator_MAXIMUM(op, context);
            break;
        case regor::OpType::Minimum:
            ValidateOperator_MINIMUM(op, context);
            break;
        case regor::OpType::Mul:
            ValidateOperator_MUL(op, context);
            break;
        case regor::OpType::Pow:
            ValidateOperator_POW(op, context);
            break;
        case regor::OpType::Sub:
            ValidateOperator_SUB(op, context);
            break;
        case regor::OpType::Table:
            ValidateOperator_TABLE(op, context);
            break;
        case regor::OpType::Abs:
            ValidateOperator_ABS(op, context);
            break;
        case regor::OpType::Not:
            ValidateOperator_BITWISE_NOT(op, context);
            break;
        case regor::OpType::Ceil:
            ValidateOperator_CEIL(op, context);
            break;
        case regor::OpType::CLZ:
            ValidateOperator_CLZ(op, context);
            break;
        case regor::OpType::Exp:
            ValidateOperator_EXP(op, context);
            break;
        case regor::OpType::Floor:
            ValidateOperator_FLOOR(op, context);
            break;
        case regor::OpType::Log:
            ValidateOperator_LOG(op, context);
            break;
        case regor::OpType::LogicalNot:
            ValidateOperator_LOGICAL_NOT(op, context);
            break;
        case regor::OpType::Neg:
            ValidateOperator_NEGATE(op, context);
            break;
        case regor::OpType::Reciprocal:
            ValidateOperator_RECIPROCAL(op, context);
            break;
        case regor::OpType::Rsqrt:
            ValidateOperator_RSQRT(op, context);
            break;
        case regor::OpType::Select:
            ValidateOperator_SELECT(op, context);
            break;
        case regor::OpType::Equal:
            ValidateOperator_EQUAL(op, context);
            break;
        case regor::OpType::Greater:
            ValidateOperator_GREATER(op, context);
            break;
        case regor::OpType::GreaterEqual:
            ValidateOperator_GREATER_EQUAL(op, context);
            break;
        case regor::OpType::ReduceAll:
            ValidateOperator_REDUCE_ALL(op, context);
            break;
        case regor::OpType::ReduceAny:
            ValidateOperator_REDUCE_ANY(op, context);
            break;
        case regor::OpType::ReduceMax:
            ValidateOperator_REDUCE_MAX(op, context);
            break;
        case regor::OpType::ReduceMin:
            ValidateOperator_REDUCE_MIN(op, context);
            break;
        case regor::OpType::ReduceProduct:
            ValidateOperator_REDUCE_PRODUCT(op, context);
            break;
        case regor::OpType::ReduceSum:
            ValidateOperator_REDUCE_SUM(op, context);
            break;
        case regor::OpType::Concat:
            ValidateOperator_CONCAT(op, context);
            break;
        case regor::OpType::Pad:
            ValidateOperator_PAD(op, context);
            break;
        case regor::OpType::Reshape:
            ValidateOperator_RESHAPE(op, context);
            break;
        case regor::OpType::Reverse:
            ValidateOperator_REVERSE(op, context);
            break;
        case regor::OpType::Slice:
            ValidateOperator_SLICE(op, context);
            break;
        case regor::OpType::Tile:
            ValidateOperator_TILE(op, context);
            break;
        case regor::OpType::Transpose:
            ValidateOperator_TRANSPOSE(op, context);
            break;
        case regor::OpType::Gather:
            ValidateOperator_GATHER(op, context);
            break;
        case regor::OpType::Scatter:
            ValidateOperator_SCATTER(op, context);
            break;
        case regor::OpType::Resize:
            ValidateOperator_RESIZE(op, context);
            break;
        case regor::OpType::Cast:
            ValidateOperator_CAST(op, context);
            break;
        case regor::OpType::Rescale:
            ValidateOperator_RESCALE(op, context);
            break;
        case regor::OpType::Identity:
            ValidateOperator_IDENTITY(op, context);
            break;
        case regor::OpType::If:
            ValidateOperator_COND_IF(op, context);
            break;
        case regor::OpType::While:
            ValidateOperator_WHILE_LOOP(op, context);
            break;
        case regor::OpType::Custom:  // passthrough or validate later
            break;
        default:
            throw std::invalid_argument("Unsupported operator");
    }
}

}  // namespace validator
}  // namespace tosa
