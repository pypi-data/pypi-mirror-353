"""
Optimization - Quantum Annealing Integration for Constitutional Dynamics

This module provides the QuantumAnnealer class, facilitating the use of
quantum annealers (like D-Wave), QAOA, and classical fallbacks (simulated annealing)
to solve QUBO problems generated by the AlignmentOptimizer. It's a key component
for finding optimal alignment trajectories within the PrincipiaDynamica framework's
application to constitutional AI.
"""

import os
import time
import random
import logging
import math
from typing import Dict, Tuple, List, Optional, Any, Union # Removed Callable as it wasn't used

logger = logging.getLogger("constitutional_dynamics.integrations.quantum")

# Check for D-Wave Ocean SDK
try:
    import dimod
    import dwave.system

    DWAVE_AVAILABLE = True
except ImportError:
    DWAVE_AVAILABLE = False
    logger.warning(
        "D-Wave Ocean SDK not found. D-Wave functionalities will not be available. "
        "Will fall back to classical simulation for 'dwave' annealer type."
    )

# Check for Qiskit
try:
    import qiskit
    from qiskit_optimization.applications import QuadraticProgram  # For QUBO to Ising
    from qiskit_optimization.translators import from_docplex_mp  # If using CPLEX model
    from qiskit.algorithms.minimum_eigensolvers import QAOA
    from qiskit.algorithms.optimizers import COBYLA
    from qiskit_aer.primitives import Sampler as AerSampler  # For sampling results
    from qiskit.quantum_info import Pauli, SparsePauliOp  # For operator construction

    QAOA_AVAILABLE = True
except ImportError:
    QAOA_AVAILABLE = False
    logger.warning(
        "Qiskit or Qiskit Aer/Optimization not found. QAOA solver will not be available. "
        "Will fall back to classical simulation for 'qaoa' annealer type."
    )


class QuantumAnnealer:
    """
    Wrapper for quantum annealing solvers with classical simulation fallbacks.

    Provides a unified interface to quantum annealing hardware (D-Wave),
    quantum-inspired algorithms (QAOA), and classical simulation
    alternatives for solving Quadratic Unconstrained Binary Optimization (QUBO)
    problems. These QUBOs are typically derived from alignment objectives
    defined in constitutional_dynamics.core.optimise, which stem from
    State Transition Calculus (STC) principles.
    """

    def __init__(self,
                 simulation_mode: Optional[bool] = None,
                 annealer_type: str = "dwave", # "dwave" or "qaoa"; crucial for STC-based optimization strategies
                 token: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 solver_name: Optional[str] = None,
                 verbose: bool = False):
        """
        Initialize the quantum annealer.
        The choice of annealer and simulation mode allows flexibility in applying
        PrincipiaDynamica's optimization strategies to various computational resources.

        Args:
            simulation_mode: If True, forces simulation mode. If False, tries to use
                             configured annealer. If None (default), attempts to auto-detect
                             availability and falls back to simulation if necessary.
            annealer_type: Type of annealer to attempt ("dwave" or "qaoa").
                           Defaults to "dwave".
            token: D-Wave API token. If None, attempts to load from DWAVE_API_TOKEN
                   environment variable.
            endpoint: D-Wave API endpoint.
            solver_name: Specific D-Wave solver name.
            verbose: Enable verbose logging for detailed operational output.
        """
        self.annealer_type = annealer_type.lower()
        self.token = token
        self.endpoint = endpoint
        self.solver_name = solver_name
        self.verbose = verbose
        self.sampler: Any = None  # To store the D-Wave sampler or Qiskit backend/config

        if verbose:
            logger.setLevel(logging.DEBUG)
        else:
            logger.setLevel(logging.INFO)

        # Determine initial simulation_mode based on availability if auto-detecting
        if simulation_mode is None:
            if self.annealer_type == "dwave" and not DWAVE_AVAILABLE:
                logger.warning("D-Wave Ocean SDK not available. Defaulting to simulation mode for D-Wave.")
                self.simulation_mode = True
            elif self.annealer_type == "qaoa" and not QAOA_AVAILABLE:
                logger.warning("Qiskit not available. Defaulting to simulation mode for QAOA.")
                self.simulation_mode = True
            else:
                self.simulation_mode = False  # Attempt to use configured annealer
        else:
            self.simulation_mode = simulation_mode

        self._initialize_annealer()

    def _initialize_annealer(self):
        """Initialize the appropriate annealer or set to simulation mode."""
        if self.simulation_mode:
            logger.info(
                f"Simulation mode explicitly enabled or forced due to missing dependencies for '{self.annealer_type}'.")
            self.sampler = "simulation"
            return

        if self.annealer_type == "dwave":
            if DWAVE_AVAILABLE:
                try:
                    self._initialize_dwave()
                    if self.sampler:
                        logger.info(
                            f"Successfully initialized D-Wave sampler: {self.sampler.solver.name if hasattr(self.sampler, 'solver') else 'Unknown D-Wave Solver'}")
                    else:  # Initialization failed despite DWAVE_AVAILABLE being true
                        logger.warning("D-Wave sampler initialization failed. Falling back to simulation.")
                        self.simulation_mode = True
                        self.sampler = "simulation"
                except Exception as e:
                    logger.warning(f"Error initializing D-Wave sampler: {e}. Falling back to simulation.")
                    self.simulation_mode = True
                    self.sampler = "simulation"
            else:  # Should have been caught by simulation_mode logic, but as a safeguard
                logger.error("D-Wave SDK is not available. Cannot initialize D-Wave sampler. Using simulation.")
                self.simulation_mode = True
                self.sampler = "simulation"

        elif self.annealer_type == "qaoa":
            if QAOA_AVAILABLE:
                try:
                    self._initialize_qaoa()
                    if self.sampler:
                        logger.info("Successfully initialized QAOA solver configuration.")
                    else:  # Initialization failed
                        logger.warning("QAOA sampler initialization failed. Falling back to simulation.")
                        self.simulation_mode = True
                        self.sampler = "simulation"
                except Exception as e:
                    logger.warning(f"Error initializing QAOA sampler: {e}. Falling back to simulation.")
                    self.simulation_mode = True
                    self.sampler = "simulation"
            else:  # Should have been caught by simulation_mode logic
                logger.error("Qiskit is not available. Cannot initialize QAOA sampler. Using simulation.")
                self.simulation_mode = True
                self.sampler = "simulation"
        else:
            logger.error(f"Unknown annealer type: '{self.annealer_type}'. Using simulation mode.")
            self.simulation_mode = True
            self.sampler = "simulation"

    def _initialize_dwave(self):
        """Initialize connection to D-Wave quantum annealer."""
        # Token resolution
        api_token = self.token or os.environ.get("DWAVE_API_TOKEN")
        if not api_token:
            logger.warning(
                "D-Wave API token not provided and DWAVE_API_TOKEN environment variable not set. Cannot connect to D-Wave.")
            self.sampler = None
            return

        client_config = {"token": api_token}
        if self.endpoint:
            client_config["endpoint"] = self.endpoint

        solver_filter = {}
        if self.solver_name:
            solver_filter["solver"] = self.solver_name
        else:
            # Example: Prefer a specific type of solver if no name is given
            solver_filter["solver"] = {'qpu': True}  # Or other filters like 'advantage'

        self.sampler = dwave.system.DWaveSampler(**client_config)
        # EmbeddingComposite will be applied at solve time if needed
        # self.sampler = dwave.system.EmbeddingComposite(dwave.system.DWaveSampler(**client_config, **solver_filter))
        # logger.info(f"D-Wave sampler configured for solver: {self.sampler.child.solver.name}")

    def _initialize_qaoa(self):
        """Initialize QAOA solver components using Qiskit."""
        # Using AerSampler for simulation of QAOA execution
        self.sampler = {
            "backend": AerSampler(),  # Qiskit Aer's Sampler primitive
            "optimizer": COBYLA(),
            "reps": 1  # Default QAOA repetitions (p parameter)
        }

    def _qubo_to_ising_operator(self, Q: Dict[Union[int, Tuple[int, int]], float]) -> Tuple[Any, float]:
        """
        Convert a QUBO problem (often representing alignment costs and STC-derived
        transition preferences) to an Ising Hamiltonian operator for QAOA.

        QUBO: sum_i Q_ii * x_i + sum_{i<j} Q_ij * x_i * x_j
        x_i = (1 - Z_i) / 2
        Returns (Ising_op, offset)
        """
        if not QAOA_AVAILABLE:
            raise ImportError("Qiskit Optimization is required for QUBO to Ising conversion.")

        # Create a QuadraticProgram from the QUBO
        qp = QuadraticProgram("QUBO_problem")
        var_names = sorted(list(
            set(k[0] for k in Q if isinstance(k, tuple)) | set(k for k in Q if not isinstance(k, tuple)) | set(
                k[1] for k in Q if isinstance(k, tuple))))

        # Ensure variables are added if they only appear in quadratic terms
        all_vars_in_Q = set()
        for k in Q.keys():
            if isinstance(k, tuple):
                all_vars_in_Q.add(k[0])
                all_vars_in_Q.add(k[1])
            else:
                all_vars_in_Q.add(k)

        var_map = {name: qp.binary_var(name=str(name)) for name in sorted(list(all_vars_in_Q))}

        linear_terms = {var_map[k]: v for k, v in Q.items() if not isinstance(k, tuple)}
        quadratic_terms = {(var_map[k[0]], var_map[k[1]]): v for k, v in Q.items() if isinstance(k, tuple)}

        qp.minimize(linear=linear_terms, quadratic=quadratic_terms)

        # Convert QuadraticProgram to Ising Hamiltonian
        ising_op, offset = qp.to_ising()
        return ising_op, offset

    def solve_qubo(self,
                   Q: Dict[Union[int, Tuple[int, int]], float],  # Allow single var keys for linear terms
                   num_reads: int = 1000,
                   annealing_time: Optional[float] = None,  # D-Wave specific
                   chain_strength: Optional[float] = None,  # D-Wave specific
                   sa_schedule: str = "geometric",  # Simulated Annealing specific
                   initial_temperature: Optional[float] = None,  # Simulated Annealing specific
                   qaoa_reps: int = 1,  # QAOA specific
                   qaoa_optimizer: Optional[Any] = None,  # QAOA specific
                   **kwargs) -> Dict[str, Any]:
        """
        Solve a QUBO problem, typically constructed by AlignmentOptimizer to find
        low-cost (high-alignment, STC-preferred) state trajectories.

        Args:
            Q: QUBO dictionary. Keys are tuples (i, j) for quadratic terms Q_ij * x_i * x_j,
               or single elements `i` for linear terms Q_ii * x_i.
               Example: {(0,0): 1, (1,1): 1, (0,1): -2} or {0:1, 1:1, (0,1):-2}
            num_reads: Number of samples/reads.
            annealing_time: Annealing time in microseconds (D-Wave).
            chain_strength: Chain strength for embedding (D-Wave).
            sa_schedule: Schedule for simulated annealing ("geometric" or "linear").
            initial_temperature: Initial temperature for simulated annealing.
            qaoa_reps: Number of QAOA repetitions (p parameter).
            qaoa_optimizer: Qiskit optimizer instance for QAOA.
            **kwargs: Additional solver-specific parameters.

        Returns:
            Dictionary with solution information:
            {
                "samples": [{"solution": dict, "energy": float, "occurrences": int}, ...],
                "num_reads": int,
                "best_solution": dict,
                "best_energy": float,
                "solver": str,
                "solve_time": float,
                ... (solver-specific info)
            }
        """
        start_time = time.time()

        # Normalize Q to handle single-variable keys as linear terms Q_ii x_i
        # D-Wave's sample_qubo expects Q_ij for linear terms to be (i,i)
        normalized_Q = {}
        max_idx = -1
        q_vars = set()

        for k, v in Q.items():
            if isinstance(k, tuple):
                normalized_Q[(k[0], k[1])] = v
                q_vars.add(k[0])
                q_vars.add(k[1])
                max_idx = max(max_idx, k[0], k[1])
            else:  # Linear term Q_i x_i, represented as Q_ii x_i
                normalized_Q[(k, k)] = v
                q_vars.add(k)
                max_idx = max(max_idx, k)

        # Identify all unique variables involved to map them to 0...N-1 if needed
        # For simplicity, assuming variables are already 0-indexed integers or can be mapped
        # For QAOA, variable names in QUBO are preserved by QuadraticProgram

        result: Dict[str, Any] = {}

        if self.simulation_mode or self.sampler == "simulation":
            logger.info(f"Using classical simulated annealing for QUBO from constitutional_dynamics ({len(normalized_Q)} terms, {num_reads} reads)")
            result = self._solve_with_simulation(
                normalized_Q, num_reads, schedule=sa_schedule,
                initial_temperature=initial_temperature, **kwargs
            )
        elif self.annealer_type == "dwave" and DWAVE_AVAILABLE and isinstance(self.sampler,
                                                                              dwave.system.samplers.DWaveSampler):
            logger.info(f"Solving QUBO from constitutional_dynamics with D-Wave ({len(normalized_Q)} terms, {num_reads} reads)")
            result = self._solve_with_dwave(
                normalized_Q, num_reads, annealing_time=annealing_time,
                chain_strength=chain_strength, **kwargs
            )
        elif self.annealer_type == "qaoa" and QAOA_AVAILABLE and self.sampler:
            logger.info(f"Solving QUBO from constitutional_dynamics with QAOA ({len(normalized_Q)} terms, p={kwargs.get('qaoa_reps', qaoa_reps)})") # Corrected qaoa_reps access
            result = self._solve_with_qaoa(
                Q,  # QAOA conversion might prefer original Q format
                num_reads,
                p=qaoa_reps,
                optimizer=qaoa_optimizer or self.sampler["optimizer"],
                quantum_instance=self.sampler["backend"],
                **kwargs
            )
        else:
            logger.warning("No specific solver successfully initialized or matched. Falling back to simulation.")
            result = self._solve_with_simulation(
                normalized_Q, num_reads, schedule=sa_schedule,
                initial_temperature=initial_temperature, **kwargs
            )

        result["solve_time"] = time.time() - start_time
        return result

    def _solve_with_dwave(self, Q_norm: Dict[Tuple[int, int], float], num_reads: int,
                          annealing_time: Optional[float] = None,
                          chain_strength: Optional[float] = None, **kwargs) -> Dict[str, Any]:
        """Solve QUBO using D-Wave quantum annealer."""
        try:
            sampler_embedded = dwave.system.EmbeddingComposite(self.sampler)

            dw_params = {"num_reads": num_reads}
            if annealing_time is not None:
                dw_params["annealing_time"] = annealing_time
            if chain_strength is not None:
                dw_params["chain_strength"] = chain_strength
            dw_params.update(kwargs)

            response = sampler_embedded.sample_qubo(Q_norm, **dw_params)

            samples = []
            min_energy = float('inf')
            best_solution = {}

            for record in response.record:
                sample_solution = dict(record.sample)
                sample_energy = float(record.energy)
                num_occurrences = int(record.num_occurrences)
                samples.append({
                    "solution": sample_solution,
                    "energy": sample_energy,
                    "occurrences": num_occurrences
                })
                if sample_energy < min_energy:
                    min_energy = sample_energy
                    best_solution = sample_solution

            # Sort by energy is good practice, D-Wave usually returns them sorted though
            samples.sort(key=lambda x: x["energy"])

            return {
                "samples": samples,
                "num_reads": num_reads,  # This is the requested num_reads
                "best_solution": best_solution if samples else {},
                "best_energy": min_energy if samples else float('inf'),
                "solver": "dwave",
                "solver_info": response.info
            }

        except Exception as e:
            logger.error(f"Error solving with D-Wave: {e}. Falling back to simulation.")
            # Ensure Q_norm is passed to simulation if D-Wave fails
            return self._solve_with_simulation(Q_norm, num_reads, **kwargs)

    def _solve_with_qaoa(self, Q: Dict[Union[int, Tuple[int, int]], float], num_reads: int,
                         p: int = 1, optimizer: Optional[Any] = None,
                         quantum_instance: Optional[Any] = None, **kwargs) -> Dict[str, Any]:
        """
        Solve QUBO using QAOA. This method explores quantum-inspired optimization
        for STC-based alignment problems. QAOA's performance can be sensitive to
        parameter choices (reps, optimizer).
        """
        try:
            ising_op, offset = self._qubo_to_ising_operator(Q)

            qaoa_mes = QAOA(
                sampler=quantum_instance or self.sampler["backend"],  # Use AerSampler
                optimizer=optimizer or self.sampler["optimizer"],
                reps=p
            )
            result = qaoa_mes.compute_minimum_eigenvalue(operator=ising_op)

            # The result.eigenstate is often a quasi-distribution or a dict
            # For Sampler primitive, result.eigenstate is a QuasiDistribution
            # We need to interpret this to get samples

            samples = []
            if hasattr(result.eigenstate, 'binary_probabilities'):  # For QuasiDistribution
                # Get the most probable bitstrings
                probabilities = result.eigenstate.binary_probabilities(num_bits=ising_op.num_qubits)
                # Convert to samples format, might need to sample if num_reads is high
                # For simplicity, let's take top states if possible, or sample

                # This is a simplification. For true "num_reads", one might sample
                # from this distribution or run the circuit `num_reads` times.
                # Here, we'll list the probable states.

                # Extract variable names/indices as strings from QuadraticProgram if possible
                # Assuming variables were named '0', '1', ... during _qubo_to_ising_operator
                var_names = [str(i) for i in range(ising_op.num_qubits)]

                for i, bitstr in enumerate(result.eigenstate.keys()):  # Iterate over bitstrings
                    # Qiskit bitstrings are often LSB first, ensure correct interpretation
                    solution_dict = {var_names[j]: int(bitstr[ising_op.num_qubits - 1 - j]) for j in
                                     range(ising_op.num_qubits)}

                    # Calculate energy for this specific solution w.r.t. original QUBO
                    # This QUBO energy reflects the alignment cost from constitutional_dynamics.
                    qubo_energy = self._calculate_energy(solution_dict, Q)  # Use original Q

                    samples.append({
                        "solution": solution_dict,
                        "energy": qubo_energy,  # QUBO energy
                        "ising_energy": float(result.eigenstate[bitstr]),  # Ising energy (eigenvalue)
                        "occurrences": int(probabilities.get(bitstr, 0) * num_reads) if probabilities else 1
                        # Approximate occurrences
                    })
                    if len(samples) >= num_reads and num_reads > 0:  # If num_reads is for distinct solutions
                        break
            else:  # Fallback if binary_probabilities is not available (e.g. from exact diagonalization)
                # This part needs robust handling of different result types from QAOA
                solution_bitstr = result.optimal_parameters[
                    'x']  # This might not be correct, depends on optimizer result format
                solution_dict = {str(i): int(solution_bitstr[i]) for i in range(len(solution_bitstr))}
                qubo_energy = self._calculate_energy(solution_dict, Q)
                samples.append({
                    "solution": solution_dict,
                    "energy": qubo_energy,
                    "ising_energy": float(result.eigenvalue.real) + offset,
                    "occurrences": num_reads  # If only one best solution is found
                })

            samples.sort(key=lambda x: x["energy"])  # Sort by QUBO energy

            return {
                "samples": samples,
                "num_reads": sum(s['occurrences'] for s in samples),
                "best_solution": samples[0]["solution"] if samples else {},
                "best_energy": samples[0]["energy"] if samples else float('inf'),
                "solver": "qaoa",
                "qaoa_reps": p,
                "ising_offset": offset,
                "qaoa_min_eigenvalue": float(result.eigenvalue.real) if result.eigenvalue is not None else None
            }

        except Exception as e:
            logger.error(f"Error solving with QAOA: {e}. Falling back to simulation.")
            return self._solve_with_simulation(Q, num_reads,
                                               **kwargs)  # Pass Q, not normalized_Q for consistency if SA handles it

    def _solve_with_simulation(self, Q_norm: Dict[Tuple[int, int], float], num_reads: int,
                               schedule="geometric", initial_temperature=None,
                               use_enhanced_sa: bool = True,
                               num_iterations: int = 1000, **kwargs) -> Dict[str, Any]:
        """
        Solve QUBO using classical simulated annealing. This provides an accessible
        fallback for optimizing alignment trajectories when quantum resources or
        specialized SDKs are unavailable.
        """

        # Get all unique variable indices from Q_norm
        variables = sorted(list(set(i for q_key in Q_norm for i in q_key)))
        if not variables:  # Handle empty QUBO
            return {
                "samples": [], "num_reads": 0, "best_solution": {},
                "best_energy": 0.0, "solver": "simulated_annealing", "schedule": schedule
            }

        raw_samples = []
        for _ in range(num_reads):
            if use_enhanced_sa:
                sample = self._enhanced_simulated_annealing(
                    Q_norm, variables, num_iterations=num_iterations, # Use Q_norm for consistency
                    schedule=schedule, initial_temperature=initial_temperature
                )
            else:
                sample = self._simulated_annealing(
                    Q_norm, variables, num_iterations=num_iterations, # Use Q_norm
                    schedule=schedule, initial_temperature=initial_temperature
                )
            raw_samples.append(sample)

        # Process results: group identical solutions and sum occurrences
        solution_map = {}
        for sample_run in raw_samples:
            # Convert solution to a hashable form (e.g., frozenset of items)
            # Assuming solution is {var_index: 0_or_1}
            solution_tuple = tuple(sorted(sample_run["solution"].items()))
            if solution_tuple not in solution_map:
                solution_map[solution_tuple] = {
                    "solution": sample_run["solution"],
                    "energy": sample_run["energy"],  # Energy from SA is already QUBO energy
                    "occurrences": 0
                }
            solution_map[solution_tuple]["occurrences"] += 1

        processed_samples = list(solution_map.values())
        processed_samples.sort(key=lambda x: x["energy"])

        return {
            "samples": processed_samples,
            "num_reads": num_reads,  # Total SA runs performed
            "best_solution": processed_samples[0]["solution"] if processed_samples else {},
            "best_energy": processed_samples[0]["energy"] if processed_samples else float('inf'),
            "solver": "simulated_annealing",
            "schedule": schedule,
            "enhancements_used": use_enhanced_sa
        }

    def _calculate_energy(self, solution: Dict[int, int], Q: Dict[Union[int, Tuple[int, int]], float]) -> float:
        """
        Calculate the energy of a given binary solution for a QUBO problem.
        The QUBO (Q) itself encodes the costs and preferences derived from
        STC-based alignment metrics in constitutional_dynamics.

        Handles Q with both single index keys (linear) and tuple keys (quadratic).
        """
        energy = 0.0
        for q_key, weight in Q.items():
            if isinstance(q_key, tuple):  # Quadratic term x_i * x_j
                i, j = q_key
                if i == j:  # Can also be Q_ii * x_i * x_i = Q_ii * x_i (since x_i is 0 or 1)
                    energy += weight * solution.get(i, 0)
                else:
                    energy += weight * solution.get(i, 0) * solution.get(j, 0)
            else:  # Linear term Q_i * x_i
                energy += weight * solution.get(q_key, 0)
        return energy

    def _simulated_annealing(self, Q: Dict[Union[int, Tuple[int, int]], float], variables: List[int],
                             num_iterations=1000, schedule="geometric", initial_temperature=None):
        """Basic simulated annealing implementation."""
        current_solution = {var: random.randint(0, 1) for var in variables}
        current_energy = self._calculate_energy(current_solution, Q)

        best_solution = current_solution.copy()
        best_energy = current_energy

        if initial_temperature is None:
            initial_temperature = max(1.0, abs(current_energy) / 10.0 if current_energy != 0 else 1.0)  # Avoid T=0

        temperature = initial_temperature

        for step in range(num_iterations):
            if temperature < 1e-6:  # Avoid issues with very small temperature
                break

            var_to_flip = random.choice(variables)
            new_solution = current_solution.copy()
            new_solution[var_to_flip] = 1 - new_solution[var_to_flip]
            new_energy = self._calculate_energy(new_solution, Q)

            delta_energy = new_energy - current_energy
            if delta_energy < 0 or random.random() < math.exp(-delta_energy / temperature):
                current_solution = new_solution
                current_energy = new_energy
                if current_energy < best_energy:
                    best_solution = current_solution.copy()
                    best_energy = current_energy

            if schedule == "geometric":
                temperature *= 0.99  # Common cooling rate
            elif schedule == "linear":
                temperature = initial_temperature * (1.0 - float(step + 1) / num_iterations)
            # Add other schedules if needed, e.g., logarithmic

            # Ensure temperature doesn't become zero or negative if linear schedule is imperfect
            temperature = max(temperature, 1e-6)

        return {"solution": best_solution, "energy": best_energy}

    def _enhanced_simulated_annealing(self, Q: Dict[Union[int, Tuple[int, int]], float], variables: List[int],
                                      num_iterations: int = 1000, schedule="geometric",
                                      initial_temperature: Optional[float] = None,
                                      reheat_threshold: int = 100, reheat_factor: float = 0.8,
                                      multi_flip_prob: float = 0.1, max_flips: int = 5):
        """Enhanced simulated annealing with adaptive temperature and multiple flips."""
        current_solution = {var: random.randint(0, 1) for var in variables}
        current_energy = self._calculate_energy(current_solution, Q)

        best_solution = current_solution.copy()
        best_energy = current_energy

        # Use a more robust initial temperature estimation if not provided
        if initial_temperature is None:
            std_dev_energy = 0
            if len(Q) > 1:  # Estimate energy landscape variance
                energies_sample = [self._calculate_energy({v: random.randint(0, 1) for v in variables}, Q) for _ in
                                   range(min(100, len(variables) * 5))]
                if len(energies_sample) > 1: std_dev_energy = np.std(energies_sample)
            initial_temperature = max(1.0, std_dev_energy if std_dev_energy > 0 else (
                abs(current_energy) / 10.0 if current_energy != 0 else 1.0))

        temperature = initial_temperature

        no_improvement_streak = 0

        for step in range(num_iterations):
            if temperature < 1e-6:
                break

            # Create a new candidate solution
            candidate_solution = current_solution.copy()

            # Determine number of variables to flip
            num_to_flip = 1
            if random.random() < multi_flip_prob and len(variables) > 1:
                num_to_flip = random.randint(1, min(max_flips, len(variables)))

            vars_to_flip = random.sample(variables, num_to_flip)
            for var in vars_to_flip:
                candidate_solution[var] = 1 - candidate_solution[var]

            candidate_energy = self._calculate_energy(candidate_solution, Q)
            delta_energy = candidate_energy - current_energy

            if delta_energy < 0 or random.random() < math.exp(-delta_energy / temperature):
                current_solution = candidate_solution
                current_energy = candidate_energy
                if current_energy < best_energy:
                    best_solution = current_solution.copy()
                    best_energy = current_energy
                    no_improvement_streak = 0
                else:
                    no_improvement_streak += 1
            else:
                no_improvement_streak += 1

            # Update temperature (adaptive cooling and reheating)
            if no_improvement_streak >= reheat_threshold:
                temperature = initial_temperature * reheat_factor  # Reheat
                no_improvement_streak = 0  # Reset streak
            elif schedule == "geometric":
                temperature *= 0.995  # Slower cooling than basic SA
            elif schedule == "linear":
                temperature = initial_temperature * (1.0 - float(step + 1) / num_iterations)

            temperature = max(temperature, 1e-6)  # Temperature floor

        return {"solution": best_solution, "energy": best_energy}


def create_annealer(simulation_mode: Optional[bool] = None,
                    annealer_type: str = "dwave",
                    token: Optional[str] = None,
                    endpoint: Optional[str] = None,
                    solver_name: Optional[str] = None,
                    verbose: bool = False) -> QuantumAnnealer:
    """
    Factory function to create and initialize a QuantumAnnealer instance.

    Args:
        simulation_mode: If True, forces simulation mode. If False, tries to use
                         configured annealer. If None (default), attempts to auto-detect.
        annealer_type: Type of annealer ("dwave" or "qaoa"). Defaults to "dwave".
        token: D-Wave API token.
        endpoint: D-Wave API endpoint.
        solver_name: Specific D-Wave solver name.
        verbose: Enable verbose logging.

    Returns:
        An initialized QuantumAnnealer instance.
    """
    return QuantumAnnealer(
        simulation_mode=simulation_mode,
        annealer_type=annealer_type,
        token=token,
        endpoint=endpoint,
        solver_name=solver_name,
        verbose=verbose
    )
