# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _maude
else:
    import _maude

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _maude.delete_SwigPyIterator

    def value(self):
        return _maude.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _maude.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _maude.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _maude.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _maude.SwigPyIterator_equal(self, x)

    def copy(self):
        return _maude.SwigPyIterator_copy(self)

    def next(self):
        return _maude.SwigPyIterator_next(self)

    def __next__(self):
        return _maude.SwigPyIterator___next__(self)

    def previous(self):
        return _maude.SwigPyIterator_previous(self)

    def advance(self, n):
        return _maude.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _maude.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _maude.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _maude.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _maude.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _maude.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _maude.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _maude:
_maude.SwigPyIterator_swigregister(SwigPyIterator)
class TokenVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.TokenVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.TokenVector___nonzero__(self)

    def __bool__(self):
        return _maude.TokenVector___bool__(self)

    def __len__(self):
        return _maude.TokenVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.TokenVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.TokenVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.TokenVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.TokenVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.TokenVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.TokenVector___setitem__(self, *args)

    def pop(self):
        return _maude.TokenVector_pop(self)

    def append(self, x):
        return _maude.TokenVector_append(self, x)

    def empty(self):
        return _maude.TokenVector_empty(self)

    def size(self):
        return _maude.TokenVector_size(self)

    def swap(self, v):
        return _maude.TokenVector_swap(self, v)

    def begin(self):
        return _maude.TokenVector_begin(self)

    def end(self):
        return _maude.TokenVector_end(self)

    def rbegin(self):
        return _maude.TokenVector_rbegin(self)

    def rend(self):
        return _maude.TokenVector_rend(self)

    def clear(self):
        return _maude.TokenVector_clear(self)

    def get_allocator(self):
        return _maude.TokenVector_get_allocator(self)

    def pop_back(self):
        return _maude.TokenVector_pop_back(self)

    def erase(self, *args):
        return _maude.TokenVector_erase(self, *args)

    def __init__(self, *args):
        _maude.TokenVector_swiginit(self, _maude.new_TokenVector(*args))

    def push_back(self, x):
        return _maude.TokenVector_push_back(self, x)

    def front(self):
        return _maude.TokenVector_front(self)

    def back(self):
        return _maude.TokenVector_back(self)

    def assign(self, n, x):
        return _maude.TokenVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.TokenVector_resize(self, *args)

    def insert(self, *args):
        return _maude.TokenVector_insert(self, *args)

    def reserve(self, n):
        return _maude.TokenVector_reserve(self, n)

    def capacity(self):
        return _maude.TokenVector_capacity(self)
    __swig_destroy__ = _maude.delete_TokenVector

# Register TokenVector in _maude:
_maude.TokenVector_swigregister(TokenVector)
class ModuleHeaderVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.ModuleHeaderVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.ModuleHeaderVector___nonzero__(self)

    def __bool__(self):
        return _maude.ModuleHeaderVector___bool__(self)

    def __len__(self):
        return _maude.ModuleHeaderVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.ModuleHeaderVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.ModuleHeaderVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.ModuleHeaderVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.ModuleHeaderVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.ModuleHeaderVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.ModuleHeaderVector___setitem__(self, *args)

    def pop(self):
        return _maude.ModuleHeaderVector_pop(self)

    def append(self, x):
        return _maude.ModuleHeaderVector_append(self, x)

    def empty(self):
        return _maude.ModuleHeaderVector_empty(self)

    def size(self):
        return _maude.ModuleHeaderVector_size(self)

    def swap(self, v):
        return _maude.ModuleHeaderVector_swap(self, v)

    def begin(self):
        return _maude.ModuleHeaderVector_begin(self)

    def end(self):
        return _maude.ModuleHeaderVector_end(self)

    def rbegin(self):
        return _maude.ModuleHeaderVector_rbegin(self)

    def rend(self):
        return _maude.ModuleHeaderVector_rend(self)

    def clear(self):
        return _maude.ModuleHeaderVector_clear(self)

    def get_allocator(self):
        return _maude.ModuleHeaderVector_get_allocator(self)

    def pop_back(self):
        return _maude.ModuleHeaderVector_pop_back(self)

    def erase(self, *args):
        return _maude.ModuleHeaderVector_erase(self, *args)

    def __init__(self, *args):
        _maude.ModuleHeaderVector_swiginit(self, _maude.new_ModuleHeaderVector(*args))

    def push_back(self, x):
        return _maude.ModuleHeaderVector_push_back(self, x)

    def front(self):
        return _maude.ModuleHeaderVector_front(self)

    def back(self):
        return _maude.ModuleHeaderVector_back(self)

    def assign(self, n, x):
        return _maude.ModuleHeaderVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.ModuleHeaderVector_resize(self, *args)

    def insert(self, *args):
        return _maude.ModuleHeaderVector_insert(self, *args)

    def reserve(self, n):
        return _maude.ModuleHeaderVector_reserve(self, n)

    def capacity(self):
        return _maude.ModuleHeaderVector_capacity(self)
    __swig_destroy__ = _maude.delete_ModuleHeaderVector

# Register ModuleHeaderVector in _maude:
_maude.ModuleHeaderVector_swigregister(ModuleHeaderVector)
class TermVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.TermVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.TermVector___nonzero__(self)

    def __bool__(self):
        return _maude.TermVector___bool__(self)

    def __len__(self):
        return _maude.TermVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.TermVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.TermVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.TermVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.TermVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.TermVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.TermVector___setitem__(self, *args)

    def pop(self):
        return _maude.TermVector_pop(self)

    def append(self, x):
        return _maude.TermVector_append(self, x)

    def empty(self):
        return _maude.TermVector_empty(self)

    def size(self):
        return _maude.TermVector_size(self)

    def swap(self, v):
        return _maude.TermVector_swap(self, v)

    def begin(self):
        return _maude.TermVector_begin(self)

    def end(self):
        return _maude.TermVector_end(self)

    def rbegin(self):
        return _maude.TermVector_rbegin(self)

    def rend(self):
        return _maude.TermVector_rend(self)

    def clear(self):
        return _maude.TermVector_clear(self)

    def get_allocator(self):
        return _maude.TermVector_get_allocator(self)

    def pop_back(self):
        return _maude.TermVector_pop_back(self)

    def erase(self, *args):
        return _maude.TermVector_erase(self, *args)

    def __init__(self, *args):
        _maude.TermVector_swiginit(self, _maude.new_TermVector(*args))

    def push_back(self, x):
        return _maude.TermVector_push_back(self, x)

    def front(self):
        return _maude.TermVector_front(self)

    def back(self):
        return _maude.TermVector_back(self)

    def assign(self, n, x):
        return _maude.TermVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.TermVector_resize(self, *args)

    def insert(self, *args):
        return _maude.TermVector_insert(self, *args)

    def reserve(self, n):
        return _maude.TermVector_reserve(self, n)

    def capacity(self):
        return _maude.TermVector_capacity(self)
    __swig_destroy__ = _maude.delete_TermVector

# Register TermVector in _maude:
_maude.TermVector_swigregister(TermVector)
class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.StringVector___nonzero__(self)

    def __bool__(self):
        return _maude.StringVector___bool__(self)

    def __len__(self):
        return _maude.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.StringVector___setitem__(self, *args)

    def pop(self):
        return _maude.StringVector_pop(self)

    def append(self, x):
        return _maude.StringVector_append(self, x)

    def empty(self):
        return _maude.StringVector_empty(self)

    def size(self):
        return _maude.StringVector_size(self)

    def swap(self, v):
        return _maude.StringVector_swap(self, v)

    def begin(self):
        return _maude.StringVector_begin(self)

    def end(self):
        return _maude.StringVector_end(self)

    def rbegin(self):
        return _maude.StringVector_rbegin(self)

    def rend(self):
        return _maude.StringVector_rend(self)

    def clear(self):
        return _maude.StringVector_clear(self)

    def get_allocator(self):
        return _maude.StringVector_get_allocator(self)

    def pop_back(self):
        return _maude.StringVector_pop_back(self)

    def erase(self, *args):
        return _maude.StringVector_erase(self, *args)

    def __init__(self, *args):
        _maude.StringVector_swiginit(self, _maude.new_StringVector(*args))

    def push_back(self, x):
        return _maude.StringVector_push_back(self, x)

    def front(self):
        return _maude.StringVector_front(self)

    def back(self):
        return _maude.StringVector_back(self)

    def assign(self, n, x):
        return _maude.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.StringVector_resize(self, *args)

    def insert(self, *args):
        return _maude.StringVector_insert(self, *args)

    def reserve(self, n):
        return _maude.StringVector_reserve(self, n)

    def capacity(self):
        return _maude.StringVector_capacity(self)
    __swig_destroy__ = _maude.delete_StringVector

# Register StringVector in _maude:
_maude.StringVector_swigregister(StringVector)
class TermPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _maude.TermPair_swiginit(self, _maude.new_TermPair(*args))
    first = property(_maude.TermPair_first_get, _maude.TermPair_first_set)
    second = property(_maude.TermPair_second_get, _maude.TermPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _maude.delete_TermPair

# Register TermPair in _maude:
_maude.TermPair_swigregister(TermPair)
class TermPairVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.TermPairVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.TermPairVector___nonzero__(self)

    def __bool__(self):
        return _maude.TermPairVector___bool__(self)

    def __len__(self):
        return _maude.TermPairVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.TermPairVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.TermPairVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.TermPairVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.TermPairVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.TermPairVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.TermPairVector___setitem__(self, *args)

    def pop(self):
        return _maude.TermPairVector_pop(self)

    def append(self, x):
        return _maude.TermPairVector_append(self, x)

    def empty(self):
        return _maude.TermPairVector_empty(self)

    def size(self):
        return _maude.TermPairVector_size(self)

    def swap(self, v):
        return _maude.TermPairVector_swap(self, v)

    def begin(self):
        return _maude.TermPairVector_begin(self)

    def end(self):
        return _maude.TermPairVector_end(self)

    def rbegin(self):
        return _maude.TermPairVector_rbegin(self)

    def rend(self):
        return _maude.TermPairVector_rend(self)

    def clear(self):
        return _maude.TermPairVector_clear(self)

    def get_allocator(self):
        return _maude.TermPairVector_get_allocator(self)

    def pop_back(self):
        return _maude.TermPairVector_pop_back(self)

    def erase(self, *args):
        return _maude.TermPairVector_erase(self, *args)

    def __init__(self, *args):
        _maude.TermPairVector_swiginit(self, _maude.new_TermPairVector(*args))

    def push_back(self, x):
        return _maude.TermPairVector_push_back(self, x)

    def front(self):
        return _maude.TermPairVector_front(self)

    def back(self):
        return _maude.TermPairVector_back(self)

    def assign(self, n, x):
        return _maude.TermPairVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.TermPairVector_resize(self, *args)

    def insert(self, *args):
        return _maude.TermPairVector_insert(self, *args)

    def reserve(self, n):
        return _maude.TermPairVector_reserve(self, n)

    def capacity(self):
        return _maude.TermPairVector_capacity(self)
    __swig_destroy__ = _maude.delete_TermPairVector

# Register TermPairVector in _maude:
_maude.TermPairVector_swigregister(TermPairVector)

__version__ = '1.5.0'


class VectorIterator:
	def __init__(self, vect, length):
		self.vect = vect
		self.i = 0
		self.length = length

	def __iter__(self):
		return self

	def __next__(self):
		if self.i >= self.length:
			raise StopIteration
		self.i = self.i + 1
		return self.vect[self.i - 1]

class OpDeclVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.OpDeclVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.OpDeclVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.OpDeclVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_OpDeclVector

# Register OpDeclVector in _maude:
_maude.OpDeclVector_swigregister(OpDeclVector)
class SortVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.SortVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.SortVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.SortVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_SortVector

# Register SortVector in _maude:
_maude.SortVector_swigregister(SortVector)
class SymbolVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.SymbolVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.SymbolVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.SymbolVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_SymbolVector

# Register SymbolVector in _maude:
_maude.SymbolVector_swigregister(SymbolVector)
class KindVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.KindVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.KindVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.KindVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_KindVector

# Register KindVector in _maude:
_maude.KindVector_swigregister(KindVector)
class SubsortVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.SubsortVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.SubsortVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.SubsortVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_SubsortVector

# Register SubsortVector in _maude:
_maude.SubsortVector_swigregister(SubsortVector)
class EquationVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.EquationVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.EquationVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.EquationVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_EquationVector

# Register EquationVector in _maude:
_maude.EquationVector_swigregister(EquationVector)
class RuleVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.RuleVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.RuleVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.RuleVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_RuleVector

# Register RuleVector in _maude:
_maude.RuleVector_swigregister(RuleVector)
class StratVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.StratVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.StratVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.StratVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_StratVector

# Register StratVector in _maude:
_maude.StratVector_swigregister(StratVector)
class StratDefVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.StratDefVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.StratDefVector_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.StratDefVector___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_StratDefVector

# Register StratDefVector in _maude:
_maude.StratDefVector_swigregister(StratDefVector)
class Condition(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.Condition_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.Condition_size(self)

    def __getitem__(self, n):
        r"""
        Get a vector position value.

        :type n: int
        :param n: Vector position from zero.
        """
        return _maude.Condition___getitem__(self, n)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	return 'empty' if self.empty() else (
    		', '.join([str(self[i]) for i in range(0, len(self))]))

    __len__ = size

    __swig_destroy__ = _maude.delete_Condition

# Register Condition in _maude:
_maude.Condition_swigregister(Condition)

def init(loadPrelude=True, randomSeed=0, advise=True, handleInterrupts=False):
    r"""
    Init Maude.

    This function must be called before anything else.

    :type loadPrelude: boolean, optional
    :param loadPrelude: Whether the Maude prelude should be loaded.
    :type randomSeed: int, optional
    :param randomSeed: Seed for the pseudorandom number generator in
        the ``RANDOM`` module.
    :type advise: boolean, optional
    :param advise: Whether debug messages should be printed.
    :type handleInterrupts: boolean, optional
    :param handleInterrupts: Whether interrupts are handled by Maude.
    """
    return _maude.init(loadPrelude, randomSeed, advise, handleInterrupts)

def load(name):
    r"""
    Load the file with the given name.

    :type name: string
    :param name: The name of the file (absolute or relative to the current
        working directory or ``MAUDE_LIB)``.
    """
    return _maude.load(name)

def input(text):
    r"""
    Process the given text as direct input to Maude.

    :type text: string
    :param text: Maude modules or commands.
    """
    return _maude.input(text)

def getCurrentModule():
    r"""
    Get the current module (the last module inserted or explicitly selected,
    like in the Maude interpreter).
    """
    return _maude.getCurrentModule()

def getModule(name):
    r"""
    Get a module or theory by name.

    :type name: string
    :param name: Name of the module or theory (module expressions are not allowed).
    """
    return _maude.getModule(name)

def downModule(term):
    r"""
    Get a module object from its metarepresentation in this
    module, which must include the ``META-LEVEL`` module.

    :type term: :py:class:`EasyTerm`
    :param term: The metarepresentation of a module, that is,
        a valid element of the ``Module`` sort in ``META-MODULE``.
        The term will be reduced.

    :rtype: :py:class:`VisibleModule`
    :return: The module object or null if the given term was not
        a valid module metarepresentation.
    """
    return _maude.downModule(term)

def tokenize(str):
    r"""
    Tokenize a string according to Maude lexer rules.

    :param tokenize: The string to be tokenized.

    :rtype: std::vector< Token,std::allocator< Token > >
    :return: A vector of tokens.
    """
    return _maude.tokenize(str)

def getModules():
    r"""
    Get the list of loaded modules.

    :rtype: std::vector< ModuleHeader,std::allocator< ModuleHeader > >
    :return: A list of module headers (this may change).
    """
    return _maude.getModules()

def getView(name):
    r"""
    Get a view by name.

    :type name: string
    :param name: Name of the view (view expressions are not allowed).
    """
    return _maude.getView(name)

def getViews():
    r"""Get the list of loaded views."""
    return _maude.getViews()
class ModuleHeader(object):
    r"""Module header information."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    type = property(_maude.ModuleHeader_type_get, doc=r"""Type of the module (see Module class)""")
    name = property(_maude.ModuleHeader_name_get, doc=r"""Name of the module""")

    def __repr__(self):
        return _maude.ModuleHeader___repr__(self)

    def __init__(self):
        _maude.ModuleHeader_swiginit(self, _maude.new_ModuleHeader())
    __swig_destroy__ = _maude.delete_ModuleHeader

# Register ModuleHeader in _maude:
_maude.ModuleHeader_swigregister(ModuleHeader)

def setAllowProcesses(flag):
    r"""
    Allow or disallow running arbitrary executables from Maude code.

    :type flag: boolean
    :param flag: Whether process creation should be allowed.
    """
    return _maude.setAllowProcesses(flag)

def setAllowFiles(flag):
    r"""
    Allow or disallow operations on files from Maude code.

    :type flag: boolean
    :param flag: Whether file access should be allowed.
    """
    return _maude.setAllowFiles(flag)

def setAllowDir(flag):
    r"""
    Allow or disallow operations on directories from Maude code.

    :type flag: boolean
    :param flag: Whether directory access should be allowed.
    """
    return _maude.setAllowDir(flag)

def setRandomSeed(randomSeed):
    r"""
    Set the pseudorandom number generator seed.

    :param seed: New pseudorandom number generator seed.
    """
    return _maude.setRandomSeed(randomSeed)

def setAssocUnifDepth(m):
    r"""
    Set depth multiplier for associative unification.

    :param seed: New depth multiplier (between 0 and 1e6).
    """
    return _maude.setAssocUnifDepth(m)
UNBOUNDED = _maude.UNBOUNDED
MAUDE_VERSION = _maude.MAUDE_VERSION
class ModuleItem(object):
    r"""An item that belongs to a module."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getModule(self):
        r"""Get the module where this item is defined."""
        return _maude.ModuleItem_getModule(self)
    __swig_destroy__ = _maude.delete_ModuleItem

# Register ModuleItem in _maude:
_maude.ModuleItem_swigregister(ModuleItem)
class Equation(ModuleItem):
    r"""A Maude equation."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.Equation_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.Equation_getRhs(self)

    def getLabel(self):
        r"""Get the label attribute."""
        return _maude.Equation_getLabel(self)

    def isNonexec(self):
        r"""Whether the equation has the ``nonexec`` attribute."""
        return _maude.Equation_isNonexec(self)

    def isOwise(self):
        r"""Whether the equation has the ``owise`` attribute."""
        return _maude.Equation_isOwise(self)

    def isVariant(self):
        r"""Whether the equation has the ``variant`` attribute."""
        return _maude.Equation_isVariant(self)

    def hasCondition(self):
        r"""Whether the equation has a condition."""
        return _maude.Equation_hasCondition(self)

    def getCondition(self):
        r"""Get the condition of the equation."""
        return _maude.Equation_getCondition(self)

    def __repr__(self):
        return _maude.Equation___repr__(self)

    def getMetadata(self):
        r"""Get the free text ``metadata`` attribute of this statement."""
        return _maude.Equation_getMetadata(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.Equation_getLineNumber(self)

    def hash(self):
        r"""Get the hash value of the equation."""
        return _maude.Equation_hash(self)

    def equal(self, other):
        r"""Check whether two equation are the same."""
        return _maude.Equation_equal(self, other)
    __swig_destroy__ = _maude.delete_Equation

    __hash__ = hash

    def __eq__(self, other):
    	return other is not None and self.equal(other)


# Register Equation in _maude:
_maude.Equation_swigregister(Equation)
class Sort(ModuleItem):
    r"""A Maude sort."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def kind(self):
        r"""Get the kind this sort belongs to."""
        return _maude.Sort_kind(self)

    def getSubsorts(self):
        r"""Get the subsorts of this sort."""
        return _maude.Sort_getSubsorts(self)

    def getSupersorts(self):
        r"""Get the supersorts of this sort."""
        return _maude.Sort_getSupersorts(self)

    def leq(self, rhs):
        r"""
        Check if this sort is a subsort of the given sort.

        :type rhs: :py:class:`Sort`
        :param rhs: The right-hand side of the comparison.
        """
        return _maude.Sort_leq(self, rhs)

    def __repr__(self):
        return _maude.Sort___repr__(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.Sort_getLineNumber(self)

    def hash(self):
        r"""Get the hash value of the sort."""
        return _maude.Sort_hash(self)

    def equal(self, other):
        r"""Check whether two sort are the same."""
        return _maude.Sort_equal(self, other)
    __swig_destroy__ = _maude.delete_Sort

    def __eq__(self, other):
    	return other is not None and self.equal(other)

    __le__ = leq
    __hash__ = hash


# Register Sort in _maude:
_maude.Sort_swigregister(Sort)
class Kind(object):
    r"""A Maude kind (connected component of sorts)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def nrSorts(self):
        r"""Get the number of sorts in this kind."""
        return _maude.Kind_nrSorts(self)

    def nrMaximalSorts(self):
        r"""Get the number of maximal sorts in this kind."""
        return _maude.Kind_nrMaximalSorts(self)

    def sort(self, index):
        r"""
        Get the sort with a given index in this kind.

        :type index: int
        :param index: Sort index.
        """
        return _maude.Kind_sort(self, index)

    def errorFree(self):
        r"""Whether the kind contains error terms."""
        return _maude.Kind_errorFree(self)

    def __repr__(self):
        return _maude.Kind___repr__(self)

    def hash(self):
        r"""Get the hash value of the kind."""
        return _maude.Kind_hash(self)

    def equal(self, other):
        r"""Check whether two kind are the same."""
        return _maude.Kind_equal(self, other)
    __swig_destroy__ = _maude.delete_Kind

    def __iter__(self):
    	return VectorIterator(self, len(self))

    __getitem__ = sort
    __len__ = nrSorts
    __hash__ = hash

    def __eq__(self, other):
    	return other is not None and self.equal(other)


# Register Kind in _maude:
_maude.Kind_swigregister(Kind)
class MembershipAxiom(ModuleItem):
    r"""A sort membership axiom."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getLhs(self):
        r"""Get the term of the membership axiom."""
        return _maude.MembershipAxiom_getLhs(self)

    def getSort(self):
        r"""Get the sort of the membership axiom."""
        return _maude.MembershipAxiom_getSort(self)

    def getCondition(self):
        r"""Get the condition of the membership axiom."""
        return _maude.MembershipAxiom_getCondition(self)

    def isNonexec(self):
        r"""Whether the membership axiom has the ``nonexec`` attribute."""
        return _maude.MembershipAxiom_isNonexec(self)

    def getLabel(self):
        r"""Get the label attribute."""
        return _maude.MembershipAxiom_getLabel(self)

    def __repr__(self):
        return _maude.MembershipAxiom___repr__(self)

    def getMetadata(self):
        r"""Get the free text ``metadata`` attribute of this statement."""
        return _maude.MembershipAxiom_getMetadata(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.MembershipAxiom_getLineNumber(self)

    def hash(self):
        r"""Get the hash value of the membership axiom."""
        return _maude.MembershipAxiom_hash(self)

    def equal(self, other):
        r"""Check whether two membership axiom are the same."""
        return _maude.MembershipAxiom_equal(self, other)
    __swig_destroy__ = _maude.delete_MembershipAxiom

    __hash__ = hash

    def __eq__(self, other):
    	return other is not None and self.equal(other)


# Register MembershipAxiom in _maude:
_maude.MembershipAxiom_swigregister(MembershipAxiom)
OP_ASSOC = _maude.OP_ASSOC
r"""associative"""
OP_COMM = _maude.OP_COMM
r"""commutative"""
OP_ITER = _maude.OP_ITER
r"""iterable"""
OP_IDEM = _maude.OP_IDEM
r"""idempotent"""
OP_LEFT_ID = _maude.OP_LEFT_ID
r"""with left identity element"""
OP_RIGHT_ID = _maude.OP_RIGHT_ID
r"""with right identity element"""
OP_MEMO = _maude.OP_MEMO
r"""with memoization"""
OP_SPECIAL = _maude.OP_SPECIAL
r"""special"""
class Symbol(ModuleItem):
    r"""A Maude symbol (operator at the kind level)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def arity(self):
        r"""Get the number of arguments."""
        return _maude.Symbol_arity(self)

    def domainKind(self, argNr):
        r"""
        Get the kind for the given argument.

        :type argNr: int
        :param argNr: The argument index.
        """
        return _maude.Symbol_domainKind(self, argNr)

    def getRangeSort(self):
        r"""Get the range sort of the symbol."""
        return _maude.Symbol_getRangeSort(self)

    def hash(self):
        r"""Get the hash value of the symbol."""
        return _maude.Symbol_hash(self)

    def equal(self, other):
        r"""Check whether two symbols are the same."""
        return _maude.Symbol_equal(self, other)

    def getOpDeclarations(self):
        r"""Get the declarations of the symbol."""
        return _maude.Symbol_getOpDeclarations(self)

    def makeTerm(self, args):
        r"""Build a term with this symbol and the given terms as arguments."""
        return _maude.Symbol_makeTerm(self, args)

    def getMetadata(self, index):
        r"""
        Get the metadata attribute of the given declaration of this symbol.

        :type index: int
        :param index: Index of the operator declaration.
        """
        return _maude.Symbol_getMetadata(self, index)

    def isAssoc(self):
        r"""
        Whether the symbol is associative.

        Deprecated: use ``hasAttr(OP_ASSOC)`` instead.
        """
        return _maude.Symbol_isAssoc(self)

    def hasAttr(self, attr):
        r"""
        Whether the symbol has the given attribute.

        :type attr: int
        :param attr: One of the ``OP_*`` constants for operator attributes.
        """
        return _maude.Symbol_hasAttr(self, attr)

    def getIdentity(self):
        r"""Get the identity element for this symbol (if any)."""
        return _maude.Symbol_getIdentity(self)

    def getStrategy(self):
        r"""Get the reduction strategy of the symbol."""
        return _maude.Symbol_getStrategy(self)

    def getFrozen(self):
        r"""
        Get the frozen attribute of the symbol.

        :rtype: std::vector< int,std::allocator< int > >
        :return: The sequence of indices in the frozen attribute,
            where arguments are numbered from 0 instead of 1.
        """
        return _maude.Symbol_getFrozen(self)

    def getFormat(self):
        r"""
        Get the format attribute of the symbol.

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: The sequence of instruction words of the format
            specification, each of them a string.
        """
        return _maude.Symbol_getFormat(self)

    def getPrec(self):
        r"""Get the syntactic precedence of the symbol."""
        return _maude.Symbol_getPrec(self)

    def getIdHooks(self):
        r"""
        Get the id-hooks of the special operator (or an empty sequence otherwise).

        :rtype: std::vector< std::vector< std::string,std::allocator< std::string > >,std::allocator< std::vector< std::string,std::allocator< std::string > > > >
        :return: A sequence of string sequences representing each an id-hook of
            the operator with its name followed by its arguments.
        """
        return _maude.Symbol_getIdHooks(self)

    def __repr__(self):
        return _maude.Symbol___repr__(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.Symbol_getLineNumber(self)
    __swig_destroy__ = _maude.delete_Symbol

    def __call__(self, *args):
    	return self.makeTerm(args)

    def __eq__(self, other):
    	return other is not None and self.equal(other)

    __hash__ = hash


    def getOpHooks(self):
        r"""Get the operator hooks of the symbol as a dictionary."""
        return _maude.Symbol_getOpHooks(self)

    def getTermHooks(self):
        r"""Get the term hooks of the symbol as a dictionary."""
        return _maude.Symbol_getTermHooks(self)

# Register Symbol in _maude:
_maude.Symbol_swigregister(Symbol)
class OpDeclaration(object):
    r"""Syntactical operator declaration."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getDomainAndRange(self):
        r"""Get domain and range sorts (range is last)."""
        return _maude.OpDeclaration_getDomainAndRange(self)

    def isConstructor(self):
        r"""Is the declared operator marked as a data constructor?"""
        return _maude.OpDeclaration_isConstructor(self)
    __swig_destroy__ = _maude.delete_OpDeclaration

    def __init__(self):
        _maude.OpDeclaration_swiginit(self, _maude.new_OpDeclaration())

# Register OpDeclaration in _maude:
_maude.OpDeclaration_swigregister(OpDeclaration)
class Rule(ModuleItem):
    r"""A Maude rewrite rule."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.Rule_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.Rule_getRhs(self)

    def getLabel(self):
        r"""Get the label attribute."""
        return _maude.Rule_getLabel(self)

    def isNarrowing(self):
        r"""Whether the rule has the ``narrowing`` attribute."""
        return _maude.Rule_isNarrowing(self)

    def isNonexec(self):
        r"""Whether the rule has the ``nonexec`` attribute."""
        return _maude.Rule_isNonexec(self)

    def hasCondition(self):
        r"""Whether the rule has a condition."""
        return _maude.Rule_hasCondition(self)

    def getCondition(self):
        r"""Get the condition of the rule."""
        return _maude.Rule_getCondition(self)

    def __repr__(self):
        return _maude.Rule___repr__(self)

    def getMetadata(self):
        r"""Get the free text ``metadata`` attribute of this statement."""
        return _maude.Rule_getMetadata(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.Rule_getLineNumber(self)

    def hash(self):
        r"""Get the hash value of the rule."""
        return _maude.Rule_hash(self)

    def equal(self, other):
        r"""Check whether two rule are the same."""
        return _maude.Rule_equal(self, other)
    __swig_destroy__ = _maude.delete_Rule

    __hash__ = hash

    def __eq__(self, other):
    	return other is not None and self.equal(other)


# Register Rule in _maude:
_maude.Rule_swigregister(Rule)
class StrategyExpression(object):
    r"""An expression of the Maude strategy language."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __swig_destroy__ = _maude.delete_StrategyExpression

    def equal(self, other):
        r"""
        Check whether two strategy expression are the same.

        Notes: Not accurate (false negatives).
        """
        return _maude.StrategyExpression_equal(self, other)

    def toLatex(self):
        r"""Obtain the LaTeX representation of this strategy expression."""
        return _maude.StrategyExpression_toLatex(self)

    def __repr__(self):
        return _maude.StrategyExpression___repr__(self)

# Register StrategyExpression in _maude:
_maude.StrategyExpression_swigregister(StrategyExpression)
class RewriteStrategy(ModuleItem):
    r"""A named rewriting strategy."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getDomain(self):
        r"""Get the argument domain."""
        return _maude.RewriteStrategy_getDomain(self)

    def getSubjectSort(self):
        r"""Get the sort to which the strategy is intended to be applied."""
        return _maude.RewriteStrategy_getSubjectSort(self)

    def getDefinitions(self):
        r"""Get the definitions for this strategy."""
        return _maude.RewriteStrategy_getDefinitions(self)

    def arity(self):
        r"""Get the number of arguments of the strategy."""
        return _maude.RewriteStrategy_arity(self)

    def getName(self):
        return _maude.RewriteStrategy_getName(self)

    def __repr__(self):
        return _maude.RewriteStrategy___repr__(self)

    def getMetadata(self):
        r"""Get the free text ``metadata`` attribute of this statement."""
        return _maude.RewriteStrategy_getMetadata(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.RewriteStrategy_getLineNumber(self)

    def hash(self):
        r"""Get the hash value of the strategy."""
        return _maude.RewriteStrategy_hash(self)

    def equal(self, other):
        r"""Check whether two strategy are the same."""
        return _maude.RewriteStrategy_equal(self, other)
    __swig_destroy__ = _maude.delete_RewriteStrategy

    __hash__ = hash

    def __eq__(self, other):
    	return other is not None and self.equal(other)


# Register RewriteStrategy in _maude:
_maude.RewriteStrategy_swigregister(RewriteStrategy)
class StrategyDefinition(ModuleItem):
    r"""A Maude strategy definition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getLhs(self):
        r"""Get the left-hand side of the strategy definition as a term."""
        return _maude.StrategyDefinition_getLhs(self)

    def getRhs(self):
        r"""Get the strategy definition."""
        return _maude.StrategyDefinition_getRhs(self)

    def getStrategy(self):
        r"""Get the named strategy being defined."""
        return _maude.StrategyDefinition_getStrategy(self)

    def isNonexec(self):
        r"""Whether the strategy definition has the ``nonexec`` attribute."""
        return _maude.StrategyDefinition_isNonexec(self)

    def hasCondition(self):
        r"""Whether the strategy definition has a condition."""
        return _maude.StrategyDefinition_hasCondition(self)

    def getCondition(self):
        r"""Get the condition of the strategy definition."""
        return _maude.StrategyDefinition_getCondition(self)

    def getLabel(self):
        r"""Get the label attribute."""
        return _maude.StrategyDefinition_getLabel(self)

    def __repr__(self):
        return _maude.StrategyDefinition___repr__(self)

    def getMetadata(self):
        r"""Get the free text ``metadata`` attribute of this statement."""
        return _maude.StrategyDefinition_getMetadata(self)

    def getLineNumber(self):
        r"""
        Get the line number information for this item as formatted by Maude.

        The format of the string is usually ``filename, line line (module)``
        where the second ``line`` is the integral line number, and ``module`` is
        the module type and name where this item was originally defined. The
        ``filename`` may be an actual quoted filename or some special name
        between angle brackets.
        """
        return _maude.StrategyDefinition_getLineNumber(self)

    def hash(self):
        r"""Get the hash value of the strategy definition."""
        return _maude.StrategyDefinition_hash(self)

    def equal(self, other):
        r"""Check whether two strategy definition are the same."""
        return _maude.StrategyDefinition_equal(self, other)
    __swig_destroy__ = _maude.delete_StrategyDefinition

    __hash__ = hash

    def __eq__(self, other):
    	return other is not None and self.equal(other)


# Register StrategyDefinition in _maude:
_maude.StrategyDefinition_swigregister(StrategyDefinition)
class Token(object):
    r"""A syntactical unit."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def name(self):
        r"""Get the name of the token."""
        return _maude.Token_name(self)

    def __init__(self, name):
        _maude.Token_swiginit(self, _maude.new_Token(name))

    def __repr__(self):
        return _maude.Token___repr__(self)
    __swig_destroy__ = _maude.delete_Token

# Register Token in _maude:
_maude.Token_swigregister(Token)
class ConditionFragment(object):
    r"""A generic condition fragment."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def __repr__(self):
        return _maude.ConditionFragment___repr__(self)
    __swig_destroy__ = _maude.delete_ConditionFragment

# Register ConditionFragment in _maude:
_maude.ConditionFragment_swigregister(ConditionFragment)
class EqualityCondition(ConditionFragment):
    r"""An equality ``t = t'`` condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, lhs, rhs):
        _maude.EqualityCondition_swiginit(self, _maude.new_EqualityCondition(lhs, rhs))

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.EqualityCondition_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.EqualityCondition_getRhs(self)

    def __repr__(self):
        return _maude.EqualityCondition___repr__(self)
    __swig_destroy__ = _maude.delete_EqualityCondition

# Register EqualityCondition in _maude:
_maude.EqualityCondition_swigregister(EqualityCondition)
class AssignmentCondition(ConditionFragment):
    r"""An assignment ``t := t'`` condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, lhs, rhs):
        _maude.AssignmentCondition_swiginit(self, _maude.new_AssignmentCondition(lhs, rhs))

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.AssignmentCondition_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.AssignmentCondition_getRhs(self)

    def __repr__(self):
        return _maude.AssignmentCondition___repr__(self)
    __swig_destroy__ = _maude.delete_AssignmentCondition

# Register AssignmentCondition in _maude:
_maude.AssignmentCondition_swigregister(AssignmentCondition)
class RewriteCondition(ConditionFragment):
    r"""A rewrite ``t => t'`` condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, lhs, rhs):
        _maude.RewriteCondition_swiginit(self, _maude.new_RewriteCondition(lhs, rhs))

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.RewriteCondition_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.RewriteCondition_getRhs(self)

    def __repr__(self):
        return _maude.RewriteCondition___repr__(self)
    __swig_destroy__ = _maude.delete_RewriteCondition

# Register RewriteCondition in _maude:
_maude.RewriteCondition_swigregister(RewriteCondition)
class SortTestCondition(ConditionFragment):
    r"""A sort test ``t : s`` condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, lhs, rhs):
        _maude.SortTestCondition_swiginit(self, _maude.new_SortTestCondition(lhs, rhs))

    def getLhs(self):
        r"""Get the term of the sort test."""
        return _maude.SortTestCondition_getLhs(self)

    def getSort(self):
        r"""Get the sort of the sort test."""
        return _maude.SortTestCondition_getSort(self)

    def __repr__(self):
        return _maude.SortTestCondition___repr__(self)
    __swig_destroy__ = _maude.delete_SortTestCondition

# Register SortTestCondition in _maude:
_maude.SortTestCondition_swigregister(SortTestCondition)
class ModelCheckResult(object):
    r"""Result of LTL model checking."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    holds = property(_maude.ModelCheckResult_holds_get, doc=r"""Whether the property holds.""")
    leadIn = property(_maude.ModelCheckResult_leadIn_get, doc=r"""The counterexample path to the cycle.""")
    cycle = property(_maude.ModelCheckResult_cycle_get, doc=r"""The counterexample cycle.""")
    nrBuchiStates = property(_maude.ModelCheckResult_nrBuchiStates_get, doc=r"""Number of states in the Büchi automaton.""")

    def __init__(self):
        _maude.ModelCheckResult_swiginit(self, _maude.new_ModelCheckResult())
    __swig_destroy__ = _maude.delete_ModelCheckResult

# Register ModelCheckResult in _maude:
_maude.ModelCheckResult_swigregister(ModelCheckResult)
class RewriteGraph(object):
    r"""Complete rewriting graph from an initial state."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, term):
        r"""
        Construct a state transition graph.

        :type term: :py:class:`EasyTerm`
        :param term: Initial state term (it will be reduced).
        """
        _maude.RewriteGraph_swiginit(self, _maude.new_RewriteGraph(term))

    def getStateTerm(self, stateNr):
        r"""
        Get the term of the given state.

        :type stateNr: int
        :param stateNr: A state number.
        """
        return _maude.RewriteGraph_getStateTerm(self, stateNr)

    def getRule(self, origin, dest):
        r"""
        Get a rule that connects two states.

        :type origin: int
        :param origin: Origin state number.
        :type dest: int
        :param dest: Destination state number.

        :rtype: :py:class:`Rule`
        :return: A rule that connects the two states or null if none.
        """
        return _maude.RewriteGraph_getRule(self, origin, dest)

    def getNrRewrites(self):
        r"""
        Get the number of rewrites used to generate this graph,
        including the evaluation of atomic propositions.
        """
        return _maude.RewriteGraph_getNrRewrites(self)

    def modelCheck(self, formula):
        r"""
        Model check a given LTL formula.

        :type formula: :py:class:`EasyTerm`
        :param formula: Term of the ``Formula`` sort.

        :rtype: :py:class:`ModelCheckResult`
        :return: The result of model checking.
        """
        return _maude.RewriteGraph_modelCheck(self, formula)

    def getNrStates(self):
        r"""Get the number of states in the graph."""
        return _maude.RewriteGraph_getNrStates(self)

    def getNextState(self, stateNr, index):
        r"""
        List the successors of a state in the graph.

        :type stateNr: int
        :param stateNr: A state number.
        :type index: int
        :param index: A child index (from zero).

        :rtype: int
        :return: The state number of a successor or -1.
        """
        return _maude.RewriteGraph_getNextState(self, stateNr, index)

    def getStateParent(self, stateNr):
        r"""
        Get the (one) parent of a given state.

        :type stateNr: int
        :param stateNr: A state number.

        :rtype: int
        :return: The state number of the parent or -1.
        """
        return _maude.RewriteGraph_getStateParent(self, stateNr)
    __swig_destroy__ = _maude.delete_RewriteGraph

# Register RewriteGraph in _maude:
_maude.RewriteGraph_swigregister(RewriteGraph)
class StrategyRewriteGraph(object):
    r"""Complete rewriting graph under the control of a strategy from an initial state."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    RULE_APPLICATION = _maude.StrategyRewriteGraph_RULE_APPLICATION
    r"""rule application"""
    OPAQUE_STRATEGY = _maude.StrategyRewriteGraph_OPAQUE_STRATEGY
    r"""opaque strategy"""
    SOLUTION = _maude.StrategyRewriteGraph_SOLUTION
    r"""self-loops for solutions"""

    def __init__(self, *args):
        r"""
        Construct a strategy transition graph.

        :type initial: :py:class:`EasyTerm`
        :param initial: Initial state term (it will be reduced).
        :type strat: :py:class:`StrategyExpression`
        :param strat: A strategy expression.
        :type opaques: std::vector< std::string,std::allocator< std::string > >, optional
        :param opaques: A list of strategy names to be considered opaque.
        :type biased: boolean, optional
        :param biased: Whether the matchrews should be biased.
        """
        _maude.StrategyRewriteGraph_swiginit(self, _maude.new_StrategyRewriteGraph(*args))

    def getStateTerm(self, stateNr):
        r"""
        Get the term of the given state.

        :type stateNr: int
        :param stateNr: A state number.
        """
        return _maude.StrategyRewriteGraph_getStateTerm(self, stateNr)

    def getStateStrategy(self, stateNr):
        r"""
        Get the strategy that will be executed next
        from the given state.

        :type stateNr: int
        :param stateNr: A state number.

        :rtype: :py:class:`StrategyExpression`
        :return: That strategy expression or null if there is
            no pending strategy in the current call or subsearch frame.
        """
        return _maude.StrategyRewriteGraph_getStateStrategy(self, stateNr)

    def getTransition(self, origin, dest):
        r"""
        Get the transition that connects two states (if any).

        :type origin: int
        :param origin: Origin state number.
        :type dest: int
        :param dest: Destination state number.

        :rtype: :py:class:`Transition`
        :return: That transition if exists or a null pointer.
        """
        return _maude.StrategyRewriteGraph_getTransition(self, origin, dest)

    def getNrRewrites(self):
        r"""
        Get the number of rewrites used to generate this graph,
        including the evaluation of atomic propositions.
        """
        return _maude.StrategyRewriteGraph_getNrRewrites(self)

    def modelCheck(self, formula):
        r"""
        Model check a given LTL formula.

        :type formula: :py:class:`EasyTerm`
        :param formula: Term of the ``Formula`` sort.

        :rtype: :py:class:`ModelCheckResult`
        :return: The result of model checking.
        """
        return _maude.StrategyRewriteGraph_modelCheck(self, formula)

    def getNrStates(self):
        r"""Get the number of states in the graph."""
        return _maude.StrategyRewriteGraph_getNrStates(self)

    def getNrRealStates(self):
        r"""Get the number of real (not merged) states in the graph (in linear time)."""
        return _maude.StrategyRewriteGraph_getNrRealStates(self)

    def getNextState(self, stateNr, index):
        r"""
        List the successors of a state in the graph.

        :type stateNr: int
        :param stateNr: A state number.
        :type index: int
        :param index: A child index (from zero).

        :rtype: int
        :return: The state number of a successor or -1.
        """
        return _maude.StrategyRewriteGraph_getNextState(self, stateNr, index)

    def isSolutionState(self, stateNr):
        r"""
        Whether the state is a solution for the strategy.

        :type stateNr: int
        :param stateNr: A state number.
        """
        return _maude.StrategyRewriteGraph_isSolutionState(self, stateNr)
    __swig_destroy__ = _maude.delete_StrategyRewriteGraph

# Register StrategyRewriteGraph in _maude:
_maude.StrategyRewriteGraph_swigregister(StrategyRewriteGraph)
class StrategyGraphTransition(object):
    r"""Structure describing a transition in the graph."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getType(self):
        r"""
        Get the transition type (rule application, opaque strategy,
        or solution).
        """
        return _maude.StrategyGraphTransition_getType(self)

    def getRule(self):
        r"""
        Get the rule applied, in case the transition is a rule application.

        :rtype: :py:class:`Rule`
        :return: That rule or a null pointer if the transition is not
            a rule application.
        """
        return _maude.StrategyGraphTransition_getRule(self)

    def getStrategy(self):
        r"""
        Get the strategy executed, in case of an opaque transition.

        :rtype: :py:class:`RewriteStrategy`
        :return: That strategy or a null pointer if the transition
            is not an opaque strategy.
        """
        return _maude.StrategyGraphTransition_getStrategy(self)

    def __repr__(self):
        return _maude.StrategyGraphTransition___repr__(self)
    __swig_destroy__ = _maude.delete_StrategyGraphTransition

# Register StrategyGraphTransition in _maude:
_maude.StrategyGraphTransition_swigregister(StrategyGraphTransition)
ONE_STEP = _maude.ONE_STEP
r"""->1"""
AT_LEAST_ONE_STEP = _maude.AT_LEAST_ONE_STEP
r"""->+"""
ANY_STEPS = _maude.ANY_STEPS
r"""->*"""
NORMAL_FORM = _maude.NORMAL_FORM
r"""->!"""
BRANCH = _maude.BRANCH
r"""->#"""
PRINT_CONCEAL = _maude.PRINT_CONCEAL
r"""respect concealed argument lists"""
PRINT_FORMAT = _maude.PRINT_FORMAT
r"""respect format attribute"""
PRINT_MIXFIX = _maude.PRINT_MIXFIX
r"""mixfix notation"""
PRINT_WITH_PARENS = _maude.PRINT_WITH_PARENS
r"""maximal parens"""
PRINT_COLOR = _maude.PRINT_COLOR
r"""dag node coloring based on ctor/reduced status"""
PRINT_DISAMBIG_CONST = _maude.PRINT_DISAMBIG_CONST
r"""(c).s for every constant c"""
PRINT_WITH_ALIASES = _maude.PRINT_WITH_ALIASES
r"""for variables"""
PRINT_FLAT = _maude.PRINT_FLAT
r"""for assoc symbols"""
PRINT_NUMBER = _maude.PRINT_NUMBER
r"""for nats & ints"""
PRINT_RAT = _maude.PRINT_RAT
r"""for rats"""
FOLD = _maude.FOLD
r"""Whether to activate folding (``fold`` option or ``fvu-narrow`` command)."""
VFOLD = _maude.VFOLD
r"""Whether to activate variant folding (``vfold`` option)."""
PATH = _maude.PATH
r"""Whether to allow for narrowing trace reconstruction (expensive)."""
DELAY = _maude.DELAY
r"""Whether variant unifiers are filtered before using the first one for narrowing (``delay`` option in the command)."""
FILTER = _maude.FILTER
r"""Whether to activate filtered variant unification (``filter`` option in the command)."""
class Term(object):
    r"""Maude term with its associated operations."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __swig_destroy__ = _maude.delete_Term

    def symbol(self):
        r"""Get the top symbol of this term."""
        return _maude.Term_symbol(self)

    def ground(self):
        r"""Is this term ground?"""
        return _maude.Term_ground(self)

    def equal(self, other):
        r"""
        Compare two terms for equality.

        :type other: :py:class:`EasyTerm`
        :param other: The second term to be compared.
        """
        return _maude.Term_equal(self, other)

    def leq(self, sort):
        r"""
        Check whether the sort of this term is a subtype of the given sort.

        :type sort: :py:class:`Sort`
        :param sort: The pretended supertype.
        """
        return _maude.Term_leq(self, sort)

    def getSort(self):
        r"""Get the sort of this term."""
        return _maude.Term_getSort(self)

    def normalize(self, full=True):
        r"""
        Normalize this term modulo axioms.

        :type full: boolean, optional
        :param full: Whether to normalize in depth.
        """
        return _maude.Term_normalize(self, full)

    def reduce(self):
        r"""
        Reduce this term.

        :rtype: int
        :return: The total number of rewrites.
        """
        return _maude.Term_reduce(self)

    def rewrite(self, bound=-1):
        r"""
        Rewrite a term following the semantics of the ``rewrite`` command.

        :type bound: int, optional
        :param bound: An upper bound on the number of rule rewrites.

        :rtype: int
        :return: The total number of rewrites.
        """
        return _maude.Term_rewrite(self, bound)

    def frewrite(self, bound=-1, gas=-1):
        r"""
        Rewrite a term following the semantics of the ``frewrite`` command.

        :type bound: int, optional
        :param bound: An upper bound on the number of rule rewrites.
        :type gas: int, optional
        :param gas: An upper bound on the number of rule rewrites per position.

        :rtype: int
        :return: The total number of rewrites.
        """
        return _maude.Term_frewrite(self, bound, gas)

    def erewrite(self, bound=-1, gas=-1):
        r"""
        Rewrite a term following the semantics of the ``erewrite`` command.

        :type bound: int, optional
        :param bound: An upper bound on the number of rule rewrites.
        :type gas: int, optional
        :param gas: An upper bound on the number of rule rewrites by position.

        :rtype: std::pair< EasyTerm *,int >
        :return: The result and the total number of rewrites (the original
            term is not modified).
        """
        return _maude.Term_erewrite(self, bound, gas)

    def match(self, *args, **kwargs):
        r"""
        Match this term into a given pattern.

        :type pattern: :py:class:`EasyTerm`
        :param pattern: Pattern term.
        :type condition: Vector< ConditionFragment * >, optional
        :param condition: Equational condition that solutions must satisfy.
        :type withExtension: boolean, optional
        :param withExtension: Whether the matching should be done with extension modulo axioms
            (deprecated, use ``maxDepth=0`` instead).
        :type minDepth: int, optional
        :param minDepth: Minimum matching depth.
        :type maxDepth: int, optional
        :param maxDepth: Maximum matching depth (``-1`` to match on top without extension, ``0``
            to match on top with extension, ``UNBOUNDED`` to match anywhere, or any intermediate value).

        :rtype: :py:class:`MatchSearchState`
        :return: An object to iterate through matches.
        """
        return _maude.Term_match(self, *args, **kwargs)

    def srewrite(self, expr, depth=False):
        r"""
        Rewrite a term following a strategy.

        :type expr: :py:class:`StrategyExpression`
        :param expr: A strategy expression.
        :type depth: boolean, optional
        :param depth: Whether to perform a depth-first search. By default, a fair search is used.

        :rtype: :py:class:`StrategicSearch`
        :return: An object to iterate through strategy solutions.
        """
        return _maude.Term_srewrite(self, expr, depth)

    def search(self, type, target, strategy=None, condition=None, depth=-1):
    	r"""
    	Search states that match into a given pattern and satisfy a given condition
    	by rewriting from this term.

    	:type type: int
    	:param type: Type of search (number of steps).
    	:type target: :py:class:`Term`
    	:param target: Pattern term.
    	:type strategy: :py:class:`StrategyExpression`, optional
    	:param strategy: Strategy to control the search.
    	:type condition: :py:class:`Condition` or sequence of condition fragments, optional
    	:param condition: Condition that solutions must satisfy.
    	:type depth: int, optional
    	:param depth: Depth bound

    	:rtype: either :py:class:`StrategySequenceSearch` if a strategy is provided or :py:class:`RewriteSequenceSearch`
    	:return: An object to iterate through matches.
    	"""
    # Fix the case where a condition and not a strategy has been specified
    	if strategy is not None and not isinstance(strategy, StrategyExpression):
    		if condition is not None:
    			depth = condition
    		condition, strategy = strategy, None

    	if condition is None:
    		condition = _maude.cvar.Term_NO_CONDITION

    	if strategy is not None:
    		return _maude.Term__search(self, type, target, strategy, condition, depth)
    	else:
    		return _maude.Term_search(self, type, target, condition, depth)





    def get_variants(self, *args, **kwargs):
        r"""
        Compute the most general variants of this term.

        :type irredundant: boolean, optional
        :param irredundant: Whether to obtain irredundant variants
            (for theories with the finite variant property).
        :type irreducible: std::vector< EasyTerm *,std::allocator< EasyTerm * > >, optional
        :param irreducible: Irreducible terms constraint.

        :rtype: :py:class:`VariantSearch`
        :return: An object to iterate through variants.
        """
        return _maude.Term_get_variants(self, *args, **kwargs)

    def vu_narrow(self, type, target, depth=-1, flags=0):
        r"""
        Narrowing-based search of terms that unify with the given target.

        :type type: int
        :param type: Type of the search (number of steps).
        :type target: :py:class:`EasyTerm`
        :param target: The pattern that has to be reached.
        :type depth: int, optional
        :param depth: Depth bound (``-1`` for unbounded).
        :type flags: int, optional
        :param flags: Narrowing search flags (``fold``, ``vfold``, ``path``, ``delay``, or ``filter`` flag).

        :rtype: :py:class:`NarrowingSequenceSearch3`
        :return: An object to iterate through solutions.
        """
        return _maude.Term_vu_narrow(self, type, target, depth, flags)

    def apply(self, *args, **kwargs):
        r"""
        Apply any rule with the given label.

        :type label: string
        :param label: Rule label (or null for any executable rule).
        :type substitution: :py:class:`EasySubstitution`, optional
        :param substitution: Initial substitution that will be applied on the rule before matching.
        :type minDepth: int, optional
        :param minDepth: Minimum matching depth.
        :type maxDepth: int, optional
        :param maxDepth: Maximum matching depth.

        :rtype: :py:class:`RewriteSearchState`
        :return: An object to iterate through the rewritten terms.
        """
        return _maude.Term_apply(self, *args, **kwargs)

    def arguments(self, normalize=True):
        r"""
        Iterate over the arguments of this term.

        :type normalize: boolean, optional
        :param normalize: Whether to normalize before iterating over its arguments.
        """
        return _maude.Term_arguments(self, normalize)

    def toFloat(self):
        r"""
        Get the floating-point number represented by the given term or
        zero otherwise.
        """
        return _maude.Term_toFloat(self)

    def toInt(self):
        r"""
        Get the integer number represented by the given term or
        zero otherwise.
        """
        return _maude.Term_toInt(self)

    def isVariable(self):
        r"""Get whether the term is a variable."""
        return _maude.Term_isVariable(self)

    def getVarName(self):
        r"""
        Get the name of the variable if the current term is a variable or
        a null value otherwise.
        """
        return _maude.Term_getVarName(self)

    def getIterExponent(self):
        r"""Get the exponent of an iterable symbol or zero otherwise."""
        return _maude.Term_getIterExponent(self)

    def hash(self):
        r"""Get the hash value of the term."""
        return _maude.Term_hash(self)

    def copy(self):
        r"""Get a copy of this term."""
        return _maude.Term_copy(self)

    def prettyPrint(self, flags):
        r"""
        Pretty prints this term.

        :type flags: int
        :param flags: Flags that affect the term output.
        """
        return _maude.Term_prettyPrint(self, flags)

    def toLatex(self):
        r"""Obtain the LaTeX representation of this term."""
        return _maude.Term_toLatex(self)

    def __repr__(self):
        return _maude.Term___repr__(self)

    def __eq__(self, other):
    	return other is not None and self.equal(other)

    __float__ = toFloat
    __int__ = toInt
    __hash__ = hash


# Register Term in _maude:
_maude.Term_swigregister(Term)
cvar = _maude.cvar
Term.NO_CONDITION = _maude.cvar.Term_NO_CONDITION

class StrategicSearch(object):
    r"""An iterator through the solutions of a strategy search."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getRewriteCount(self):
        r"""Get the number of rewrites until the solution has been found."""
        return _maude.StrategicSearch_getRewriteCount(self)

    def __next(self):
        r"""
        Get the next solution for the strategic search.

        :rtype: :py:class:`EasyTerm`
        :return: That solution or null pointer if the end has
            been reached.
        """
        return _maude.StrategicSearch___next(self)
    __swig_destroy__ = _maude.delete_StrategicSearch

    def __iter__(self):
    	return self

    def __next__(self):
    	v = self.__next()
    	if v is None:
    		raise StopIteration
    	return v, self.getRewriteCount()


# Register StrategicSearch in _maude:
_maude.StrategicSearch_swigregister(StrategicSearch)
class Substitution(object):
    r"""Substitution (mapping from variables to terms)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, vars, values):
        r"""
        Create a substitution with the given variables and values.

        :type vars: std::vector< EasyTerm *,std::allocator< EasyTerm * > >
        :param vars: Variables in the substitution.
        :type values: std::vector< EasyTerm *,std::allocator< EasyTerm * > >
        :param values: values Values for these variables in the substitution.
        """
        _maude.Substitution_swiginit(self, _maude.new_Substitution(vars, values))

    def size(self):
        r"""Get the number of variables in the substitution."""
        return _maude.Substitution_size(self)

    def value(self, variable):
        r"""
        Get the value of a given variable.

        :type variable: :py:class:`EasyTerm`
        :param variable: The variable whose value is looked up.
        """
        return _maude.Substitution_value(self, variable)

    def matchedPortion(self):
        r"""
        Get the matched portion when matching with extension.

        :rtype: :py:class:`EasyTerm`
        :return: The matched portion or null if the
            whole term matched.
        """
        return _maude.Substitution_matchedPortion(self)

    def find(self, name, sort=None):
        r"""
        Find the value of a given variable by name.

        :type name: string
        :param name: Variable name (without sort).
        :type sort: :py:class:`Sort`, optional
        :param sort: Sort of the variable (optional).

        :rtype: :py:class:`EasyTerm`
        :return: The value of the variable or null if not found.
            If the sort of the variable is not given, multiple results
            are possible.
        """
        return _maude.Substitution_find(self, name, sort)

    def instantiate(self, term):
        r"""
        Instantiate a term with this substitution.

        :type term: :py:class:`EasyTerm`
        :param term: The term to be instantiated.

        :rtype: :py:class:`EasyTerm`
        :return: The instantiated term.
        """
        return _maude.Substitution_instantiate(self, term)

    def __iter__(self):
        r"""Get an iterator to the substitution assignments."""
        return _maude.Substitution___iter__(self)

    _raw_init = __init__

    def __init__(self, *args):
    	if len(args) == 2:
    		self._raw_init(*args)
    	elif len(args) == 1 and isinstance(args[0], dict):
    		self._raw_init(list(args[0].keys()), list(args[0].values()))
    	else:
    		raise TypeError('__init__() takes either a dictionary or two sequences of Term.')

    def __getitem__(self, variable):
    	if isinstance(variable, str):
    		return self.find(variable)
    	else:
    		return self.value(variable)

    __len__ = size

    def __repr__(self):
    	return 'Subtitution with {} variables'.format(self.size())

    def __str__(self):
    	if len(self) == 0:
    		return 'empty'

    	return ', '.join(['{}={}'.format(variable, value) for variable, value in self])

    __swig_destroy__ = _maude.delete_Substitution

# Register Substitution in _maude:
_maude.Substitution_swigregister(Substitution)
class SubstitutionIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def nextAssignment(self):
        return _maude.SubstitutionIterator_nextAssignment(self)

    def getVariable(self):
        return _maude.SubstitutionIterator_getVariable(self)

    def getValue(self):
        return _maude.SubstitutionIterator_getValue(self)

    def __next__(self):
    	variable, value = self.getVariable(), self.getValue()

    	if variable is None:
    		raise StopIteration

    	self.nextAssignment()

    	return variable, value

    def __iter__(self):
    	return self

    __swig_destroy__ = _maude.delete_SubstitutionIterator

# Register SubstitutionIterator in _maude:
_maude.SubstitutionIterator_swigregister(SubstitutionIterator)
class MatchSearchState(object):
    r"""An iterator through the matching a term into a pattern."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __next(self):
        r"""
        Get the next match.

        :rtype: :py:class:`EasySubstitution`
        :return: A matching substitution or null pointer if
            there is no more matches.
        """
        return _maude.MatchSearchState___next(self)

    def fillContext(self, term):
        r"""
        Get the context of the match filled with the given term.

        :type term: :py:class:`EasyTerm`
        :param term: Term to fill the context.

        :rtype: :py:class:`EasyTerm`
        :return: The original term with the matched subterm replaced by the given term.
        """
        return _maude.MatchSearchState_fillContext(self, term)
    __swig_destroy__ = _maude.delete_MatchSearchState

    def __iter__(self):
    	return self

    def __next__(self):
    	nxt = self.__next()
    	if nxt is None:
    		raise StopIteration
    	return nxt, lambda t: self.fillContext(t)


# Register MatchSearchState in _maude:
_maude.MatchSearchState_swigregister(MatchSearchState)
class RewriteSequenceSearch(object):
    r"""An iterator through the solutions of a search."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getRewriteCount(self):
        r"""Get the number of rewrites until this term has been found."""
        return _maude.RewriteSequenceSearch_getRewriteCount(self)

    def getSubstitution(self):
        r"""Get the matching substitution of the solution into the pattern."""
        return _maude.RewriteSequenceSearch_getSubstitution(self)

    def getRule(self, stateNr=-1):
        r"""
        Get the rule leading to the given state.

        :type stateNr: int, optional
        :param stateNr: The number of a state in the search graph
            or -1 for the current one.
        """
        return _maude.RewriteSequenceSearch_getRule(self, stateNr)

    def getStateTerm(self, stateNr):
        r"""
        Get the term of a given state.

        :type stateNr: int
        :param stateNr: The number of a state in the search graph.
        """
        return _maude.RewriteSequenceSearch_getStateTerm(self, stateNr)

    def __next(self):
        r"""
        Get the next match.

        :rtype: :py:class:`EasyTerm`
        :return: A term or a null pointer if there is no more matches.
        """
        return _maude.RewriteSequenceSearch___next(self)

    def getStateNr(self):
        r"""
        Get an internal state number that allows reconstructing
        the path to this term.
        """
        return _maude.RewriteSequenceSearch_getStateNr(self)

    def getStateParent(self, stateNr):
        r"""
        Get the parent state.

        :type stateNr: int
        :param stateNr: The number of a state in the search graph.

        :rtype: int
        :return: The number of the parent or -1 for the root.
        """
        return _maude.RewriteSequenceSearch_getStateParent(self, stateNr)
    __swig_destroy__ = _maude.delete_RewriteSequenceSearch

    def __iter__(self):
    	return self

    def pathTo(self, stateNr):
    	r"""
    	Get the path from the initial to the given state.

    	:type stateNr: int
    	:param stateNr: State index.

    	:rtype: list of :py:class:`Term` and :py:class:`Rule`
    	:return: A list interleaving terms and rules that connect
    	  them from the initial to the given state.
    	"""
    	parent = self.getStateParent(stateNr)

    	if parent < 0:
    		path = [self.getStateTerm(stateNr)]
    	else:
    		path = self.pathTo(parent)

    		path.append(self.getRule(stateNr))
    		path.append(self.getStateTerm(stateNr))

    	return path

    def __next__(self):
    	term = self.__next()
    	if term is None:
    		raise StopIteration
    	return term, self.getSubstitution(), lambda: self.pathTo(self.getStateNr()), self.getRewriteCount()


# Register RewriteSequenceSearch in _maude:
_maude.RewriteSequenceSearch_swigregister(RewriteSequenceSearch)
class StrategySequenceSearch(object):
    r"""An iterator through the solutions of a strategy-controlled search."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getRewriteCount(self):
        r"""Get the number of rewrites until this term has been found."""
        return _maude.StrategySequenceSearch_getRewriteCount(self)

    def getSubstitution(self):
        r"""Get the matching substitution of the solution into the pattern."""
        return _maude.StrategySequenceSearch_getSubstitution(self)

    def getTransition(self, stateNr=-1):
        r"""
        Get the transition leading to the given state.

        :type stateNr: int, optional
        :param stateNr: The number of a state in the search graph
            or -1 for the current one.

        :rtype: :py:class:`Transition`
        :return: The transition between the parent of the given state and the
            state itself.
        """
        return _maude.StrategySequenceSearch_getTransition(self, stateNr)

    def getStateTerm(self, stateNr):
        r"""
        Get the term of a given state.

        :type stateNr: int
        :param stateNr: The number of a state in the search graph.
        """
        return _maude.StrategySequenceSearch_getStateTerm(self, stateNr)

    def getStrategyContinuation(self, stateNr=-1):
        r"""
        Get the next strategy to be executed from the given state.

        :type stateNr: int, optional
        :param stateNr: The number of a state in the search graph
            or -1 for the current one.
        """
        return _maude.StrategySequenceSearch_getStrategyContinuation(self, stateNr)

    def __next(self):
        r"""
        Get the next match.

        :rtype: :py:class:`EasyTerm`
        :return: A term or a null pointer if there is no more matches.
        """
        return _maude.StrategySequenceSearch___next(self)

    def getStateNr(self):
        r"""
        Get an internal state number that allows reconstructing
        the path to this term.
        """
        return _maude.StrategySequenceSearch_getStateNr(self)

    def getStateParent(self, stateNr):
        r"""
        Get the parent state.

        :type stateNr: int
        :param stateNr: The number of a state in the search graph.

        :rtype: int
        :return: The number of the parent or -1 for the root.
        """
        return _maude.StrategySequenceSearch_getStateParent(self, stateNr)
    __swig_destroy__ = _maude.delete_StrategySequenceSearch

    def __iter__(self):
    	return self

    def pathTo(self, stateNr):
    	r"""
    	Get the path from the initial to the given state.

    	:type stateNr: int
    	:param stateNr: State index.

    	:rtype: list of :py:class:`Term` and :py:class:`StrategyGraphTransition`
    	:return: A list interleaving terms and transitions that connect
    	  them from the initial to the given state.
    	"""
    	parent = self.getStateParent(stateNr)

    	if parent < 0:
    		path = [self.getStateTerm(stateNr)]
    	else:
    		path = self.pathTo(parent)

    		path.append(self.getTransition(stateNr))
    		path.append(self.getStateTerm(stateNr))

    	return path

    def __next__(self):
    	term = self.__next()
    	if term is None:
    		raise StopIteration
    	return (term, self.getSubstitution(), lambda: self.pathTo(self.getStateNr()),
    	        self.getStrategyContinuation(), self.getRewriteCount())


# Register StrategySequenceSearch in _maude:
_maude.StrategySequenceSearch_swigregister(StrategySequenceSearch)
class NarrowingSequenceSearch(object):
    r"""An iterator through narrowing solutions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def isIncomplete(self):
        r"""Whether some solutions may have been missed due to incomplete unification algorithms."""
        return _maude.NarrowingSequenceSearch_isIncomplete(self)

    def getStateParent(self, stateNr):
        r"""
        Get the parent state.

        :type stateNr: int
        :param stateNr: The number of state in the search graph.

        :rtype: int
        :return: The number of the parent or -1 for the root.
        """
        return _maude.NarrowingSequenceSearch_getStateParent(self, stateNr)

    def __next(self):
        r"""Get the next solution of the narrowing search."""
        return _maude.NarrowingSequenceSearch___next(self)

    def getSubstitution(self):
        r"""Get the accumulated substitution."""
        return _maude.NarrowingSequenceSearch_getSubstitution(self)

    def getUnifier(self):
        r"""Get the variant unifier."""
        return _maude.NarrowingSequenceSearch_getUnifier(self)

    def getFrontierStates(self):
        r"""Get the frontier states."""
        return _maude.NarrowingSequenceSearch_getFrontierStates(self)

    def getMostGeneralStates(self):
        r"""Get the most general states."""
        return _maude.NarrowingSequenceSearch_getMostGeneralStates(self)
    __swig_destroy__ = _maude.delete_NarrowingSequenceSearch

    def __iter__(self):
    	return self

    def __next__(self):
    	nxt = self.__next()
    	if nxt is None:
    		raise StopIteration
    	return nxt, self.getSubstitution(), self.getUnifier()


# Register NarrowingSequenceSearch in _maude:
_maude.NarrowingSequenceSearch_swigregister(NarrowingSequenceSearch)
class VariantSearch(object):
    r"""An iterator through variants."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def isIncomplete(self):
        r"""Whether some variants may have been missed due to incomplete unification algorithms."""
        return _maude.VariantSearch_isIncomplete(self)

    def __next(self):
        r"""
        Get the next variant.

        :rtype: std::pair< EasyTerm *,EasySubstitution * >
        :return: The variant term or null if there is no more.
        """
        return _maude.VariantSearch___next(self)
    __swig_destroy__ = _maude.delete_VariantSearch

    def __iter__(self):
    	return self

    def __next__(self):
    	nxt = self.__next()
    	if nxt is None:
    		raise StopIteration
    	return nxt


# Register VariantSearch in _maude:
_maude.VariantSearch_swigregister(VariantSearch)
class RewriteSearchState(object):
    r"""An iterator through rewriting solutions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getRule(self):
        r"""Get the applied rule."""
        return _maude.RewriteSearchState_getRule(self)

    def __next(self):
        r"""Get the next solution of the rewriting search."""
        return _maude.RewriteSearchState___next(self)

    def getSubstitution(self):
        r"""Get the matching substitution."""
        return _maude.RewriteSearchState_getSubstitution(self)

    def fillContext(self, term):
        r"""
        Get the context of the match filled with the given term.

        :type term: :py:class:`EasyTerm`
        :param term: Term to fill the context.

        :rtype: :py:class:`EasyTerm`
        :return: The original term with the matched subterm replaced by the given term.
        """
        return _maude.RewriteSearchState_fillContext(self, term)
    __swig_destroy__ = _maude.delete_RewriteSearchState

    def __iter__(self):
    	return self

    def __next__(self):
    	nxt = self.__next()
    	if nxt is None:
    		raise StopIteration
    	return nxt, self.getSubstitution(), lambda t: self.fillContext(t), self.getRule()


# Register RewriteSearchState in _maude:
_maude.RewriteSearchState_swigregister(RewriteSearchState)
class ArgumentIterator(object):
    r"""An iterator through the arguments of a term."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def valid(self):
        r"""Is this iterator pointing to a valid argument?"""
        return _maude.ArgumentIterator_valid(self)

    def __next(self):
        r"""Advance the iterator to the next argument."""
        return _maude.ArgumentIterator___next(self)

    def argument(self):
        r"""Get the argument pointed by this iterator."""
        return _maude.ArgumentIterator_argument(self)

    def __iter__(self):
    	return self

    def __next__(self):
    	if not self.valid():
    		raise StopIteration
    	term = self.argument()
    	self.__next()
    	return term

    __swig_destroy__ = _maude.delete_ArgumentIterator

# Register ArgumentIterator in _maude:
_maude.ArgumentIterator_swigregister(ArgumentIterator)
class Module(object):
    r"""A Maude module."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __swig_destroy__ = _maude.delete_Module
    FUNCTIONAL_MODULE = _maude.Module_FUNCTIONAL_MODULE
    r"""Functional module (``fmod``)"""
    SYSTEM_MODULE = _maude.Module_SYSTEM_MODULE
    r"""System module (``mod``)"""
    STRATEGY_MODULE = _maude.Module_STRATEGY_MODULE
    r"""Strategy module (``smod``)"""
    FUNCTIONAL_THEORY = _maude.Module_FUNCTIONAL_THEORY
    r"""Functional theory (``fth``)"""
    SYSTEM_THEORY = _maude.Module_SYSTEM_THEORY
    r"""System theory (``th``)"""
    STRATEGY_THEORY = _maude.Module_STRATEGY_THEORY
    r"""Strategy theory (``sth``)"""
    OBJECT_ORIENTED_MODULE = _maude.Module_OBJECT_ORIENTED_MODULE
    r"""Object-oriented module (``omod``)"""
    OBJECT_ORIENTED_THEORY = _maude.Module_OBJECT_ORIENTED_THEORY
    r"""Object-oriented theory (``oth``)"""

    def getModuleType(self):
        r"""
        Get the module type.

        This allows distinguishing modules from theories, and the
        functional, system and strategy variants within them.
        """
        return _maude.Module_getModuleType(self)

    def getSorts(self):
        r"""Get the sorts declared in the module."""
        return _maude.Module_getSorts(self)

    def getSymbols(self):
        r"""Get the symbols declared in the module."""
        return _maude.Module_getSymbols(self)

    def getKinds(self):
        r"""Get the kinds defined in the module."""
        return _maude.Module_getKinds(self)

    def getMembershipAxioms(self):
        r"""Get the membership axioms defined in the module."""
        return _maude.Module_getMembershipAxioms(self)

    def getEquations(self):
        r"""Get the equations defined in the module."""
        return _maude.Module_getEquations(self)

    def getRules(self):
        r"""Get the rules defined in the module."""
        return _maude.Module_getRules(self)

    def getStrategies(self):
        r"""Get the strategies declared in the module."""
        return _maude.Module_getStrategies(self)

    def getStrategyDefinitions(self):
        r"""Get the strategy definitions defined in the module."""
        return _maude.Module_getStrategyDefinitions(self)

    def getNrParameters(self):
        r"""Number of parameters of the parameterized module."""
        return _maude.Module_getNrParameters(self)

    def hasFreeParameters(self):
        r"""Is this a parameterized module with free parameters?"""
        return _maude.Module_hasFreeParameters(self)

    def getNrImportedSorts(self):
        r"""Number of sorts imported from other modules or parameters."""
        return _maude.Module_getNrImportedSorts(self)

    def getNrImportedSymbols(self):
        r"""Number of symbols imported from other modules or parameters."""
        return _maude.Module_getNrImportedSymbols(self)

    def getNrImportedStrategies(self):
        r"""Number of strategies imported from other modules or parameters."""
        return _maude.Module_getNrImportedStrategies(self)

    def getNrOriginalEquations(self):
        r"""Number of equations from this module."""
        return _maude.Module_getNrOriginalEquations(self)

    def getNrOriginalRules(self):
        r"""Number of rules from this module."""
        return _maude.Module_getNrOriginalRules(self)

    def getNrOriginalStrategyDefinitions(self):
        r"""Number of strategy definitions from this module."""
        return _maude.Module_getNrOriginalStrategyDefinitions(self)

    def getParameterTheory(self, index):
        r"""Get the theory of the given parameter."""
        return _maude.Module_getParameterTheory(self, index)

    def getParameterName(self, index):
        r"""
        Get the name of a module parameter.

        :type index: int
        :param index: Index of the parameter.
        """
        return _maude.Module_getParameterName(self, index)

    def findSort(self, name):
        r"""
        Finds a sort by its name in the module.

        :type name: string
        :param name: The name of the sort.

        :rtype: :py:class:`Sort`
        :return: The sort or null if it does not exist.
        """
        return _maude.Module_findSort(self, name)

    def findSymbol(self, name, domainKinds, rangeKind):
        r"""
        Find a symbol by its name and signature in the module.

        :type name: string
        :param name: The name of the sort.
        :type domainKinds: Vector< ConnectedComponent * >
        :param domainKinds: Kinds of the symbol domain.
        :type rangeKind: :py:class:`ConnectedComponent`
        :param rangeKind: Range kind of the symbol.

        :rtype: :py:class:`Symbol`
        :return: The symbol or null if it does not exist.
        """
        return _maude.Module_findSymbol(self, name, domainKinds, rangeKind)

    def parseTerm(self, *args):
        r"""
        *Overload 1:*

        Parse a term.

        :type bubble: std::vector< Token,std::allocator< Token > >
        :param bubble: Tokenized term.
        :type kind: :py:class:`ConnectedComponent`, optional
        :param kind: Restrict parsing to terms of the given kind.

        |

        *Overload 2:*

        Parse a term.

        :type term_str: string
        :param term_str: A term represented as a string.
        :type kind: :py:class:`ConnectedComponent`, optional
        :param kind: Restrict parsing to terms of the given kind.
        :type vars: std::vector< EasyTerm *,std::allocator< EasyTerm * > >, optional
        :param vars: Variables that may appear without explicit type
            annotation in the strategy.

        |

        *Overload 3:*

        Parse a term.

        :type term_str: string
        :param term_str: A term represented as a string.
        :type kind: :py:class:`ConnectedComponent`, optional
        :param kind: Restrict parsing to terms of the given kind.
        :param vars: Variables that may appear without explicit type
            annotation in the strategy.

        |

        *Overload 4:*

        Parse a term.

        :type term_str: string
        :param term_str: A term represented as a string.
        :param kind: Restrict parsing to terms of the given kind.
        :param vars: Variables that may appear without explicit type
            annotation in the strategy.
        """
        return _maude.Module_parseTerm(self, *args)

    def parseStrategy(self, *args, **kwargs):
        r"""
        Parse a strategy expression.

        :param term_str: A strategy represented as a string.
        :type vars: std::vector< EasyTerm *,std::allocator< EasyTerm * > >, optional
        :param vars: Variables that may appear without explicit type
            annotation in the strategy.
        """
        return _maude.Module_parseStrategy(self, *args, **kwargs)

    def downTerm(self, term):
        r"""
        Get a term in this module from its metarepresentation
        in (possibly) another module.

        :type term: :py:class:`EasyTerm`
        :param term: The metarepresentation of a term, that is,
            a valid element of the ``Term`` sort in ``META-TERM``.
            This term must belong to a module where the ``META-LEVEL``
            module is included. The term will be reduced.

        :rtype: :py:class:`EasyTerm`
        :return: The term or null if the metarepresentation was
            not valid.
        """
        return _maude.Module_downTerm(self, term)

    def downStrategy(self, term):
        r"""
        Get a strategy expression in this module from its
        metarepresentation in (possibly) another module.

        :type term: :py:class:`EasyTerm`
        :param term: The metarepresentation of a strategy, that is,
            a valid element of the ``Strategy`` sort in ``META-STRATEGY``.
            This term must belong to a module where the ``META-LEVEL``
            module is included. The term will be reduced.

        :rtype: :py:class:`StrategyExpression`
        :return: The strategy expression or null if the
            metarepresentation was not valid.
        """
        return _maude.Module_downStrategy(self, term)

    def upTerm(self, term):
        r"""
        Get the metarepresentation in this module of a term
        in (possibly) another module. This module must contain
        ``META-LEVEL``.

        :type term: :py:class:`EasyTerm`
        :param term: Any term.

        :rtype: :py:class:`EasyTerm`
        :return: The metarepresentation term or null.
        """
        return _maude.Module_upTerm(self, term)

    def upStrategy(self, expr):
        r"""
        Get the metarepresentation in this module of a strategy
        expression in (possibly) another module. This module must
        contain ``META-LEVEL``.

        :type expr: :py:class:`StrategyExpression`
        :param expr: Any strategy expression.

        :rtype: :py:class:`EasyTerm`
        :return: The metarepresented strategy or null.
        """
        return _maude.Module_upStrategy(self, expr)

    def unify(self, problem, irredundant=False):
        r"""
        Solves the given unification problem.

        :type problem: std::vector< std::pair< EasyTerm *,EasyTerm * >,std::allocator< std::pair< EasyTerm *,EasyTerm * > > >
        :param problem: A list of pairs of terms to be unified.
        :type irredundant: boolean, optional
        :param irredundant: Whether to compute a minimal set of unifiers.

        :rtype: :py:class:`UnificationProblem`
        :return: An object to iterate through unifiers.
        """
        return _maude.Module_unify(self, problem, irredundant)

    def variant_unify(self, *args, **kwargs):
        r"""
        Solves the given unification problem using variants.

        :type problem: std::vector< std::pair< EasyTerm *,EasyTerm * >,std::allocator< std::pair< EasyTerm *,EasyTerm * > > >
        :param problem: A list of pairs of terms to be unified.
        :type irreducible: std::vector< EasyTerm *,std::allocator< EasyTerm * > >, optional
        :param irreducible: Irreducible terms.
        :type filtered: boolean, optional
        :param filtered: Whether to compute a minimal set of unifiers.

        :rtype: :py:class:`VariantUnifierSearch`
        :return: An object to iterate through unifiers.
        """
        return _maude.Module_variant_unify(self, *args, **kwargs)

    def variant_match(self, *args):
        r"""
        Computes a complete set of order-sorted matches modulo the equations
        declared with the variant attribute (which must satisfy the finite
        variant property) plus the (supported) equational axioms in the
        given module.

        :type problem: std::vector< std::pair< EasyTerm *,EasyTerm * >,std::allocator< std::pair< EasyTerm *,EasyTerm * > > >
        :param problem: A list of pairs of terms to be matched.
        :type irreducible: std::vector< EasyTerm *,std::allocator< EasyTerm * > >, optional
        :param irreducible: Irreducible terms.

        :rtype: :py:class:`VariantUnifierSearch`
        :return: An object to iterate through unifiers.
        """
        return _maude.Module_variant_match(self, *args)

    def vu_narrow(self, subject, type, target, depth=-1, flags=0):
        r"""
        Narrowing-based search of terms that unify with the given target
        with multiple initial states.

        :type subject: std::vector< EasyTerm *,std::allocator< EasyTerm * > >
        :param subject: Subject terms where to start the search.
        :type type: int
        :param type: Type of the search (number of steps).
        :type target: :py:class:`EasyTerm`
        :param target: Term that found states must unify with.
        :type depth: int, optional
        :param depth: Depth bound (``-1`` for unbounded)
        :type flags: int, optional
        :param flags: Narrowing search flags (``fold``, ``vfold``, ``path``, ``delay``, or ``filter`` flag).
        """
        return _maude.Module_vu_narrow(self, subject, type, target, depth, flags)

    def toLatex(self, all=False):
        r"""
        Obtain the LaTeX representation of this module.

        :type all: boolean, optional
        :param all: Whether to show all statements by transitivity.
        """
        return _maude.Module_toLatex(self, all)

    def __repr__(self):
        return _maude.Module___repr__(self)

# Register Module in _maude:
_maude.Module_swigregister(Module)
class UnificationProblem(object):
    r"""An iterator through unifiers."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __next(self):
        r"""
        Get the next unifier.

        :rtype: :py:class:`EasySubstitution`
        :return: That unifier or null pointer if there is no more.
        """
        return _maude.UnificationProblem___next(self)
    __swig_destroy__ = _maude.delete_UnificationProblem

    def __iter__(self):
    	return self

    def __next__(self):
    	nxt = self.__next()
    	if nxt is None:
    		raise StopIteration
    	return nxt


# Register UnificationProblem in _maude:
_maude.UnificationProblem_swigregister(UnificationProblem)
class VariantUnifierSearch(object):
    r"""An iterator through unifiers or matchers for variant unification or matching."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def isIncomplete(self):
        r"""Whether some unifiers may have been missed due to incomplete unification algorithms."""
        return _maude.VariantUnifierSearch_isIncomplete(self)

    def filteringIncomplete(self):
        r"""Whether filetering was incomplete due to incomplete unification algorithms."""
        return _maude.VariantUnifierSearch_filteringIncomplete(self)

    def __next(self):
        r"""
        Get the next unifier.

        :rtype: :py:class:`EasySubstitution`
        :return: The next unifier or null if there is no more.
        """
        return _maude.VariantUnifierSearch___next(self)
    __swig_destroy__ = _maude.delete_VariantUnifierSearch

    def __iter__(self):
    	return self

    def __next__(self):
    	nxt = self.__next()
    	if nxt is None:
    		raise StopIteration
    	return nxt


# Register VariantUnifierSearch in _maude:
_maude.VariantUnifierSearch_swigregister(VariantUnifierSearch)
class View(object):
    r"""A Maude view."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getFromTheory(self):
        r"""Get the *from* theory of the view."""
        return _maude.View_getFromTheory(self)

    def getToModule(self):
        r"""Get the *to* module of the view."""
        return _maude.View_getToModule(self)

    def toLatex(self, all=False):
        r"""
        Get the LaTeX representation of the view.

        :type all: boolean, optional
        :param all: Whether to show the processed view.
        """
        return _maude.View_toLatex(self, all)

    def __repr__(self):
        return _maude.View___repr__(self)
    __swig_destroy__ = _maude.delete_View

# Register View in _maude:
_maude.View_swigregister(View)
class HookData(object):
    r"""Data associated to a hook and passed to its callback."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getData(self):
        r"""Get the data associated to the hook."""
        return _maude.HookData_getData(self)

    def getSymbol(self, name):
        r"""Get the symbol associated to the hook with the given name."""
        return _maude.HookData_getSymbol(self, name)

    def getTerm(self, name):
        r"""Get the term associated to the hook with the given name."""
        return _maude.HookData_getTerm(self, name)
    __swig_destroy__ = _maude.delete_HookData

# Register HookData in _maude:
_maude.HookData_swigregister(HookData)
class Hook(object):
    r"""Special operators defined on the external language."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def run(self, term, data):
        r"""
        Method called by the hook.

        :type term: :py:class:`EasyTerm`
        :param term: The term being reduced or rewritten.
        :type data: :py:class:`HookData`
        :param data: Data associated to the hook.

        :rtype: :py:class:`EasyTerm`
        :return: The reduced or rewritten term, or a null value in case
            no rewrite is possible.
        """
        return _maude.Hook_run(self, term, data)
    __swig_destroy__ = _maude.delete_Hook

    def __init__(self):
        if self.__class__ == Hook:
            _self = None
        else:
            _self = self
        _maude.Hook_swiginit(self, _maude.new_Hook(_self, ))
    def __disown__(self):
        self.this.disown()
        _maude.disown_Hook(self)
        return weakref.proxy(self)

# Register Hook in _maude:
_maude.Hook_swigregister(Hook)

def connectEqHook(name, hook):
    r"""
    Connect a callback for the reduction of a special operator declared with
    the ``SpecialHubSymbol`` id-hook.

    :type name: string
    :param name: The name of the operator to be bound to this callback.
          In case the id-hook contains arguments, the name is instead the first
          of these. A null value may be passed to assign a default callback for
          those operators without an explicitly associated one.
    :type hook: :py:class:`Hook`
    :param hook: An instance of a subclass of Hook defining its run method.
          The object must be alive as long as the binding is active. A null value
          can be passed to disconnect the current one.

    :rtype: boolean
    :return: Whether this call overwrites a previous binding.
    """
    return _maude.connectEqHook(name, hook)

def connectRlHook(name, hook):
    r"""
    Connect a callback for rule rewriting a special operator declared with
    the ``SpecialHubSymbol`` id-hook.

    :type name: string
    :param name: The name of the operator to be bound to this callback.
          In case the id-hook contains arguments, the name is instead the first
          of these. A null value may be passed to assign a default callback for
          those operators without an explicitly associated one.
    :type hook: :py:class:`Hook`
    :param hook: An instance of a subclass of Hook defining its run method.
          The object must be alive as long as the binding is active. A null value
          can be passed to disconnect the current one.

    :rtype: boolean
    :return: Whether this call overwrites a previous binding.
    """
    return _maude.connectRlHook(name, hook)
class RewriteSmtSequenceSearch(object):
    r"""An iterator through the solutions of a search."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getRewriteCount(self):
        r"""Get the number of rewrites until this term has been found."""
        return _maude.RewriteSmtSequenceSearch_getRewriteCount(self)

    def getSubstitution(self):
        r"""Get the matching substitution of the solution into the pattern."""
        return _maude.RewriteSmtSequenceSearch_getSubstitution(self)

    def getRule(self, stateNr=-1):
        r"""
        Get the rule leading to the given state.

        :type stateNr: int, optional
        :param stateNr: The number of a state in the search graph
            or -1 for the current one.
        """
        return _maude.RewriteSmtSequenceSearch_getRule(self, stateNr)

    def getStateTerm(self, stateNr):
        r"""
        Get the term of a given state.

        :type stateNr: int
        :param stateNr: The number of a state in the search graph.
        """
        return _maude.RewriteSmtSequenceSearch_getStateTerm(self, stateNr)

    def __next(self):
        r"""
        Get the next match.

        :rtype: :py:class:`EasyTerm`
        :return: A term or a null pointer if there is no more matches.
        """
        return _maude.RewriteSmtSequenceSearch___next(self)

    def getStateConst(self, stateNr):
        r"""Get the number of rewrites until this term has been found."""
        return _maude.RewriteSmtSequenceSearch_getStateConst(self, stateNr)

    def getStateNr(self):
        r"""
        Get an internal state number that allows reconstructing
        the path to this term.
        """
        return _maude.RewriteSmtSequenceSearch_getStateNr(self)

    def getStateParent(self, stateNr):
        r"""
        Get the parent state.

        :type stateNr: int
        :param stateNr: The number of a state in the search graph.

        :rtype: int
        :return: The number of the parent or -1 for the root.
        """
        return _maude.RewriteSmtSequenceSearch_getStateParent(self, stateNr)
    __swig_destroy__ = _maude.delete_RewriteSmtSequenceSearch

# Register RewriteSmtSequenceSearch in _maude:
_maude.RewriteSmtSequenceSearch_swigregister(RewriteSmtSequenceSearch)

def setSmtSolver(solver):
    return _maude.setSmtSolver(solver)

def setSmtManagerFactory(fac):
    return _maude.setSmtManagerFactory(fac)
SHARED_PTR_DISOWN = _maude.SHARED_PTR_DISOWN
class _PySmtTermVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude._PySmtTermVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude._PySmtTermVector___nonzero__(self)

    def __bool__(self):
        return _maude._PySmtTermVector___bool__(self)

    def __len__(self):
        return _maude._PySmtTermVector___len__(self)

    def __getslice__(self, i, j):
        return _maude._PySmtTermVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude._PySmtTermVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude._PySmtTermVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude._PySmtTermVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude._PySmtTermVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude._PySmtTermVector___setitem__(self, *args)

    def pop(self):
        return _maude._PySmtTermVector_pop(self)

    def append(self, x):
        return _maude._PySmtTermVector_append(self, x)

    def empty(self):
        return _maude._PySmtTermVector_empty(self)

    def size(self):
        return _maude._PySmtTermVector_size(self)

    def swap(self, v):
        return _maude._PySmtTermVector_swap(self, v)

    def begin(self):
        return _maude._PySmtTermVector_begin(self)

    def end(self):
        return _maude._PySmtTermVector_end(self)

    def rbegin(self):
        return _maude._PySmtTermVector_rbegin(self)

    def rend(self):
        return _maude._PySmtTermVector_rend(self)

    def clear(self):
        return _maude._PySmtTermVector_clear(self)

    def get_allocator(self):
        return _maude._PySmtTermVector_get_allocator(self)

    def pop_back(self):
        return _maude._PySmtTermVector_pop_back(self)

    def erase(self, *args):
        return _maude._PySmtTermVector_erase(self, *args)

    def __init__(self, *args):
        _maude._PySmtTermVector_swiginit(self, _maude.new__PySmtTermVector(*args))

    def push_back(self, x):
        return _maude._PySmtTermVector_push_back(self, x)

    def front(self):
        return _maude._PySmtTermVector_front(self)

    def back(self):
        return _maude._PySmtTermVector_back(self)

    def assign(self, n, x):
        return _maude._PySmtTermVector_assign(self, n, x)

    def resize(self, *args):
        return _maude._PySmtTermVector_resize(self, *args)

    def insert(self, *args):
        return _maude._PySmtTermVector_insert(self, *args)

    def reserve(self, n):
        return _maude._PySmtTermVector_reserve(self, n)

    def capacity(self):
        return _maude._PySmtTermVector_capacity(self)
    __swig_destroy__ = _maude.delete__PySmtTermVector

# Register _PySmtTermVector in _maude:
_maude._PySmtTermVector_swigregister(_PySmtTermVector)
class SmtTerm(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, data):
        _maude.SmtTerm_swiginit(self, _maude.new_SmtTerm(data))
    __swig_destroy__ = _maude.delete_SmtTerm

# Register SmtTerm in _maude:
_maude.SmtTerm_swigregister(SmtTerm)
class TermSubst(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _maude.TermSubst_swiginit(self, _maude.new_TermSubst())
    __swig_destroy__ = _maude.delete_TermSubst

    def get(self, t):
        return _maude.TermSubst_get(self, t)

    def keys(self):
        return _maude.TermSubst_keys(self)

    def set(self, var, val):
        return _maude.TermSubst_set(self, var, val)

# Register TermSubst in _maude:
_maude.TermSubst_swigregister(TermSubst)
class SmtModel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _maude.SmtModel_swiginit(self, _maude.new_SmtModel())
    __swig_destroy__ = _maude.delete_SmtModel

    def set(self, k, v):
        return _maude.SmtModel_set(self, k, v)

    def get(self, k):
        return _maude.SmtModel_get(self, k)

    def keys(self):
        return _maude.SmtModel_keys(self)

# Register SmtModel in _maude:
_maude.SmtModel_swigregister(SmtModel)
class cmpExprById(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __call__(self, lhs, rhs):
        return _maude.cmpExprById___call__(self, lhs, rhs)

    def __init__(self):
        _maude.cmpExprById_swiginit(self, _maude.new_cmpExprById())
    __swig_destroy__ = _maude.delete_cmpExprById

# Register cmpExprById in _maude:
_maude.cmpExprById_swigregister(cmpExprById)
class Converter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _maude.delete_Converter

    def prepareFor(self, module):
        return _maude.Converter_prepareFor(self, module)

    def dag2term(self, *args):
        return _maude.Converter_dag2term(self, *args)

    def term2dag(self, *args):
        return _maude.Converter_term2dag(self, *args)

    def cache_insert(self, dag, term):
        return _maude.Converter_cache_insert(self, dag, term)

    def cache_find(self, *args):
        return _maude.Converter_cache_find(self, *args)

    def __init__(self):
        if self.__class__ == Converter:
            _self = None
        else:
            _self = self
        _maude.Converter_swiginit(self, _maude.new_Converter(_self, ))
    def __disown__(self):
        self.this.disown()
        _maude.disown_Converter(self)
        return weakref.proxy(self)

# Register Converter in _maude:
_maude.Converter_swigregister(Converter)
class Connector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _maude.delete_Connector

    def get_model(self):
        return _maude.Connector_get_model(self)

    def get_converter(self):
        return _maude.Connector_get_converter(self)

    def set_logic(self, logic):
        return _maude.Connector_set_logic(self, logic)

    def check_sat(self, *args):
        return _maude.Connector_check_sat(self, *args)

    def add_const(self, *args):
        return _maude.Connector_add_const(self, *args)

    def mk_subst(self, subst_dict):
        return _maude.Connector_mk_subst(self, subst_dict)

    def subsume(self, *args):
        return _maude.Connector_subsume(self, *args)

    def simplify(self, *args):
        return _maude.Connector_simplify(self, *args)

    def push(self):
        return _maude.Connector_push(self)

    def pop(self):
        return _maude.Connector_pop(self)

    def reset(self):
        return _maude.Connector_reset(self)

    def print_model(self):
        return _maude.Connector_print_model(self)

    def __init__(self):
        if self.__class__ == Connector:
            _self = None
        else:
            _self = self
        _maude.Connector_swiginit(self, _maude.new_Connector(_self, ))
    def __disown__(self):
        self.this.disown()
        _maude.disown_Connector(self)
        return weakref.proxy(self)

# Register Connector in _maude:
_maude.Connector_swigregister(Connector)
class SmtManagerFactory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _maude.delete_SmtManagerFactory

    def createConnector(self, *args):
        return _maude.SmtManagerFactory_createConnector(self, *args)

    def createConverter(self, *args):
        return _maude.SmtManagerFactory_createConverter(self, *args)

    def __init__(self):
        if self.__class__ == SmtManagerFactory:
            _self = None
        else:
            _self = self
        _maude.SmtManagerFactory_swiginit(self, _maude.new_SmtManagerFactory(_self, ))
    def __disown__(self):
        self.this.disown()
        _maude.disown_SmtManagerFactory(self)
        return weakref.proxy(self)

# Register SmtManagerFactory in _maude:
_maude.SmtManagerFactory_swigregister(SmtManagerFactory)
class SmtManagerFactorySetter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def set(self):
        return _maude.SmtManagerFactorySetter_set(self)

    def __init__(self):
        _maude.SmtManagerFactorySetter_swiginit(self, _maude.new_SmtManagerFactorySetter())
    __swig_destroy__ = _maude.delete_SmtManagerFactorySetter

# Register SmtManagerFactorySetter in _maude:
_maude.SmtManagerFactorySetter_swigregister(SmtManagerFactorySetter)
sat = _maude.sat
unsat = _maude.unsat
unknown = _maude.unknown

def get_data(obj):
    return _maude.get_data(obj)

