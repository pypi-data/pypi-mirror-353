# coding: utf-8

"""
    Immich

    Immich API

    The version of the OpenAPI document: 1.134.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from immich_python_sdk.models.asset_order import AssetOrder
from immich_python_sdk.models.asset_type_enum import AssetTypeEnum
from immich_python_sdk.models.asset_visibility import AssetVisibility
from typing import Optional, Set
from typing_extensions import Self

class MetadataSearchDto(BaseModel):
    """
    MetadataSearchDto
    """ # noqa: E501
    checksum: Optional[StrictStr] = None
    city: Optional[StrictStr] = None
    country: Optional[StrictStr] = None
    created_after: Optional[datetime] = Field(default=None, alias="createdAfter")
    created_before: Optional[datetime] = Field(default=None, alias="createdBefore")
    description: Optional[StrictStr] = None
    device_asset_id: Optional[StrictStr] = Field(default=None, alias="deviceAssetId")
    device_id: Optional[StrictStr] = Field(default=None, alias="deviceId")
    encoded_video_path: Optional[StrictStr] = Field(default=None, alias="encodedVideoPath")
    id: Optional[StrictStr] = None
    is_encoded: Optional[StrictBool] = Field(default=None, alias="isEncoded")
    is_favorite: Optional[StrictBool] = Field(default=None, alias="isFavorite")
    is_motion: Optional[StrictBool] = Field(default=None, alias="isMotion")
    is_not_in_album: Optional[StrictBool] = Field(default=None, alias="isNotInAlbum")
    is_offline: Optional[StrictBool] = Field(default=None, alias="isOffline")
    lens_model: Optional[StrictStr] = Field(default=None, alias="lensModel")
    library_id: Optional[StrictStr] = Field(default=None, alias="libraryId")
    make: Optional[StrictStr] = None
    model: Optional[StrictStr] = None
    order: Optional[AssetOrder] = None
    original_file_name: Optional[StrictStr] = Field(default=None, alias="originalFileName")
    original_path: Optional[StrictStr] = Field(default=None, alias="originalPath")
    page: Optional[Union[Annotated[float, Field(strict=True, ge=1)], Annotated[int, Field(strict=True, ge=1)]]] = None
    person_ids: Optional[List[StrictStr]] = Field(default=None, alias="personIds")
    preview_path: Optional[StrictStr] = Field(default=None, alias="previewPath")
    rating: Optional[Union[Annotated[float, Field(le=5, strict=True, ge=-1)], Annotated[int, Field(le=5, strict=True, ge=-1)]]] = None
    size: Optional[Union[Annotated[float, Field(le=1000, strict=True, ge=1)], Annotated[int, Field(le=1000, strict=True, ge=1)]]] = None
    state: Optional[StrictStr] = None
    tag_ids: Optional[List[StrictStr]] = Field(default=None, alias="tagIds")
    taken_after: Optional[datetime] = Field(default=None, alias="takenAfter")
    taken_before: Optional[datetime] = Field(default=None, alias="takenBefore")
    thumbnail_path: Optional[StrictStr] = Field(default=None, alias="thumbnailPath")
    trashed_after: Optional[datetime] = Field(default=None, alias="trashedAfter")
    trashed_before: Optional[datetime] = Field(default=None, alias="trashedBefore")
    type: Optional[AssetTypeEnum] = None
    updated_after: Optional[datetime] = Field(default=None, alias="updatedAfter")
    updated_before: Optional[datetime] = Field(default=None, alias="updatedBefore")
    visibility: Optional[AssetVisibility] = None
    with_deleted: Optional[StrictBool] = Field(default=None, alias="withDeleted")
    with_exif: Optional[StrictBool] = Field(default=None, alias="withExif")
    with_people: Optional[StrictBool] = Field(default=None, alias="withPeople")
    with_stacked: Optional[StrictBool] = Field(default=None, alias="withStacked")
    __properties: ClassVar[List[str]] = ["checksum", "city", "country", "createdAfter", "createdBefore", "description", "deviceAssetId", "deviceId", "encodedVideoPath", "id", "isEncoded", "isFavorite", "isMotion", "isNotInAlbum", "isOffline", "lensModel", "libraryId", "make", "model", "order", "originalFileName", "originalPath", "page", "personIds", "previewPath", "rating", "size", "state", "tagIds", "takenAfter", "takenBefore", "thumbnailPath", "trashedAfter", "trashedBefore", "type", "updatedAfter", "updatedBefore", "visibility", "withDeleted", "withExif", "withPeople", "withStacked"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MetadataSearchDto from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if city (nullable) is None
        # and model_fields_set contains the field
        if self.city is None and "city" in self.model_fields_set:
            _dict['city'] = None

        # set to None if country (nullable) is None
        # and model_fields_set contains the field
        if self.country is None and "country" in self.model_fields_set:
            _dict['country'] = None

        # set to None if lens_model (nullable) is None
        # and model_fields_set contains the field
        if self.lens_model is None and "lens_model" in self.model_fields_set:
            _dict['lensModel'] = None

        # set to None if library_id (nullable) is None
        # and model_fields_set contains the field
        if self.library_id is None and "library_id" in self.model_fields_set:
            _dict['libraryId'] = None

        # set to None if model (nullable) is None
        # and model_fields_set contains the field
        if self.model is None and "model" in self.model_fields_set:
            _dict['model'] = None

        # set to None if state (nullable) is None
        # and model_fields_set contains the field
        if self.state is None and "state" in self.model_fields_set:
            _dict['state'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MetadataSearchDto from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "checksum": obj.get("checksum"),
            "city": obj.get("city"),
            "country": obj.get("country"),
            "createdAfter": obj.get("createdAfter"),
            "createdBefore": obj.get("createdBefore"),
            "description": obj.get("description"),
            "deviceAssetId": obj.get("deviceAssetId"),
            "deviceId": obj.get("deviceId"),
            "encodedVideoPath": obj.get("encodedVideoPath"),
            "id": obj.get("id"),
            "isEncoded": obj.get("isEncoded"),
            "isFavorite": obj.get("isFavorite"),
            "isMotion": obj.get("isMotion"),
            "isNotInAlbum": obj.get("isNotInAlbum"),
            "isOffline": obj.get("isOffline"),
            "lensModel": obj.get("lensModel"),
            "libraryId": obj.get("libraryId"),
            "make": obj.get("make"),
            "model": obj.get("model"),
            "order": obj.get("order"),
            "originalFileName": obj.get("originalFileName"),
            "originalPath": obj.get("originalPath"),
            "page": obj.get("page"),
            "personIds": obj.get("personIds"),
            "previewPath": obj.get("previewPath"),
            "rating": obj.get("rating"),
            "size": obj.get("size"),
            "state": obj.get("state"),
            "tagIds": obj.get("tagIds"),
            "takenAfter": obj.get("takenAfter"),
            "takenBefore": obj.get("takenBefore"),
            "thumbnailPath": obj.get("thumbnailPath"),
            "trashedAfter": obj.get("trashedAfter"),
            "trashedBefore": obj.get("trashedBefore"),
            "type": obj.get("type"),
            "updatedAfter": obj.get("updatedAfter"),
            "updatedBefore": obj.get("updatedBefore"),
            "visibility": obj.get("visibility"),
            "withDeleted": obj.get("withDeleted"),
            "withExif": obj.get("withExif"),
            "withPeople": obj.get("withPeople"),
            "withStacked": obj.get("withStacked")
        })
        return _obj


