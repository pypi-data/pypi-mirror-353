name: Create Release

on:
  workflow_dispatch:
    inputs:
      revision:
        description: 'Git revision (commit SHA, branch, or tag) to checkout'
        required: false
        default: ''
        type: string
      publish_to_pypi:
        description: 'Publish to PyPI?'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      create_prerelease:
        description: 'Create a pre-release tag?'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      prerelease_type:
        description: 'Pre-release type (if creating pre-release)'
        required: false
        default: 'dev'
        type: choice
        options:
          - 'dev'
          - 'alpha'
          - 'beta'
          - 'rc'

jobs:
  prepare-version:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.version.outputs.version }}
      pypi_version: ${{ steps.version.outputs.pypi_version }}
      git_hash: ${{ steps.version.outputs.git_hash }}
      tag_name: ${{ steps.version.outputs.tag_name }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      dev_status: ${{ steps.version.outputs.dev_status }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: false
          fetch-depth: 0
          ref: ${{ github.event.inputs.revision || github.sha }}

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          enable-cache: false

      - name: Set up Python
        run: uv python install 3.11

      - name: Install setuptools-scm
        run: |
          # Sync the project to ensure setuptools-scm is available
          uv sync --extra dev

      - name: Get version from setuptools-scm
        id: version
        run: |
          # Get the short commit hash
          GIT_COMMIT_SHORT_HASH=$(git rev-parse --short=7 HEAD)
          echo "Git commit short hash: $GIT_COMMIT_SHORT_HASH"

          # Get version using setuptools-scm (this handles all the dev versioning automatically)
          SCM_VERSION=$(uv run python -c "from setuptools_scm import get_version; print(get_version())")
          echo "setuptools-scm version: $SCM_VERSION"

          # Extract the clean version without local identifiers for PyPI
          PYPI_VERSION=$(echo "$SCM_VERSION" | sed 's/+.*//')
          echo "PyPI version: $PYPI_VERSION"

          # Handle manual pre-release creation
          if [[ "${{ github.event.inputs.create_prerelease }}" == "true" ]]; then
            echo "Creating manual pre-release..."

            # Get base version from current setuptools-scm version
            BASE_VERSION=$(echo "$PYPI_VERSION" | sed 's/\.dev[0-9]*$//')
            PRE_TYPE="${{ github.event.inputs.prerelease_type }}"

            # Find the latest pre-release tag for this version and type
            git fetch --tags
            TAG_PATTERN="v${BASE_VERSION}${PRE_TYPE}[0-9]*"
            LATEST_PRE_TAG=$(git tag -l "$TAG_PATTERN" | sort -V | tail -n 1)

            if [[ -n "$LATEST_PRE_TAG" ]]; then
              # Extract the number from the tag and increment
              if [[ "$LATEST_PRE_TAG" =~ ${PRE_TYPE}([0-9]+) ]]; then
                PREV_NUMBER="${BASH_REMATCH[1]}"
                PRE_NUMBER=$((PREV_NUMBER + 1))
                echo "Found previous pre-release number: $PREV_NUMBER, incrementing to: $PRE_NUMBER"
              else
                PRE_NUMBER="1"
                echo "Could not parse pre-release number, using: 1"
              fi
            else
              PRE_NUMBER="1"
              echo "No previous pre-release tags found, starting with: 1"
            fi

            # Create PEP 440 compliant pre-release version
            if [[ "$PRE_TYPE" == "dev" ]]; then
              PYPI_VERSION="${BASE_VERSION}.dev${PRE_NUMBER}"
              TAG_NAME="v${BASE_VERSION}.dev${PRE_NUMBER}"
            elif [[ "$PRE_TYPE" == "alpha" ]]; then
              PYPI_VERSION="${BASE_VERSION}a${PRE_NUMBER}"
              TAG_NAME="v${BASE_VERSION}${PRE_TYPE}${PRE_NUMBER}"
            elif [[ "$PRE_TYPE" == "beta" ]]; then
              PYPI_VERSION="${BASE_VERSION}b${PRE_NUMBER}"
              TAG_NAME="v${BASE_VERSION}${PRE_TYPE}${PRE_NUMBER}"
            elif [[ "$PRE_TYPE" == "rc" ]]; then
              PYPI_VERSION="${BASE_VERSION}rc${PRE_NUMBER}"
              TAG_NAME="v${BASE_VERSION}${PRE_TYPE}${PRE_NUMBER}"
            fi

            IS_PRERELEASE="true"

            echo "Manual pre-release version: $PYPI_VERSION"
            echo "Manual pre-release tag: $TAG_NAME"
          else
            # Use setuptools-scm automatic versioning

            # Check if this is a pre-release (contains dev, alpha, beta, rc)
            if [[ "$PYPI_VERSION" =~ (dev|a|b|rc) ]]; then
              IS_PRERELEASE="true"
              echo "Detected automatic pre-release version"
            else
              IS_PRERELEASE="false"
              echo "Detected stable release version"
            fi

            # For manual tag creation, use the provided tag name or create one from version
            if [[ -n "${{ github.event.inputs.revision }}" && "${{ github.event.inputs.revision }}" =~ ^v[0-9] ]]; then
              # User provided a tag name
              TAG_NAME="${{ github.event.inputs.revision }}"
              echo "Using provided tag name: $TAG_NAME"
            else
              # Create tag name from version (for dev releases, don't create tags automatically)
              if [[ "$IS_PRERELEASE" == "true" ]]; then
                TAG_NAME=""  # Don't auto-create tags for dev versions
                echo "Dev version detected - no automatic tag creation"
              else
                TAG_NAME="v${PYPI_VERSION}"
                echo "Will create tag: $TAG_NAME"
              fi
            fi
          fi

          # Determine development status based on version
          if [[ "$PYPI_VERSION" =~ dev ]]; then
            DEV_STATUS="Development Status :: 2 - Pre-Alpha"
          elif [[ "$PYPI_VERSION" =~ a ]]; then
            DEV_STATUS="Development Status :: 3 - Alpha"
          elif [[ "$PYPI_VERSION" =~ (b|rc) ]]; then
            DEV_STATUS="Development Status :: 4 - Beta"
          else
            DEV_STATUS="Development Status :: 5 - Production/Stable"
          fi

          echo "Final version: $PYPI_VERSION"
          echo "Final tag: $TAG_NAME"
          echo "Is pre-release: $IS_PRERELEASE"
          echo "Dev status: $DEV_STATUS"

          echo "version=$SCM_VERSION" >> $GITHUB_OUTPUT
          echo "pypi_version=$PYPI_VERSION" >> $GITHUB_OUTPUT
          echo "git_hash=$GIT_COMMIT_SHORT_HASH" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "dev_status=$DEV_STATUS" >> $GITHUB_OUTPUT

      - name: Create and push Git tag
        if: steps.version.outputs.tag_name != ''
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          echo "Creating tag ${{ steps.version.outputs.tag_name }} for current commit"
          git tag -a ${{ steps.version.outputs.tag_name }} -m "Release ${{ steps.version.outputs.tag_name }}"
          git push origin ${{ steps.version.outputs.tag_name }}
          echo "Tag ${{ steps.version.outputs.tag_name }} created and pushed"

  create-release:
    runs-on: ubuntu-latest
    needs: prepare-version
    if: needs.prepare-version.outputs.tag_name != ''
    permissions:
      contents: write
    outputs:
      version: ${{ needs.prepare-version.outputs.version }}
      pypi_version: ${{ needs.prepare-version.outputs.pypi_version }}
      git_hash: ${{ needs.prepare-version.outputs.git_hash }}
      tag_name: ${{ needs.prepare-version.outputs.tag_name }}
      is_prerelease: ${{ needs.prepare-version.outputs.is_prerelease }}
      dev_status: ${{ needs.prepare-version.outputs.dev_status }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: false
          fetch-depth: 0
          ref: ${{ needs.prepare-version.outputs.tag_name }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          name: IDA Domain v${{ needs.prepare-version.outputs.pypi_version }}
          tag_name: ${{ needs.prepare-version.outputs.tag_name }}
          body: |
            # IDA Domain v${{ needs.prepare-version.outputs.pypi_version }}

            ${{ needs.prepare-version.outputs.is_prerelease == 'true' && '⚠️ **PRE-RELEASE VERSION**: This is a pre-release intended for testing purposes. APIs may change without notice and pre-release versions may be deleted at any time.' || '' }}

            Built from tag: ${{ needs.prepare-version.outputs.tag_name }}
            Commit: ${{ needs.prepare-version.outputs.git_hash }}

            ## Installation

            ${{ github.event.inputs.publish_to_pypi == 'true' && '### From PyPI

            ```bash
            # Install from PyPI' || '' }}
            ${{ needs.prepare-version.outputs.is_prerelease == 'true' && 'pip install --pre ida-domain' || 'pip install ida-domain' }}${{ github.event.inputs.publish_to_pypi == 'true' && '
            ```

            ### From Source

            ' || '' }}This release contains the source code for the IDA Domain API.

            To use this release:
            1. Clone or download the source code from this tag
            2. Follow the build instructions in the README

            This release was automatically generated by GitHub Actions.
          draft: false
          prerelease: ${{ needs.prepare-version.outputs.is_prerelease == 'true' }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-package:
    runs-on: ubuntu-latest
    needs: [prepare-version, create-release]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: false
          fetch-depth: 0
          ref: ${{ needs.prepare-version.outputs.tag_name }}

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          enable-cache: true

      - name: Set up Python
        run: uv python install 3.11

      - name: Update version in pyproject.toml
        run: |
          # Update version in pyproject.toml to use PyPI-compliant version
          echo "Updating version to ${{ needs.prepare-version.outputs.pypi_version }} in pyproject.toml"

          # Use sed to replace the version line in pyproject.toml
          sed -i 's/^version = .*/version = "${{ needs.prepare-version.outputs.pypi_version }}"/' pyproject.toml

          # Verify the change
          echo "Updated pyproject.toml version:"
          grep "^version" pyproject.toml

      - name: Add development status classifier for pre-releases
        if: needs.prepare-version.outputs.is_prerelease == 'true'
        run: |
          # Add development status classifier to pyproject.toml
          echo "Adding development status classifier: ${{ needs.prepare-version.outputs.dev_status }}"

          # Find the classifiers section and add the development status
          if grep -q "classifiers = \[" pyproject.toml; then
            # Add after the opening bracket of classifiers
            sed -i '/classifiers = \[/a\    "${{ needs.prepare-version.outputs.dev_status }}",' pyproject.toml
          else
            echo "Warning: Could not find classifiers section in pyproject.toml"
          fi

      - name: Build Python package
        run: |
          echo "Building Python package with uv..."

          # Sync dependencies (this will create a virtual environment)
          uv sync --extra dev

          # Build the package using uv
          uv build

          echo "Built package files:"
          ls -la dist/

      - name: Verify package
        run: |
          # Install twine for package verification
          uv add --dev twine

          # Verify the built packages
          echo "Verifying package integrity..."
          uv run twine check dist/*.whl dist/*.tar.gz

      - name: Upload Python package artifacts
        uses: actions/upload-artifact@v4
        with:
          name: python-package-dist
          path: dist/
          retention-days: 14

  publish-package:
    runs-on: ubuntu-latest
    needs: [prepare-version, create-release, build-package]
    if: github.event.inputs.publish_to_pypi == 'true'

    steps:
      - name: Download package artifacts
        uses: actions/download-artifact@v4
        with:
          name: python-package-dist
          path: dist/

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install publishing tools
        run: |
          python -m pip install --upgrade pip
          pip install twine uv

      - name: Verify package before publishing
        run: |
          echo "Final verification before publishing..."
          echo "Package files to publish:"
          ls -la dist/

          # Final verification with twine
          twine check dist/*.whl dist/*.tar.gz

      - name: Publish to PyPI
        run: |
          echo "Publishing to PyPI..."
          echo "PyPI version: ${{ needs.prepare-version.outputs.pypi_version }}"
          echo "Is pre-release: ${{ needs.prepare-version.outputs.is_prerelease }}"

          # Publish using uv publish
          uv publish \
            --token ${{ secrets.PYPI_API_TOKEN }} \
            --verbose \
            dist/*
        env:
          UV_PUBLISH_TOKEN: ${{ secrets.PYPI_API_TOKEN }}

      - name: Verify PyPI publication
        run: |
          echo "Waiting for package to be available on PyPI..."
          sleep 30

          # Try to install the published package to verify it's available
          echo "Attempting to install published package..."
          if [[ "${{ needs.prepare-version.outputs.is_prerelease }}" == "true" ]]; then
            pip install --pre ida-domain==${{ needs.prepare-version.outputs.pypi_version }} || echo "Package not yet available on PyPI"
          else
            pip install ida-domain==${{ needs.prepare-version.outputs.pypi_version }} || echo "Package not yet available on PyPI"
          fi

  cleanup-on-failure:
    runs-on: ubuntu-latest
    needs: [prepare-version, create-release, build-package, publish-package]
    if: always() && contains(needs.*.result, 'failure')
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Delete tag if job fails
        run: |
          echo "Workflow failed. Deleting tag ${{ needs.prepare-version.outputs.tag_name }}"
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          # Delete the tag remotely
          git push origin --delete ${{ needs.prepare-version.outputs.tag_name }} || echo "Failed to delete remote tag, it may not exist"

          # Delete the tag locally
          git tag -d ${{ needs.prepare-version.outputs.tag_name }} || echo "Failed to delete local tag, it may not exist"

          echo "Tag cleanup completed"
          echo "GitHub release may have been created - check the releases page and delete manually if needed"
