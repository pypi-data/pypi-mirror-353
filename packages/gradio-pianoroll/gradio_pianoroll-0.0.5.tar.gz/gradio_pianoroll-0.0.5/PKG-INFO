Metadata-Version: 2.4
Name: gradio_pianoroll
Version: 0.0.5
Summary: A PianoRoll Component for Gradio.
Author-email: crlotwhite <crlotwhite@gmail.com>
License-Expression: Apache-2.0
Keywords: audio,gradio-custom-component,gradio-template-Fallback
Classifier: Development Status :: 3 - Alpha
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3 :: Only
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Topic :: Scientific/Engineering
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Classifier: Topic :: Scientific/Engineering :: Visualization
Requires-Python: >=3.10
Requires-Dist: gradio<6.0,>=4.0
Provides-Extra: dev
Requires-Dist: build; extra == 'dev'
Requires-Dist: twine; extra == 'dev'
Description-Content-Type: text/markdown

---
tags: [gradio-custom-component, ]
title: gradio_pianoroll
short_description: A PianoRoll Component for
colorFrom: blue
colorTo: yellow
sdk: gradio
pinned: false
app_file: space.py
---

# `gradio_pianoroll`
<a href="https://pypi.org/project/gradio_pianoroll/" target="_blank"><img alt="PyPI - Version" src="https://img.shields.io/pypi/v/gradio_pianoroll"></a>  

A PianoRoll Component for Gradio.

## Installation

```bash
pip install gradio_pianoroll
```

## Usage

```python
import gradio as gr
import numpy as np
import io
import base64
import wave
import tempfile
import os
from gradio_pianoroll import PianoRoll

# F0 ë¶„ì„ì„ ìœ„í•œ ì¶”ê°€ import
try:
    import librosa
    LIBROSA_AVAILABLE = True
    print("âœ… librosa ì‚¬ìš© ê°€ëŠ¥")
except ImportError:
    LIBROSA_AVAILABLE = False
    print("âš ï¸ librosaê°€ ì„¤ì¹˜ë˜ì§€ ì•ŠìŒ. F0 ë¶„ì„ ê¸°ëŠ¥ì´ ì œí•œë©ë‹ˆë‹¤.")

# ì‹ ë””ì‚¬ì´ì € ì„¤ì •
SAMPLE_RATE = 44100
MAX_DURATION = 10.0  # ìµœëŒ€ 10ì´ˆ

# ì‚¬ìš©ì ì •ì˜ phoneme ë§¤í•‘ (ì „ì—­ ìƒíƒœ)
user_phoneme_map = {}

def initialize_phoneme_map():
    """ê¸°ë³¸ í•œêµ­ì–´ phoneme ë§¤í•‘ìœ¼ë¡œ ì´ˆê¸°í™”"""
    global user_phoneme_map
    user_phoneme_map = {
        'ê°€': 'g a',
        'ë‚˜': 'n a',
        'ë‹¤': 'd a',
        'ë¼': 'l aa',
        'ë§ˆ': 'm a',
        'ë°”': 'b a',
        'ì‚¬': 's a',
        'ì•„': 'aa',
        'ì': 'j a',
        'ì°¨': 'ch a',
        'ì¹´': 'k a',
        'íƒ€': 't a',
        'íŒŒ': 'p a',
        'í•˜': 'h a',
        'ë„': 'd o',
        'ë ˆ': 'l e',
        'ë¯¸': 'm i',
        'íŒŒ': 'p aa',
        'ì†”': 's o l',
        'ë¼': 'l aa',
        'ì‹œ': 's i',
        'ì•ˆë…•': 'aa n ny eo ng',
        'í•˜ì„¸ìš”': 'h a s e y o',
        'ë…¸ë˜': 'n o l ae',
        'ì‚¬ë‘': 's a l a ng',
        'í–‰ë³µ': 'h ae ng b o k',
        'ìŒì•…': 'eu m a k',
        'í”¼ì•„ë…¸': 'p i a n o'
    }

# í”„ë¡œê·¸ë¨ ì‹œì‘ ì‹œ phoneme ë§¤í•‘ ì´ˆê¸°í™”
initialize_phoneme_map()

def get_phoneme_mapping_list():
    """í˜„ì¬ phoneme ë§¤í•‘ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜ (UI í‘œì‹œìš©)"""
    global user_phoneme_map
    return [{"lyric": k, "phoneme": v} for k, v in user_phoneme_map.items()]

def get_phoneme_mapping_for_dataframe():
    """Dataframeìš© phoneme ë§¤í•‘ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜"""
    global user_phoneme_map
    return [[k, v] for k, v in user_phoneme_map.items()]

def add_phoneme_mapping(lyric: str, phoneme: str):
    """ìƒˆë¡œìš´ phoneme ë§¤í•‘ ì¶”ê°€"""
    global user_phoneme_map
    user_phoneme_map[lyric.strip()] = phoneme.strip()
    return get_phoneme_mapping_for_dataframe(), f"'{lyric}' â†’ '{phoneme}' ë§¤í•‘ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤."

def update_phoneme_mapping(old_lyric: str, new_lyric: str, new_phoneme: str):
    """ê¸°ì¡´ phoneme ë§¤í•‘ ìˆ˜ì •"""
    global user_phoneme_map

    # ê¸°ì¡´ ë§¤í•‘ ì‚­ì œ
    if old_lyric in user_phoneme_map:
        del user_phoneme_map[old_lyric]

    # ìƒˆ ë§¤í•‘ ì¶”ê°€
    user_phoneme_map[new_lyric.strip()] = new_phoneme.strip()
    return get_phoneme_mapping_for_dataframe(), f"ë§¤í•‘ì´ '{new_lyric}' â†’ '{new_phoneme}'ë¡œ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤."

def delete_phoneme_mapping(lyric: str):
    """phoneme ë§¤í•‘ ì‚­ì œ"""
    global user_phoneme_map
    if lyric in user_phoneme_map:
        del user_phoneme_map[lyric]
        return get_phoneme_mapping_for_dataframe(), f"'{lyric}' ë§¤í•‘ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤."
    else:
        return get_phoneme_mapping_for_dataframe(), f"'{lyric}' ë§¤í•‘ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

def reset_phoneme_mapping():
    """phoneme ë§¤í•‘ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹"""
    initialize_phoneme_map()
    return get_phoneme_mapping_for_dataframe(), "Phoneme ë§¤í•‘ì´ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹ë˜ì—ˆìŠµë‹ˆë‹¤."

def midi_to_frequency(midi_note):
    """MIDI ë…¸íŠ¸ ë²ˆí˜¸ë¥¼ ì£¼íŒŒìˆ˜ë¡œ ë³€í™˜ (A4 = 440Hz)"""
    return 440.0 * (2.0 ** ((midi_note - 69) / 12.0))

def create_adsr_envelope(attack, decay, sustain, release, duration, sample_rate):
    """ADSR ì—”ë²¨ë¡œí”„ë¥¼ ìƒì„±"""
    total_samples = int(duration * sample_rate)
    attack_samples = int(attack * sample_rate)
    decay_samples = int(decay * sample_rate)
    release_samples = int(release * sample_rate)
    sustain_samples = total_samples - attack_samples - decay_samples - release_samples

    # ì§€ì† êµ¬ê°„ì´ ìŒìˆ˜ê°€ ë˜ì§€ ì•Šë„ë¡ ì¡°ì •
    if sustain_samples < 0:
        sustain_samples = 0
        total_samples = attack_samples + decay_samples + release_samples

    envelope = np.zeros(total_samples)

    # Attack phase
    if attack_samples > 0:
        envelope[:attack_samples] = np.linspace(0, 1, attack_samples)

    # Decay phase
    if decay_samples > 0:
        start_idx = attack_samples
        end_idx = attack_samples + decay_samples
        envelope[start_idx:end_idx] = np.linspace(1, sustain, decay_samples)

    # Sustain phase
    if sustain_samples > 0:
        start_idx = attack_samples + decay_samples
        end_idx = start_idx + sustain_samples
        envelope[start_idx:end_idx] = sustain

    # Release phase
    if release_samples > 0:
        start_idx = attack_samples + decay_samples + sustain_samples
        envelope[start_idx:] = np.linspace(sustain, 0, release_samples)

    return envelope

def generate_sine_wave(frequency, duration, sample_rate):
    """ì‚¬ì¸íŒŒ ìƒì„±"""
    t = np.linspace(0, duration, int(duration * sample_rate), False)
    return np.sin(2 * np.pi * frequency * t)

def generate_sawtooth_wave(frequency, duration, sample_rate):
    """í†±ë‹ˆíŒŒ ìƒì„±"""
    t = np.linspace(0, duration, int(duration * sample_rate), False)
    # 2 * (t * frequency - np.floor(0.5 + t * frequency))
    return 2 * (t * frequency % 1) - 1

def generate_square_wave(frequency, duration, sample_rate):
    """ì‚¬ê°íŒŒ ìƒì„±"""
    t = np.linspace(0, duration, int(duration * sample_rate), False)
    return np.sign(np.sin(2 * np.pi * frequency * t))

def generate_triangle_wave(frequency, duration, sample_rate):
    """ì‚¼ê°íŒŒ ìƒì„±"""
    t = np.linspace(0, duration, int(duration * sample_rate), False)
    return 2 * np.abs(2 * (t * frequency % 1) - 1) - 1

def generate_harmonic_wave(frequency, duration, sample_rate, harmonics=5):
    """í•˜ëª¨ë‹‰ì„ í¬í•¨í•œ ë³µí•© íŒŒí˜• ìƒì„±"""
    t = np.linspace(0, duration, int(duration * sample_rate), False)
    wave = np.zeros_like(t)

    # ê¸°ë³¸ ì£¼íŒŒìˆ˜
    wave += np.sin(2 * np.pi * frequency * t)

    # í•˜ëª¨ë‹‰ ì¶”ê°€ (ê° í•˜ëª¨ë‹‰ì˜ ì§„í­ì€ 1/në¡œ ê°ì†Œ)
    for n in range(2, harmonics + 1):
        amplitude = 1.0 / n
        wave += amplitude * np.sin(2 * np.pi * frequency * n * t)

    # ì •ê·œí™”
    wave = wave / np.max(np.abs(wave))
    return wave

def generate_fm_wave(frequency, duration, sample_rate, mod_freq=5.0, mod_depth=2.0):
    """FM í•©ì„± íŒŒí˜• ìƒì„±"""
    t = np.linspace(0, duration, int(duration * sample_rate), False)

    # Modulator
    modulator = mod_depth * np.sin(2 * np.pi * mod_freq * t)

    # Carrier with frequency modulation
    carrier = np.sin(2 * np.pi * frequency * t + modulator)

    return carrier

def generate_complex_wave(frequency, duration, sample_rate, wave_type='complex'):
    """ë³µí•©ì ì¸ íŒŒí˜• ìƒì„± (ì—¬ëŸ¬ ê¸°ë²• ì¡°í•©)"""
    if wave_type == 'sine':
        return generate_sine_wave(frequency, duration, sample_rate)
    elif wave_type == 'sawtooth':
        return generate_sawtooth_wave(frequency, duration, sample_rate)
    elif wave_type == 'square':
        return generate_square_wave(frequency, duration, sample_rate)
    elif wave_type == 'triangle':
        return generate_triangle_wave(frequency, duration, sample_rate)
    elif wave_type == 'harmonic':
        return generate_harmonic_wave(frequency, duration, sample_rate, harmonics=7)
    elif wave_type == 'fm':
        return generate_fm_wave(frequency, duration, sample_rate, mod_freq=frequency * 0.1, mod_depth=3.0)
    else:  # 'complex' - ì—¬ëŸ¬ íŒŒí˜• ì¡°í•©
        # ê¸°ë³¸ sawtooth + í•˜ëª¨ë‹‰ + ì•½ê°„ì˜ FM
        base = generate_sawtooth_wave(frequency, duration, sample_rate) * 0.6
        harmonic = generate_harmonic_wave(frequency, duration, sample_rate, harmonics=4) * 0.3
        fm = generate_fm_wave(frequency, duration, sample_rate, mod_freq=frequency * 0.05, mod_depth=1.0) * 0.1

        return base + harmonic + fm

def synthesize_audio(piano_roll_data, attack=0.01, decay=0.1, sustain=0.7, release=0.3, wave_type='complex'):
    """í”¼ì•„ë…¸ë¡¤ ë°ì´í„°ë¡œë¶€í„° ì˜¤ë””ì˜¤ë¥¼ í•©ì„±"""
    if not piano_roll_data or 'notes' not in piano_roll_data or not piano_roll_data['notes']:
        return None

    notes = piano_roll_data['notes']
    tempo = piano_roll_data.get('tempo', 120)
    pixels_per_beat = piano_roll_data.get('pixelsPerBeat', 80)

    # ì „ì²´ ê¸¸ì´ ê³„ì‚° (ë§ˆì§€ë§‰ ë…¸íŠ¸ì˜ ëê¹Œì§€)
    max_end_time = 0
    for note in notes:
        # í”½ì…€ì„ ì´ˆë¡œ ë³€í™˜ (í…œí¬ì™€ í”½ì…€ë‹¹ ë¹„íŠ¸ ìˆ˜ ê³ ë ¤)
        start_seconds = (note['start'] / pixels_per_beat) * (60.0 / tempo)
        duration_seconds = (note['duration'] / pixels_per_beat) * (60.0 / tempo)
        end_time = start_seconds + duration_seconds
        max_end_time = max(max_end_time, end_time)

    # ìµœëŒ€ ê¸¸ì´ ì œí•œ
    total_duration = min(max_end_time + 1.0, MAX_DURATION)  # 1ì´ˆ ì—¬ìœ  ì¶”ê°€
    total_samples = int(total_duration * SAMPLE_RATE)

    # ìµœì¢… ì˜¤ë””ì˜¤ ë²„í¼
    audio_buffer = np.zeros(total_samples)

    # ê° ë…¸íŠ¸ ì²˜ë¦¬
    for i, note in enumerate(notes):
        try:
            # ë…¸íŠ¸ ì†ì„±
            pitch = note['pitch']
            velocity = note.get('velocity', 100)

            # ì‹œê°„ ê³„ì‚°
            start_seconds = (note['start'] / pixels_per_beat) * (60.0 / tempo)
            duration_seconds = (note['duration'] / pixels_per_beat) * (60.0 / tempo)

            # ë²”ìœ„ ì²´í¬
            if start_seconds >= total_duration:
                continue

            # ì§€ì† ì‹œê°„ì´ ì „ì²´ ê¸¸ì´ë¥¼ ì´ˆê³¼í•˜ì§€ ì•Šë„ë¡ ì¡°ì •
            if start_seconds + duration_seconds > total_duration:
                duration_seconds = total_duration - start_seconds

            if duration_seconds <= 0:
                continue

            # ì£¼íŒŒìˆ˜ ê³„ì‚°
            frequency = midi_to_frequency(pitch)

            # ë³¼ë¥¨ ê³„ì‚° (velocityë¥¼ 0-1ë¡œ ì •ê·œí™”)
            volume = velocity / 127.0

            # ëª¨ë“  ë…¸íŠ¸ì— ë™ì¼í•œ íŒŒí˜• íƒ€ì… ì‚¬ìš© (ì¼ê´€ì„± ìœ ì§€)
            # ë³µí•© íŒŒí˜• ìƒì„±
            base_wave = generate_complex_wave(frequency, duration_seconds, SAMPLE_RATE, wave_type)

            # ì¶”ê°€ íš¨ê³¼: ë¹„ë¸Œë¼í†  (ì£¼íŒŒìˆ˜ ë³€ì¡°)
            t = np.linspace(0, duration_seconds, len(base_wave), False)
            vibrato_freq = 4.5  # 4.5Hz ë¹„ë¸Œë¼í† 
            vibrato_depth = 0.02  # 2% ì£¼íŒŒìˆ˜ ë³€ì¡°
            vibrato = 1 + vibrato_depth * np.sin(2 * np.pi * vibrato_freq * t)

            # ë¹„ë¸Œë¼í† ë¥¼ íŒŒí˜•ì— ì ìš© (ê°„ë‹¨í•œ ê·¼ì‚¬)
            vibrato_wave = base_wave * vibrato

            # ì¶”ê°€ íš¨ê³¼: íŠ¸ë ˆëª°ë¡œ (ì§„í­ ë³€ì¡°)
            tremolo_freq = 3.0  # 3Hz íŠ¸ë ˆëª°ë¡œ
            tremolo_depth = 0.1  # 10% ì§„í­ ë³€ì¡°
            tremolo = 1 + tremolo_depth * np.sin(2 * np.pi * tremolo_freq * t)

            # íŠ¸ë ˆëª°ë¡œ ì ìš©
            final_wave = vibrato_wave * tremolo

            # ADSR ì—”ë²¨ë¡œí”„ ì ìš©
            envelope = create_adsr_envelope(attack, decay, sustain, release, duration_seconds, SAMPLE_RATE)

            # ì—”ë²¨ë¡œí”„ì™€ íŒŒí˜• ê¸¸ì´ ë§ì¶¤
            min_length = min(len(final_wave), len(envelope))
            note_audio = final_wave[:min_length] * envelope[:min_length] * volume * 0.25  # ë³¼ë¥¨ ì¡°ì ˆ

            # ì˜¤ë””ì˜¤ ë²„í¼ì— ì¶”ê°€
            start_sample = int(start_seconds * SAMPLE_RATE)
            end_sample = start_sample + len(note_audio)

            # ë²„í¼ ë²”ìœ„ ë‚´ì—ì„œë§Œ ì¶”ê°€
            if start_sample < total_samples:
                end_sample = min(end_sample, total_samples)
                audio_length = end_sample - start_sample
                if audio_length > 0:
                    audio_buffer[start_sample:end_sample] += note_audio[:audio_length]

        except Exception as e:
            print(f"ë…¸íŠ¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")
            continue

    # í´ë¦¬í•‘ ë°©ì§€ (normalize)
    max_amplitude = np.max(np.abs(audio_buffer))
    if max_amplitude > 0:
        audio_buffer = audio_buffer / max_amplitude * 0.9  # 90%ë¡œ ì œí•œ

    return audio_buffer

def audio_to_base64_wav(audio_data, sample_rate):
    """ì˜¤ë””ì˜¤ ë°ì´í„°ë¥¼ base64 ì¸ì½”ë”©ëœ WAVë¡œ ë³€í™˜"""
    if audio_data is None or len(audio_data) == 0:
        return None

    # 16ë¹„íŠ¸ PCMìœ¼ë¡œ ë³€í™˜
    audio_16bit = (audio_data * 32767).astype(np.int16)

    # WAV íŒŒì¼ì„ ë©”ëª¨ë¦¬ì— ìƒì„±
    buffer = io.BytesIO()
    with wave.open(buffer, 'wb') as wav_file:
        wav_file.setnchannels(1)  # ëª¨ë…¸
        wav_file.setsampwidth(2)  # 16ë¹„íŠ¸
        wav_file.setframerate(sample_rate)
        wav_file.writeframes(audio_16bit.tobytes())

    # base64 ì¸ì½”ë”©
    buffer.seek(0)
    wav_data = buffer.read()
    base64_data = base64.b64encode(wav_data).decode('utf-8')

    return f"data:audio/wav;base64,{base64_data}"

def calculate_waveform_data(audio_data, pixels_per_beat, tempo, target_width=1000):
    """ì˜¤ë””ì˜¤ ë°ì´í„°ë¡œë¶€í„° ì›¨ì´ë¸Œí¼ ì‹œê°í™” ë°ì´í„°ë¥¼ ê³„ì‚°"""
    if audio_data is None or len(audio_data) == 0:
        return None

    # ì˜¤ë””ì˜¤ ì´ ê¸¸ì´ (ì´ˆ)
    audio_duration = len(audio_data) / SAMPLE_RATE

    # ì´ í”½ì…€ ê¸¸ì´ ê³„ì‚° (í…œí¬ì™€ í”½ì…€ë‹¹ ë¹„íŠ¸ ê¸°ë°˜)
    total_pixels = (tempo / 60) * pixels_per_beat * audio_duration

    # ê° í”½ì…€ë‹¹ ìƒ˜í”Œ ìˆ˜ ê³„ì‚°
    samples_per_pixel = len(audio_data) / total_pixels

    waveform_points = []

    # ê° í”½ì…€ì— ëŒ€í•´ min/max ê°’ ê³„ì‚°
    for pixel in range(int(total_pixels)):
        start_sample = int(pixel * samples_per_pixel)
        end_sample = int((pixel + 1) * samples_per_pixel)
        end_sample = min(end_sample, len(audio_data))

        if start_sample >= len(audio_data):
            break

        if start_sample < end_sample:
            # í•´ë‹¹ í”½ì…€ ë²”ìœ„ì˜ ì˜¤ë””ì˜¤ ë°ì´í„°
            pixel_data = audio_data[start_sample:end_sample]

            # min, max ê°’ ê³„ì‚°
            min_val = float(np.min(pixel_data))
            max_val = float(np.max(pixel_data))

            # ì‹œê°„ ì •ë³´ (í”½ì…€ ìœ„ì¹˜)
            time_position = pixel

            waveform_points.append({
                'x': time_position,
                'min': min_val,
                'max': max_val
            })

    return waveform_points

def convert_basic(piano_roll):
    """ê¸°ë³¸ ë³€í™˜ í•¨ìˆ˜ (ì²« ë²ˆì§¸ íƒ­ìš©)"""
    print("=== Basic Convert function called ===")
    print("Received piano_roll:")
    print(piano_roll)
    print("Type:", type(piano_roll))
    return piano_roll

def synthesize_and_play(piano_roll, attack, decay, sustain, release, wave_type='complex'):
    """ì‹ ë””ì‚¬ì´ì €ë¡œ ì˜¤ë””ì˜¤ë¥¼ ìƒì„±í•˜ê³  í”¼ì•„ë…¸ë¡¤ì— ì „ë‹¬"""
    print("=== Synthesize function called ===")
    print("Piano roll data:", piano_roll)
    print(f"ADSR: A={attack}, D={decay}, S={sustain}, R={release}")
    print(f"Wave Type: {wave_type}")

    # ì˜¤ë””ì˜¤ í•©ì„±
    audio_data = synthesize_audio(piano_roll, attack, decay, sustain, release, wave_type)

    if audio_data is None:
        print("ì˜¤ë””ì˜¤ ìƒì„± ì‹¤íŒ¨")
        return piano_roll, "ì˜¤ë””ì˜¤ ìƒì„± ì‹¤íŒ¨", None

    # base64ë¡œ ë³€í™˜ (í”¼ì•„ë…¸ë¡¤ìš©)
    audio_base64 = audio_to_base64_wav(audio_data, SAMPLE_RATE)

    # gradio Audio ì»´í¬ë„ŒíŠ¸ìš© WAV íŒŒì¼ ìƒì„±
    gradio_audio_path = create_temp_wav_file(audio_data, SAMPLE_RATE)

    # í”¼ì•„ë…¸ë¡¤ ë°ì´í„°ì— ì˜¤ë””ì˜¤ ì¶”ê°€
    updated_piano_roll = piano_roll.copy() if piano_roll else {}
    updated_piano_roll['audio_data'] = audio_base64
    updated_piano_roll['use_backend_audio'] = True

    print(f"ğŸ”Š [synthesize_and_play] Setting backend audio data:")
    print(f"   - audio_data length: {len(audio_base64) if audio_base64 else 0}")
    print(f"   - use_backend_audio: {updated_piano_roll['use_backend_audio']}")
    print(f"   - audio_base64 preview: {audio_base64[:50] + '...' if audio_base64 else 'None'}")

    # ì›¨ì´ë¸Œí¼ ë°ì´í„° ê³„ì‚°
    pixels_per_beat = updated_piano_roll.get('pixelsPerBeat', 80)
    tempo = updated_piano_roll.get('tempo', 120)
    waveform_data = calculate_waveform_data(audio_data, pixels_per_beat, tempo)

    # ê³¡ì„  ë°ì´í„° ì˜ˆì‹œ (í”¼ì¹˜ ê³¡ì„  + ì›¨ì´ë¸Œí¼ ë°ì´í„°)
    curve_data = {}

    # ì›¨ì´ë¸Œí¼ ë°ì´í„° ì¶”ê°€
    if waveform_data:
        curve_data['waveform_data'] = waveform_data
        print(f"ì›¨ì´ë¸Œí¼ ë°ì´í„° ìƒì„±: {len(waveform_data)} í¬ì¸íŠ¸")

    # í”¼ì¹˜ ê³¡ì„  ë°ì´í„° (ê¸°ì¡´)
    if 'notes' in updated_piano_roll and updated_piano_roll['notes']:
        pitch_curve = []
        for note in updated_piano_roll['notes']:
            # ê°„ë‹¨í•œ ì˜ˆì‹œ: ë…¸íŠ¸ì˜ í”¼ì¹˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê³¡ì„  ìƒì„±
            base_pitch = note['pitch']
            # ì•½ê°„ì˜ ë¹„ë¸Œë¼í†  íš¨ê³¼
            curve_points = [base_pitch + 0.5 * np.sin(i * 0.5) for i in range(10)]
            pitch_curve.extend(curve_points)

        curve_data['pitch_curve'] = pitch_curve[:100]  # ìµœëŒ€ 100ê°œ í¬ì¸íŠ¸ë¡œ ì œí•œ

    updated_piano_roll['curve_data'] = curve_data

    # ì„¸ê·¸ë¨¼íŠ¸ ë°ì´í„° ì˜ˆì‹œ (ë°œìŒ íƒ€ì´ë°)
    if 'notes' in updated_piano_roll and updated_piano_roll['notes']:
        segment_data = []

        for i, note in enumerate(updated_piano_roll['notes']):
            start_seconds = (note['start'] / pixels_per_beat) * (60.0 / tempo)
            duration_seconds = (note['duration'] / pixels_per_beat) * (60.0 / tempo)

            segment_data.append({
                'start': start_seconds,
                'end': start_seconds + duration_seconds,
                'type': 'note',
                'value': note.get('lyric', f"Note_{i+1}"),
                'confidence': 0.95
            })

        updated_piano_roll['segment_data'] = segment_data

    print(f"ì˜¤ë””ì˜¤ ìƒì„± ì™„ë£Œ: {len(audio_data)} ìƒ˜í”Œ")
    if waveform_data:
        print(f"ì›¨ì´ë¸Œí¼ í¬ì¸íŠ¸: {len(waveform_data)}ê°œ")

    status_message = f"ì˜¤ë””ì˜¤ ìƒì„± ì™„ë£Œ ({wave_type} íŒŒí˜•): {len(audio_data)} ìƒ˜í”Œ, ê¸¸ì´: {len(audio_data)/SAMPLE_RATE:.2f}ì´ˆ"

    return updated_piano_roll, status_message, gradio_audio_path

def create_temp_wav_file(audio_data, sample_rate):
    """gradio Audio ì»´í¬ë„ŒíŠ¸ìš© ì„ì‹œ WAV íŒŒì¼ ìƒì„±"""
    if audio_data is None or len(audio_data) == 0:
        return None

    try:
        # 16ë¹„íŠ¸ PCMìœ¼ë¡œ ë³€í™˜
        audio_16bit = (audio_data * 32767).astype(np.int16)

        # ì„ì‹œ íŒŒì¼ ìƒì„±
        temp_fd, temp_path = tempfile.mkstemp(suffix='.wav')

        with wave.open(temp_path, 'wb') as wav_file:
            wav_file.setnchannels(1)  # ëª¨ë…¸
            wav_file.setsampwidth(2)  # 16ë¹„íŠ¸
            wav_file.setframerate(sample_rate)
            wav_file.writeframes(audio_16bit.tobytes())

        # íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° ë‹«ê¸°
        os.close(temp_fd)

        return temp_path
    except Exception as e:
        print(f"ì„ì‹œ WAV íŒŒì¼ ìƒì„± ì˜¤ë¥˜: {e}")
        return None

def clear_and_regenerate_waveform(piano_roll, attack, decay, sustain, release, wave_type='complex'):
    """ì›¨ì´ë¸Œí¼ì„ ì§€ìš°ê³  ë‹¤ì‹œ ìƒì„±"""
    print("=== Clear and Regenerate Waveform ===")

    # ë¨¼ì € ì›¨ì´ë¸Œí¼ ë°ì´í„°ë¥¼ ì§€ì›€
    cleared_piano_roll = piano_roll.copy() if piano_roll else {}
    cleared_piano_roll['curve_data'] = {}  # ê³¡ì„  ë°ì´í„° ì´ˆê¸°í™”
    cleared_piano_roll['audio_data'] = None  # ì˜¤ë””ì˜¤ ë°ì´í„° ì´ˆê¸°í™”
    cleared_piano_roll['use_backend_audio'] = False  # ë°±ì—”ë“œ ì˜¤ë””ì˜¤ ë¹„í™œì„±í™”

    # ì ì‹œ ëŒ€ê¸°ë¥¼ ìœ„í•œ ë©”ì‹œì§€
    yield cleared_piano_roll, "ì›¨ì´ë¸Œí¼ì„ ì§€ìš°ëŠ” ì¤‘...", None

    # ê·¸ ë‹¤ìŒ ìƒˆë¡œìš´ ì›¨ì´ë¸Œí¼ ìƒì„±
    result_piano_roll, status_message, gradio_audio_path = synthesize_and_play(piano_roll, attack, decay, sustain, release, wave_type)

    yield result_piano_roll, f"ì¬ìƒì„± ì™„ë£Œ! {status_message}", gradio_audio_path

# G2P (Grapheme-to-Phoneme) í•¨ìˆ˜ (ì‚¬ìš©ì ì •ì˜ ë§¤í•‘ ì‚¬ìš©)
def mock_g2p(text: str) -> str:
    """
    ì‚¬ìš©ì ì •ì˜ ë§¤í•‘ì„ ì‚¬ìš©í•˜ëŠ” í•œêµ­ì–´ G2P í•¨ìˆ˜
    """
    global user_phoneme_map

    # í…ìŠ¤íŠ¸ë¥¼ ì†Œë¬¸ìë¡œ ë³€í™˜í•˜ê³  ê³µë°± ì œê±°
    text = text.strip()

    # ì‚¬ìš©ì ì •ì˜ ë§¤í•‘ì—ì„œ ì°¾ê¸°
    if text in user_phoneme_map:
        return user_phoneme_map[text]

    # ë§¤í•‘ì— ì—†ìœ¼ë©´ ê¸€ìë³„ë¡œ ì²˜ë¦¬
    result = []
    for char in text:
        if char in user_phoneme_map:
            result.append(user_phoneme_map[char])
        else:
            # ì•Œ ìˆ˜ ì—†ëŠ” ê¸€ìëŠ” ê·¸ëŒ€ë¡œ ë°˜í™˜
            result.append(char)

    return ' '.join(result)

def process_lyric_input(piano_roll, lyric_data):
    """
    ê°€ì‚¬ ì…ë ¥ ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•˜ê³  G2Pë¥¼ ì‹¤í–‰í•˜ì—¬ phonemeì„ ìƒì„±
    """
    print("=== G2P Processing ===")
    print("Piano roll data:", piano_roll)
    print("Lyric data:", lyric_data)

    if not piano_roll or not lyric_data:
        return piano_roll, "ê°€ì‚¬ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."

    # ìƒˆë¡œìš´ ê°€ì‚¬ì— ëŒ€í•´ G2P ì‹¤í–‰
    new_lyric = lyric_data.get('newLyric', '')
    if new_lyric:
        # G2P ì‹¤í–‰ (ëª¨í‚¹ í•¨ìˆ˜ ì‚¬ìš©)
        phoneme = mock_g2p(new_lyric)
        print(f"G2P ê²°ê³¼: '{new_lyric}' -> '{phoneme}'")

        # í•´ë‹¹ ë…¸íŠ¸ì˜ phoneme ì—…ë°ì´íŠ¸
        note_id = lyric_data.get('noteId')
        if note_id and 'notes' in piano_roll:
            notes = piano_roll['notes'].copy()
            for note in notes:
                if note.get('id') == note_id:
                    note['phoneme'] = phoneme
                    print(f"ë…¸íŠ¸ {note_id}ì˜ phoneme ì—…ë°ì´íŠ¸: {phoneme}")
                    break

            # ì—…ë°ì´íŠ¸ëœ í”¼ì•„ë…¸ë¡¤ ë°ì´í„° ë°˜í™˜
            updated_piano_roll = piano_roll.copy()
            updated_piano_roll['notes'] = notes

            return updated_piano_roll, f"G2P ì™„ë£Œ: '{new_lyric}' -> [{phoneme}]"

    return piano_roll, "G2P ì²˜ë¦¬ ì™„ë£Œ"

def manual_phoneme_update(piano_roll, note_index, phoneme_text):
    """
    ìˆ˜ë™ìœ¼ë¡œ íŠ¹ì • ë…¸íŠ¸ì˜ phonemeì„ ì—…ë°ì´íŠ¸
    """
    print(f"=== Manual Phoneme Update ===")
    print(f"Note index: {note_index}, Phoneme: '{phoneme_text}'")

    if not piano_roll or 'notes' not in piano_roll:
        return piano_roll, "í”¼ì•„ë…¸ë¡¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."

    notes = piano_roll['notes'].copy()

    if 0 <= note_index < len(notes):
        notes[note_index]['phoneme'] = phoneme_text

        updated_piano_roll = piano_roll.copy()
        updated_piano_roll['notes'] = notes

        lyric = notes[note_index].get('lyric', '?')
        return updated_piano_roll, f"ë…¸íŠ¸ {note_index + 1} ('{lyric}')ì˜ phonemeì„ '{phoneme_text}'ë¡œ ì„¤ì •í–ˆìŠµë‹ˆë‹¤."
    else:
        return piano_roll, f"ì˜ëª»ëœ ë…¸íŠ¸ ì¸ë±ìŠ¤: {note_index}"

def clear_all_phonemes(piano_roll):
    """
    ëª¨ë“  ë…¸íŠ¸ì˜ phonemeì„ ì§€ìš°ê¸°
    """
    print("=== Clear All Phonemes ===")

    if not piano_roll or 'notes' not in piano_roll:
        return piano_roll, "í”¼ì•„ë…¸ë¡¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."

    notes = piano_roll['notes'].copy()

    for note in notes:
        note['phoneme'] = None

    updated_piano_roll = piano_roll.copy()
    updated_piano_roll['notes'] = notes

    return updated_piano_roll, "ëª¨ë“  phonemeì´ ì§€ì›Œì¡ŒìŠµë‹ˆë‹¤."

def auto_generate_all_phonemes(piano_roll):
    """
    ëª¨ë“  ë…¸íŠ¸ì˜ ê°€ì‚¬ì— ëŒ€í•´ ìë™ìœ¼ë¡œ phoneme ìƒì„±
    """
    print("=== Auto Generate All Phonemes ===")

    if not piano_roll or 'notes' not in piano_roll:
        return piano_roll, "í”¼ì•„ë…¸ë¡¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."

    notes = piano_roll['notes'].copy()

    updated_count = 0
    for note in notes:
        lyric = note.get('lyric')
        if lyric:
            phoneme = mock_g2p(lyric)
            note['phoneme'] = phoneme
            updated_count += 1
            print(f"ìë™ ìƒì„±: '{lyric}' -> '{phoneme}'")

    updated_piano_roll = piano_roll.copy()
    updated_piano_roll['notes'] = notes

    return updated_piano_roll, f"{updated_count}ê°œ ë…¸íŠ¸ì˜ phonemeì´ ìë™ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤."

# F0 ë¶„ì„ í•¨ìˆ˜ë“¤
def extract_f0_from_audio(audio_file_path, f0_method="pyin"):
    """
    ì˜¤ë””ì˜¤ íŒŒì¼ì—ì„œ F0(ê¸°ë³¸ ì£¼íŒŒìˆ˜)ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
    """
    if not LIBROSA_AVAILABLE:
        return None, "librosaê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•„ F0 ë¶„ì„ì„ ìˆ˜í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

    try:
        print(f"ğŸµ F0 ì¶”ì¶œ ì‹œì‘: {audio_file_path}")

        # ì˜¤ë””ì˜¤ ë¡œë“œ
        y, sr = librosa.load(audio_file_path, sr=None)
        print(f"   - ìƒ˜í”Œë ˆì´íŠ¸: {sr}Hz")
        print(f"   - ê¸¸ì´: {len(y)/sr:.2f}ì´ˆ")

        # F0 ì¶”ì¶œ ë°©ë²• ì„ íƒ
        if f0_method == "pyin":
            # PYIN ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš© (ë” ì •í™•í•˜ì§€ë§Œ ëŠë¦¼)
            f0, voiced_flag, voiced_probs = librosa.pyin(
                y,
                fmin=librosa.note_to_hz('C2'),  # ì•½ 65Hz
                fmax=librosa.note_to_hz('C7')   # ì•½ 2093Hz
            )
        else:
            # ê¸°ë³¸ í”¼ì¹˜ ì¶”ì¶œ
            pitches, magnitudes = librosa.piptrack(y=y, sr=sr)
            f0 = []
            for t in range(pitches.shape[1]):
                index = magnitudes[:, t].argmax()
                pitch = pitches[index, t]
                f0.append(pitch if pitch > 0 else np.nan)
            f0 = np.array(f0)

        # ì‹œê°„ ì¶• ê³„ì‚°
        hop_length = 512  # librosa ê¸°ë³¸ê°’
        frame_times = librosa.frames_to_time(np.arange(len(f0)), sr=sr, hop_length=hop_length)

        # NaN ê°’ ì²˜ë¦¬ ë° ìŠ¤ë¬´ë”©
        valid_indices = ~np.isnan(f0)
        if np.sum(valid_indices) == 0:
            return None, "ìœ íš¨í•œ F0 ê°’ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

        # ìœ íš¨í•œ F0 ê°’ë§Œ ì‚¬ìš©
        valid_f0 = f0[valid_indices]
        valid_times = frame_times[valid_indices]

        print(f"   - ì¶”ì¶œëœ F0 í¬ì¸íŠ¸: {len(valid_f0)}ê°œ")
        print(f"   - F0 ë²”ìœ„: {np.min(valid_f0):.1f}Hz ~ {np.max(valid_f0):.1f}Hz")

        return {
            'times': valid_times,
            'f0_values': valid_f0,
            'sample_rate': sr,
            'duration': len(y) / sr
        }, "F0 ì¶”ì¶œ ì™„ë£Œ"

    except Exception as e:
        print(f"âŒ F0 ì¶”ì¶œ ì˜¤ë¥˜: {e}")
        return None, f"F0 ì¶”ì¶œ ì˜¤ë¥˜: {str(e)}"

def create_f0_line_data(f0_data, tempo=120, pixelsPerBeat=80):
    """
    F0 ë°ì´í„°ë¥¼ LineLayerìš© line_data í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
    F0 ê³¡ì„ ì´ í”¼ì•„ë…¸ë¡¤ ê·¸ë¦¬ë“œì˜ ì •í™•í•œ í”¼ì¹˜ ìœ„ì¹˜ì— í‘œì‹œë˜ë„ë¡ ë³€í™˜í•©ë‹ˆë‹¤.
    """
    if not f0_data:
        return None

    try:
        times = f0_data['times']
        f0_values = f0_data['f0_values']

        # í”¼ì•„ë…¸ë¡¤ ìƒìˆ˜ë“¤ (GridComponentì™€ ë™ì¼)
        NOTE_HEIGHT = 20
        TOTAL_NOTES = 128

        def hz_to_midi(frequency):
            """ì£¼íŒŒìˆ˜(Hz)ë¥¼ MIDI ë…¸íŠ¸ ë²ˆí˜¸ë¡œ ë³€í™˜"""
            if frequency <= 0:
                return 0
            return 69 + 12 * np.log2(frequency / 440.0)

        def midi_to_y_coordinate(midi_note):
            """MIDI ë…¸íŠ¸ ë²ˆí˜¸ë¥¼ í”¼ì•„ë…¸ë¡¤ Y ì¢Œí‘œë¡œ ë³€í™˜ (GridComponentì™€ ë™ì¼í•œ ë°©ì‹)"""
            return (TOTAL_NOTES - 1 - midi_note) * NOTE_HEIGHT + NOTE_HEIGHT/2

        # ë°ì´í„° í¬ì¸íŠ¸ ìƒì„± (í”¼ì•„ë…¸ë¡¤ ì¢Œí‘œê³„ ì‚¬ìš©)
        data_points = []
        valid_f0_values = []

        for time, f0 in zip(times, f0_values):
            if not np.isnan(f0) and f0 > 0:
                # Hzë¥¼ MIDIë¡œ ë³€í™˜
                midi_note = hz_to_midi(f0)

                # MIDI ë²”ìœ„ ì²´í¬ (0-127)
                if 0 <= midi_note <= 127:
                    # ì‹œê°„(ì´ˆ)ì„ í”½ì…€ X ì¢Œí‘œë¡œ ë³€í™˜
                    x_pixel = time * (tempo / 60) * pixelsPerBeat

                    # MIDIë¥¼ í”¼ì•„ë…¸ë¡¤ Y ì¢Œí‘œë¡œ ë³€í™˜
                    y_pixel = midi_to_y_coordinate(midi_note)

                    data_points.append({
                        "x": float(x_pixel),
                        "y": float(y_pixel)
                    })
                    valid_f0_values.append(f0)

        if not data_points:
            print("âš ï¸ ìœ íš¨í•œ F0 ë°ì´í„° í¬ì¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return None

        # F0 ê°’ ë²”ìœ„ ì •ë³´ (í‘œì‹œìš©)
        min_f0 = float(np.min(valid_f0_values))
        max_f0 = float(np.max(valid_f0_values))
        min_midi = hz_to_midi(min_f0)
        max_midi = hz_to_midi(max_f0)

        # Y ë²”ìœ„ë¥¼ ì „ì²´ í”¼ì•„ë…¸ë¡¤ ë²”ìœ„ë¡œ ì„¤ì •
        y_min = 0
        y_max = TOTAL_NOTES * NOTE_HEIGHT

        line_data = {
            "f0_curve": {
                "color": "#FF6B6B",  # ë¹¨ê°„ìƒ‰
                "lineWidth": 3,
                "yMin": y_min,
                "yMax": y_max,
                "position": "overlay",  # ê·¸ë¦¬ë“œ ìœ„ì— ì˜¤ë²„ë ˆì´
                "renderMode": "piano_grid",  # F0 ì „ìš© ë Œë”ë§ ëª¨ë“œ
                "visible": True,
                "opacity": 0.8,
                "data": data_points,
                # ë©”íƒ€ë°ì´í„°
                "dataType": "f0",
                "unit": "Hz",
                "originalRange": {
                    "minHz": min_f0,
                    "maxHz": max_f0,
                    "minMidi": min_midi,
                    "maxMidi": max_midi
                }
            }
        }

        print(f"ğŸ“Š F0 LineData ìƒì„± ì™„ë£Œ: {len(data_points)}ê°œ í¬ì¸íŠ¸")
        print(f"   - F0 ë²”ìœ„: {min_f0:.1f}Hz ~ {max_f0:.1f}Hz")
        print(f"   - MIDI ë²”ìœ„: {min_midi:.1f} ~ {max_midi:.1f}")
        print(f"   - ë Œë”ë§ ëª¨ë“œ: í”¼ì•„ë…¸ë¡¤ ê·¸ë¦¬ë“œ ì •ë ¬")

        return line_data

    except Exception as e:
        print(f"âŒ LineData ìƒì„± ì˜¤ë¥˜: {e}")
        return None

def analyze_audio_f0(piano_roll, audio_file, f0_method="pyin"):
    """
    ì—…ë¡œë“œëœ ì˜¤ë””ì˜¤ íŒŒì¼ì—ì„œ F0ë¥¼ ì¶”ì¶œí•˜ê³  í”¼ì•„ë…¸ë¡¤ì— í‘œì‹œí•©ë‹ˆë‹¤.
    """
    print("=== F0 Analysis ===")
    print(f"Audio file: {audio_file}")
    print(f"F0 method: {f0_method}")

    if not audio_file:
        return piano_roll, "ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.", None

    if not LIBROSA_AVAILABLE:
        return piano_roll, "librosaê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•„ F0 ë¶„ì„ì„ ìˆ˜í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. 'pip install librosa'ë¡œ ì„¤ì¹˜í•´ì£¼ì„¸ìš”.", None

    try:
        # F0 ì¶”ì¶œ
        f0_data, status = extract_f0_from_audio(audio_file, f0_method)

        if f0_data is None:
            return piano_roll, f"F0 ì¶”ì¶œ ì‹¤íŒ¨: {status}", None

        # LineLayerìš© ë°ì´í„° ìƒì„±
        line_data = create_f0_line_data(f0_data, piano_roll.get('tempo', 120), piano_roll.get('pixelsPerBeat', 80))

        if line_data is None:
            return piano_roll, "LineLayer ë°ì´í„° ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", None

        # í”¼ì•„ë…¸ë¡¤ ë°ì´í„° ì—…ë°ì´íŠ¸
        updated_piano_roll = piano_roll.copy() if piano_roll else {
            "notes": [],
            "tempo": 120,
            "timeSignature": {"numerator": 4, "denominator": 4},
            "editMode": "select",
            "snapSetting": "1/4",
            "pixelsPerBeat": 80
        }

        updated_piano_roll['line_data'] = line_data

        # ë¶„ì„ ê²°ê³¼ ì •ë³´
        f0_points = len(line_data['f0_curve']['data'])
        f0_min = line_data['f0_curve']['yMin']
        f0_max = line_data['f0_curve']['yMax']
        duration = f0_data['duration']

        success_message = f"""F0 ë¶„ì„ ì™„ë£Œ!
ğŸ“Š ë°ì´í„° í¬ì¸íŠ¸: {f0_points}ê°œ
ğŸ“ˆ F0 ë²”ìœ„: {f0_min:.1f}Hz ~ {f0_max:.1f}Hz
â±ï¸ ì˜¤ë””ì˜¤ ê¸¸ì´: {duration:.2f}ì´ˆ
ğŸµ ë°©ë²•: {f0_method.upper()}"""

        return updated_piano_roll, success_message, audio_file

    except Exception as e:
        error_message = f"F0 ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}"
        print(f"âŒ {error_message}")
        return piano_roll, error_message, None

def generate_f0_demo_audio():
    """
    F0 ë¶„ì„ ë°ëª¨ìš© ê°„ë‹¨í•œ ì˜¤ë””ì˜¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    """
    print("ğŸµ F0 ë°ëª¨ ì˜¤ë””ì˜¤ ìƒì„± ì¤‘...")

    # ê°„ë‹¨í•œ ìŠ¤ìœ„í”„ í†¤ ìƒì„± (100Hzì—ì„œ 400Hzê¹Œì§€)
    duration = 3.0  # 3ì´ˆ
    sample_rate = 44100
    t = np.linspace(0, duration, int(duration * sample_rate), False)

    # ì£¼íŒŒìˆ˜ê°€ ì‹œê°„ì— ë”°ë¼ ë³€í•˜ëŠ” ì‚¬ì¸íŒŒ (100Hz -> 400Hz)
    start_freq = 100
    end_freq = 400
    instantaneous_freq = start_freq + (end_freq - start_freq) * (t / duration)

    # ì£¼íŒŒìˆ˜ ë³€ì¡°ëœ ì‚¬ì¸íŒŒ ìƒì„±
    phase = 2 * np.pi * np.cumsum(instantaneous_freq) / sample_rate
    audio = 0.3 * np.sin(phase)  # ë³¼ë¥¨ ì¡°ì ˆ

    # WAV íŒŒì¼ë¡œ ì €ì¥
    temp_fd, temp_path = tempfile.mkstemp(suffix='.wav')
    try:
        with wave.open(temp_path, 'wb') as wav_file:
            wav_file.setnchannels(1)  # ëª¨ë…¸
            wav_file.setsampwidth(2)  # 16ë¹„íŠ¸
            wav_file.setframerate(sample_rate)

            # 16ë¹„íŠ¸ PCMìœ¼ë¡œ ë³€í™˜
            audio_16bit = (audio * 32767).astype(np.int16)
            wav_file.writeframes(audio_16bit.tobytes())

        os.close(temp_fd)
        print(f"âœ… ë°ëª¨ ì˜¤ë””ì˜¤ ìƒì„± ì™„ë£Œ: {temp_path}")
        return temp_path

    except Exception as e:
        os.close(temp_fd)
        print(f"âŒ ë°ëª¨ ì˜¤ë””ì˜¤ ìƒì„± ì‹¤íŒ¨: {e}")
        return None

# Gradio ì¸í„°í˜ì´ìŠ¤
with gr.Blocks(title="PianoRoll with Synthesizer Demo") as demo:
    gr.Markdown("# ğŸ¹ Gradio PianoRoll with Synthesizer")
    gr.Markdown("í”¼ì•„ë…¸ë¡¤ ì»´í¬ë„ŒíŠ¸ì™€ ì‹ ë””ì‚¬ì´ì € ê¸°ëŠ¥ì„ í…ŒìŠ¤íŠ¸í•´ë³´ì„¸ìš”!")

    with gr.Tabs():
        # ì²« ë²ˆì§¸ íƒ­: ê¸°ë³¸ ë°ëª¨
        with gr.TabItem("ğŸ¼ Basic Demo"):
            gr.Markdown("## ê¸°ë³¸ í”¼ì•„ë…¸ë¡¤ ë°ëª¨")

            with gr.Row():
                with gr.Column():
                    # ì´ˆê¸°ê°’ ì„¤ì •
                    initial_value_basic = {
                        "notes": [
                            {
                                "start": 80,
                                "duration": 80,
                                "pitch": 60,
                                "velocity": 100,
                                "lyric": "ì•ˆë…•"
                            },
                            {
                                "start": 160,
                                "duration": 160,
                                "pitch": 64,
                                "velocity": 90,
                                "lyric": "í•˜ì„¸ìš”"
                            }
                        ],
                        "tempo": 120,
                        "timeSignature": {"numerator": 4, "denominator": 4},
                        "editMode": "select",
                        "snapSetting": "1/4"
                    }
                    piano_roll_basic = PianoRoll(
                        height=600,
                        width=1000,
                        value=initial_value_basic,
                        elem_id="piano_roll_basic",  # ê³ ìœ  ID ë¶€ì—¬
                        use_backend_audio=False  # í”„ë¡ íŠ¸ì—”ë“œ ì˜¤ë””ì˜¤ ì—”ì§„ ì‚¬ìš©
                    )

            with gr.Row():
                with gr.Column():
                    output_json_basic = gr.JSON()

            with gr.Row():
                with gr.Column():
                    btn_basic = gr.Button("ğŸ”„ Convert & Debug", variant="primary")

            # ê¸°ë³¸ íƒ­ ì´ë²¤íŠ¸
            btn_basic.click(
                fn=convert_basic,
                inputs=piano_roll_basic,
                outputs=output_json_basic,
                show_progress=True
            )

        # ë‘ ë²ˆì§¸ íƒ­: ì‹ ë””ì‚¬ì´ì € ë°ëª¨
        with gr.TabItem("ğŸµ Synthesizer Demo"):
            gr.Markdown("## ì‹ ë””ì‚¬ì´ì €ê°€ í¬í•¨ëœ í”¼ì•„ë…¸ë¡¤ ë°ëª¨")
            gr.Markdown("ë…¸íŠ¸ë¥¼ í¸ì§‘í•œ í›„ 'ğŸ¶ Synthesize Audio' ë²„íŠ¼ì„ í´ë¦­í•˜ë©´ ì˜¤ë””ì˜¤ê°€ ìƒì„±ë˜ì–´ ì¬ìƒë©ë‹ˆë‹¤!")

            with gr.Row():
                with gr.Column(scale=3):
                    # ì‹ ë””ì‚¬ì´ì €ìš© ì´ˆê¸°ê°’
                    initial_value_synth = {
                        "notes": [
                            {
                                "start": 0,
                                "duration": 160,
                                "pitch": 60,  # C4
                                "velocity": 100,
                                "lyric": "ë„"
                            },
                            {
                                "start": 160,
                                "duration": 160,
                                "pitch": 62,  # D4
                                "velocity": 100,
                                "lyric": "ë ˆ"
                            },
                            {
                                "start": 320,
                                "duration": 160,
                                "pitch": 64,  # E4
                                "velocity": 100,
                                "lyric": "ë¯¸"
                            },
                            {
                                "start": 480,
                                "duration": 160,
                                "pitch": 65,  # F4
                                "velocity": 100,
                                "lyric": "íŒŒ"
                            }
                        ],
                        "tempo": 120,
                        "timeSignature": {"numerator": 4, "denominator": 4},
                        "editMode": "select",
                        "snapSetting": "1/4",
                        "curve_data": {},  # ì´ˆê¸°ì—ëŠ” ë¹ˆ ê³¡ì„  ë°ì´í„°
                        "use_backend_audio": False  # ì´ˆê¸°ì—ëŠ” ë°±ì—”ë“œ ì˜¤ë””ì˜¤ ë¹„í™œì„±í™”
                    }
                    piano_roll_synth = PianoRoll(
                        height=600,
                        width=1000,
                        value=initial_value_synth,
                        elem_id="piano_roll_synth",  # ê³ ìœ  ID ë¶€ì—¬
                        use_backend_audio=False  # ì´ˆê¸°ì—ëŠ” í”„ë¡ íŠ¸ì—”ë“œ ì—”ì§„ ì‚¬ìš©, synthesize ì‹œ ë°±ì—”ë“œë¡œ ì „í™˜
                    )

                with gr.Column(scale=1):
                    gr.Markdown("### ğŸ›ï¸ ADSR ì„¤ì •")
                    attack_slider = gr.Slider(
                        minimum=0.001,
                        maximum=1.0,
                        value=0.01,
                        step=0.001,
                        label="Attack (ì´ˆ)"
                    )
                    decay_slider = gr.Slider(
                        minimum=0.001,
                        maximum=1.0,
                        value=0.1,
                        step=0.001,
                        label="Decay (ì´ˆ)"
                    )
                    sustain_slider = gr.Slider(
                        minimum=0.0,
                        maximum=1.0,
                        value=0.7,
                        step=0.01,
                        label="Sustain (ë ˆë²¨)"
                    )
                    release_slider = gr.Slider(
                        minimum=0.001,
                        maximum=2.0,
                        value=0.3,
                        step=0.001,
                        label="Release (ì´ˆ)"
                    )

                    gr.Markdown("### ğŸµ íŒŒí˜• ì„¤ì •")
                    wave_type_dropdown = gr.Dropdown(
                        choices=[
                            ("ë³µí•© íŒŒí˜• (Complex)", "complex"),
                            ("í•˜ëª¨ë‹‰ í•©ì„± (Harmonic)", "harmonic"),
                            ("FM í•©ì„± (FM)", "fm"),
                            ("í†±ë‹ˆíŒŒ (Sawtooth)", "sawtooth"),
                            ("ì‚¬ê°íŒŒ (Square)", "square"),
                            ("ì‚¼ê°íŒŒ (Triangle)", "triangle"),
                            ("ì‚¬ì¸íŒŒ (Sine)", "sine")
                        ],
                        value="complex",
                        label="íŒŒí˜• íƒ€ì…",
                        info="ê° ë…¸íŠ¸ëŠ” ìˆœí™˜ì ìœ¼ë¡œ ë‹¤ë¥¸ íŒŒí˜•ì„ ì‚¬ìš©í•©ë‹ˆë‹¤"
                    )

            with gr.Row():
                with gr.Column():
                    btn_synthesize = gr.Button("ğŸ¶ Synthesize Audio", variant="primary", size="lg")
                    status_text = gr.Textbox(label="ìƒíƒœ", interactive=False)

            with gr.Row():
                with gr.Column():
                    btn_regenerate = gr.Button("ğŸ”„ ì›¨ì´ë¸Œí¼ ì¬ìƒì„±", variant="secondary", size="lg")

            # ë¹„êµìš© gradio Audio ì»´í¬ë„ŒíŠ¸ ì¶”ê°€
            with gr.Row():
                with gr.Column():
                    gr.Markdown("### ğŸ”Š ë¹„êµìš© Gradio Audio ì¬ìƒ")
                    gradio_audio_output = gr.Audio(
                        label="ë°±ì—”ë“œì—ì„œ ìƒì„±ëœ ì˜¤ë””ì˜¤ (ë¹„êµìš©)",
                        type="filepath",
                        interactive=False
                    )

            with gr.Row():
                with gr.Column():
                    output_json_synth = gr.JSON(label="ê²°ê³¼ ë°ì´í„°")

            # ì‹ ë””ì‚¬ì´ì € íƒ­ ì´ë²¤íŠ¸
            btn_synthesize.click(
                fn=synthesize_and_play,
                inputs=[
                    piano_roll_synth,
                    attack_slider,
                    decay_slider,
                    sustain_slider,
                    release_slider,
                    wave_type_dropdown
                ],
                outputs=[piano_roll_synth, status_text, gradio_audio_output],
                show_progress=True
            )

            # ì›¨ì´ë¸Œí¼ ì¬ìƒì„± ë²„íŠ¼ ì´ë²¤íŠ¸
            btn_regenerate.click(
                fn=clear_and_regenerate_waveform,
                inputs=[
                    piano_roll_synth,
                    attack_slider,
                    decay_slider,
                    sustain_slider,
                    release_slider,
                    wave_type_dropdown
                ],
                outputs=[piano_roll_synth, status_text, gradio_audio_output],
                show_progress=True
            )

            # ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
            def log_play_event(event_data=None):
                print("ğŸµ Play event triggered:", event_data)
                return f"ì¬ìƒ ì‹œì‘ë¨: {event_data if event_data else 'ì¬ìƒ ì¤‘'}"

            def log_pause_event(event_data=None):
                print("â¸ï¸ Pause event triggered:", event_data)
                return f"ì¼ì‹œì •ì§€ë¨: {event_data if event_data else 'ì¼ì‹œì •ì§€'}"

            def log_stop_event(event_data=None):
                print("â¹ï¸ Stop event triggered:", event_data)
                return f"ì •ì§€ë¨: {event_data if event_data else 'ì •ì§€'}"

            piano_roll_synth.play(log_play_event, outputs=status_text)
            piano_roll_synth.pause(log_pause_event, outputs=status_text)
            piano_roll_synth.stop(log_stop_event, outputs=status_text)

            # input ì´ë²¤íŠ¸ ì²˜ë¦¬ ì¶”ê°€ (G2P ì²˜ë¦¬)
            def handle_synth_input(lyric_data):
                print("ğŸµ Synthesizer tab - Input event triggered:", lyric_data)
                return f"ê°€ì‚¬ ì…ë ¥ ê°ì§€: {lyric_data if lyric_data else 'ì…ë ¥ë¨'}"

            piano_roll_synth.input(handle_synth_input, outputs=status_text)

            # ë…¸íŠ¸ ë³€ê²½ ì‹œ JSON ì¶œë ¥ ì—…ë°ì´íŠ¸
            piano_roll_synth.change(lambda x: x, inputs=piano_roll_synth, outputs=output_json_synth)

        # ì„¸ ë²ˆì§¸ íƒ­: Phoneme ë°ëª¨
        with gr.TabItem("ğŸ—£ï¸ Phoneme Demo"):
            gr.Markdown("## ğŸ“¢ ìŒì†Œ(Phoneme) ê¸°ëŠ¥ ë°ëª¨")
            gr.Markdown("ê°€ì‚¬ë¥¼ ìˆ˜ì •í•˜ë©´ ìë™ìœ¼ë¡œ G2P(Grapheme-to-Phoneme)ê°€ ì‹¤í–‰ë˜ì–´ ìŒì†Œê°€ í‘œì‹œë©ë‹ˆë‹¤. ë˜í•œ ìˆ˜ë™ìœ¼ë¡œ ìŒì†Œë¥¼ í¸ì§‘í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.")

            with gr.Row():
                with gr.Column(scale=3):
                    # Phonemeìš© ì´ˆê¸°ê°’
                    initial_value_phoneme = {
                        "notes": [
                            {
                                "id": "note_0",
                                "start": 0,
                                "duration": 160,
                                "pitch": 60,  # C4
                                "velocity": 100,
                                "lyric": "ì•ˆë…•",
                                "phoneme": "aa n ny eo ng"  # ë¯¸ë¦¬ ì„¤ì •ëœ ìŒì†Œ
                            },
                            {
                                "id": "note_1",
                                "start": 160,
                                "duration": 160,
                                "pitch": 62,  # D4
                                "velocity": 100,
                                "lyric": "í•˜ì„¸ìš”",
                                "phoneme": "h a s e y o"
                            },
                            {
                                "id": "note_2",
                                "start": 320,
                                "duration": 160,
                                "pitch": 64,  # E4
                                "velocity": 100,
                                "lyric": "ìŒì•…",
                                "phoneme": "eu m a k"
                            },
                            {
                                "id": "note_3",
                                "start": 480,
                                "duration": 160,
                                "pitch": 65,  # F4
                                "velocity": 100,
                                "lyric": "í”¼ì•„ë…¸"
                            }
                        ],
                        "tempo": 120,
                        "timeSignature": {"numerator": 4, "denominator": 4},
                        "editMode": "select",
                        "snapSetting": "1/4"
                    }
                    piano_roll_phoneme = PianoRoll(
                        height=600,
                        width=1000,
                        value=initial_value_phoneme,
                        elem_id="piano_roll_phoneme",  # ê³ ìœ  ID ë¶€ì—¬
                        use_backend_audio=False  # í”„ë¡ íŠ¸ì—”ë“œ ì˜¤ë””ì˜¤ ì—”ì§„ ì‚¬ìš©
                    )

                with gr.Column(scale=1):
                    gr.Markdown("### ğŸ“ Phoneme ë§¤í•‘ ê´€ë¦¬")

                    # í˜„ì¬ ë§¤í•‘ ë¦¬ìŠ¤íŠ¸ í‘œì‹œ
                    phoneme_mapping_dataframe = gr.Dataframe(
                        headers=["ê°€ì‚¬", "Phoneme"],
                        datatype=["str", "str"],
                        value=get_phoneme_mapping_for_dataframe(),
                        label="í˜„ì¬ Phoneme ë§¤í•‘",
                        interactive=True,
                        wrap=True
                    )

                    gr.Markdown("#### â• ìƒˆ ë§¤í•‘ ì¶”ê°€")
                    with gr.Row():
                        add_lyric_input = gr.Textbox(
                            label="ê°€ì‚¬",
                            placeholder="ì˜ˆ: ë¼",
                            scale=1
                        )
                        add_phoneme_input = gr.Textbox(
                            label="Phoneme",
                            placeholder="ì˜ˆ: l aa",
                            scale=1
                        )
                    btn_add_mapping = gr.Button("â• ë§¤í•‘ ì¶”ê°€", variant="primary", size="sm")

                    gr.Markdown("### ğŸ”§ ì¼ê´„ ì‘ì—…")
                    with gr.Row():
                        btn_auto_generate = gr.Button("ğŸ¤– ëª¨ë“  Phoneme ìë™ ìƒì„±", variant="primary")
                        btn_clear_phonemes = gr.Button("ğŸ—‘ï¸ ëª¨ë“  Phoneme ì§€ìš°ê¸°", variant="secondary")

                    btn_reset_mapping = gr.Button("ğŸ”„ ë§¤í•‘ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹", variant="secondary")

            with gr.Row():
                with gr.Column():
                    phoneme_status_text = gr.Textbox(label="ìƒíƒœ", interactive=False)

            with gr.Row():
                with gr.Column():
                    output_json_phoneme = gr.JSON(label="Phoneme ë°ì´í„°")

            # Phoneme íƒ­ ì´ë²¤íŠ¸ ì²˜ë¦¬

            # ë§¤í•‘ ì¶”ê°€
            btn_add_mapping.click(
                fn=add_phoneme_mapping,
                inputs=[add_lyric_input, add_phoneme_input],
                outputs=[phoneme_mapping_dataframe, phoneme_status_text],
                show_progress=False
            ).then(
                fn=lambda: ["", ""],  # ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
                outputs=[add_lyric_input, add_phoneme_input]
            )

            # ë§¤í•‘ ë¦¬ì…‹
            btn_reset_mapping.click(
                fn=reset_phoneme_mapping,
                outputs=[phoneme_mapping_dataframe, phoneme_status_text],
                show_progress=False
            )

            # ê°€ì‚¬ ì…ë ¥ ì‹œ ìë™ G2P ì²˜ë¦¬
            def handle_phoneme_input_event(piano_roll_data):
                """ê°€ì‚¬ ì…ë ¥ ì´ë²¤íŠ¸ ì²˜ë¦¬ - í”¼ì•„ë…¸ë¡¤ ë³€ê²½ì‚¬í•­ì„ ê°ì§€í•˜ì—¬ phoneme ìƒì„±"""
                print("ğŸ—£ï¸ Phoneme tab - Input event triggered")
                print(f"   - Piano roll data: {type(piano_roll_data)}")

                if not piano_roll_data or 'notes' not in piano_roll_data:
                    return piano_roll_data, "í”¼ì•„ë…¸ë¡¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."

                return auto_generate_missing_phonemes(piano_roll_data)

            def auto_generate_missing_phonemes(piano_roll_data):
                """ê°€ì‚¬ê°€ ìˆì§€ë§Œ phonemeì´ ì—†ëŠ” ë…¸íŠ¸ë“¤ì— ëŒ€í•´ ìë™ìœ¼ë¡œ phoneme ìƒì„±"""
                if not piano_roll_data or 'notes' not in piano_roll_data:
                    return piano_roll_data, "í”¼ì•„ë…¸ë¡¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."

                # í˜„ì¬ notesë¥¼ ë³µì‚¬
                notes = piano_roll_data['notes'].copy()
                updated_notes = []
                changes_made = 0

                for note in notes:
                    note_copy = note.copy()

                    # ê°€ì‚¬ê°€ ìˆëŠ” ê²½ìš° ì²˜ë¦¬
                    lyric = note.get('lyric', '').strip()
                    current_phoneme = note.get('phoneme', '').strip()

                    if lyric:
                        # G2P ì‹¤í–‰í•˜ì—¬ ìƒˆë¡œìš´ phoneme ìƒì„±
                        new_phoneme = mock_g2p(lyric)

                        # ê¸°ì¡´ phonemeê³¼ ë‹¤ë¥´ê±°ë‚˜ ì—†ìœ¼ë©´ ì—…ë°ì´íŠ¸
                        if not current_phoneme or current_phoneme != new_phoneme:
                            note_copy['phoneme'] = new_phoneme
                            changes_made += 1
                            print(f"   - G2P ì ìš©: '{lyric}' -> '{new_phoneme}'")
                    else:
                        # ê°€ì‚¬ê°€ ì—†ìœ¼ë©´ phonemeë„ ì œê±°
                        if current_phoneme:
                            note_copy['phoneme'] = None
                            changes_made += 1
                            print(f"   - Phoneme ì œê±° (ê°€ì‚¬ ì—†ìŒ)")

                    updated_notes.append(note_copy)

                if changes_made > 0:
                    # ì—…ë°ì´íŠ¸ëœ í”¼ì•„ë…¸ë¡¤ ë°ì´í„° ë°˜í™˜
                    updated_piano_roll = piano_roll_data.copy()
                    updated_piano_roll['notes'] = updated_notes
                    return updated_piano_roll, f"ìë™ G2P ì™„ë£Œ: {changes_made}ê°œ ë…¸íŠ¸ ì—…ë°ì´íŠ¸"
                else:
                    return piano_roll_data, "G2P ì ìš©í•  ë³€ê²½ì‚¬í•­ì´ ì—†ìŠµë‹ˆë‹¤."

            piano_roll_phoneme.input(
                fn=handle_phoneme_input_event,
                inputs=[piano_roll_phoneme],
                outputs=[piano_roll_phoneme, phoneme_status_text],
                show_progress=False
            )

            # ë…¸íŠ¸ ë³€ê²½ ì‹œì—ë„ ìë™ phoneme ìƒì„±
            def handle_phoneme_change_event(piano_roll_data):
                """í”¼ì•„ë…¸ë¡¤ ë³€ê²½ ì‹œ ìë™ phoneme ì²˜ë¦¬"""
                return auto_generate_missing_phonemes(piano_roll_data)

            piano_roll_phoneme.change(
                fn=handle_phoneme_change_event,
                inputs=[piano_roll_phoneme],
                outputs=[piano_roll_phoneme, phoneme_status_text],
                show_progress=False
            )

            # ìë™ phoneme ìƒì„± (ìˆ˜ë™ ë²„íŠ¼)
            btn_auto_generate.click(
                fn=auto_generate_all_phonemes,
                inputs=[piano_roll_phoneme],
                outputs=[piano_roll_phoneme, phoneme_status_text],
                show_progress=True
            )

            # ëª¨ë“  phoneme ì§€ìš°ê¸°
            btn_clear_phonemes.click(
                fn=clear_all_phonemes,
                inputs=[piano_roll_phoneme],
                outputs=[piano_roll_phoneme, phoneme_status_text],
                show_progress=False
            )

            # ë…¸íŠ¸ ë³€ê²½ ì‹œ JSON ì¶œë ¥ ì—…ë°ì´íŠ¸ (ìë™ phoneme ì²˜ë¦¬ì™€ ë³„ë„ë¡œ)
            def update_json_output(piano_roll_data):
                return piano_roll_data

            piano_roll_phoneme.change(
                fn=update_json_output,
                inputs=[piano_roll_phoneme],
                outputs=[output_json_phoneme],
                show_progress=False
            )

            # ì¬ìƒ ì´ë²¤íŠ¸ ë¡œê¹…
            def log_phoneme_play_event(event_data=None):
                print("ğŸ—£ï¸ Phoneme Play event triggered:", event_data)
                return f"ì¬ìƒ ì‹œì‘: {event_data if event_data else 'ì¬ìƒ ì¤‘'}"

            def log_phoneme_pause_event(event_data=None):
                print("ğŸ—£ï¸ Phoneme Pause event triggered:", event_data)
                return f"ì¼ì‹œì •ì§€: {event_data if event_data else 'ì¼ì‹œì •ì§€'}"

            def log_phoneme_stop_event(event_data=None):
                print("ğŸ—£ï¸ Phoneme Stop event triggered:", event_data)
                return f"ì •ì§€: {event_data if event_data else 'ì •ì§€'}"

            piano_roll_phoneme.play(log_phoneme_play_event, outputs=phoneme_status_text)
            piano_roll_phoneme.pause(log_phoneme_pause_event, outputs=phoneme_status_text)
            piano_roll_phoneme.stop(log_phoneme_stop_event, outputs=phoneme_status_text)

        # ë„¤ ë²ˆì§¸ íƒ­: F0 ë¶„ì„ ë°ëª¨
        with gr.TabItem("ğŸ“Š F0 Analysis Demo"):
            gr.Markdown("## ğŸµ F0 (Fundamental Frequency) ë¶„ì„ ë°ëª¨")
            if LIBROSA_AVAILABLE:
                gr.Markdown("ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê³  F0ë¥¼ ì¶”ì¶œí•˜ì—¬ í”¼ì•„ë…¸ë¡¤ì—ì„œ ì‹œê°í™”í•´ë³´ì„¸ìš”!")
            else:
                gr.Markdown("âš ï¸ **librosaê°€ ì„¤ì¹˜ë˜ì§€ ì•ŠìŒ**: F0 ë¶„ì„ì„ ìœ„í•´ `pip install librosa`ë¥¼ ì‹¤í–‰í•´ì£¼ì„¸ìš”.")

            with gr.Row():
                with gr.Column(scale=3):
                    # F0ìš© ì´ˆê¸°ê°’ (ë¹ˆ í”¼ì•„ë…¸ë¡¤)
                    initial_value_f0 = {
                        "notes": [],
                        "tempo": 120,
                        "timeSignature": {"numerator": 4, "denominator": 4},
                        "editMode": "select",
                        "snapSetting": "1/4",
                        "pixelsPerBeat": 80
                    }
                    piano_roll_f0 = PianoRoll(
                        height=600,
                        width=1000,
                        value=initial_value_f0,
                        elem_id="piano_roll_f0",  # ê³ ìœ  ID ë¶€ì—¬
                        use_backend_audio=False  # í”„ë¡ íŠ¸ì—”ë“œ ì˜¤ë””ì˜¤ ì—”ì§„ ì‚¬ìš©
                    )

                with gr.Column(scale=1):
                    gr.Markdown("### ğŸ¤ ì˜¤ë””ì˜¤ ì—…ë¡œë“œ")

                    audio_input = gr.Audio(
                        label="ë¶„ì„í•  ì˜¤ë””ì˜¤ íŒŒì¼",
                        type="filepath",
                        interactive=True
                    )

                    gr.Markdown("### âš™ï¸ F0 ì¶”ì¶œ ì„¤ì •")
                    f0_method_dropdown = gr.Dropdown(
                        choices=[
                            ("PYIN (ì •í™•í•¨, ëŠë¦¼)", "pyin"),
                            ("PipTrack (ë¹ ë¦„, ëœ ì •í™•)", "piptrack")
                        ],
                        value="pyin",
                        label="F0 ì¶”ì¶œ ë°©ë²•"
                    )
                    gr.Markdown("ğŸ’¡ **PYIN**ì€ ë” ì •í™•í•˜ì§€ë§Œ ì²˜ë¦¬ ì‹œê°„ì´ ê¸¸ì–´ì§‘ë‹ˆë‹¤.")

                    btn_analyze_f0 = gr.Button(
                        "ğŸ”¬ F0 ë¶„ì„ ì‹œì‘",
                        variant="primary",
                        size="lg",
                        interactive=LIBROSA_AVAILABLE
                    )

                    btn_generate_demo = gr.Button(
                        "ğŸµ ë°ëª¨ ì˜¤ë””ì˜¤ ìƒì„±",
                        variant="secondary"
                    )
                    gr.Markdown("ğŸ“„ F0ê°€ ì‹œê°„ì— ë”°ë¼ ë³€í•˜ëŠ” í…ŒìŠ¤íŠ¸ ì˜¤ë””ì˜¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.")

                    if not LIBROSA_AVAILABLE:
                        gr.Markdown("âš ï¸ librosaê°€ í•„ìš”í•©ë‹ˆë‹¤")

            with gr.Row():
                with gr.Column():
                    f0_status_text = gr.Textbox(
                        label="ë¶„ì„ ìƒíƒœ",
                        interactive=False,
                        lines=6
                    )

            with gr.Row():
                with gr.Column():
                    # ë¹„êµìš© ì˜¤ë””ì˜¤ ì¬ìƒ
                    reference_audio = gr.Audio(
                        label="ì›ë³¸ ì˜¤ë””ì˜¤ (ì°¸ê³ ìš©)",
                        type="filepath",
                        interactive=False
                    )

            with gr.Row():
                with gr.Column():
                    output_json_f0 = gr.JSON(label="F0 ë¶„ì„ ê²°ê³¼")

            # F0 íƒ­ ì´ë²¤íŠ¸ ì²˜ë¦¬

            # F0 ë¶„ì„ ë²„íŠ¼
            btn_analyze_f0.click(
                fn=analyze_audio_f0,
                inputs=[piano_roll_f0, audio_input, f0_method_dropdown],
                outputs=[piano_roll_f0, f0_status_text, reference_audio],
                show_progress=True
            )

            # ë°ëª¨ ì˜¤ë””ì˜¤ ìƒì„± ë²„íŠ¼
            def create_and_analyze_demo():
                """ë°ëª¨ ì˜¤ë””ì˜¤ë¥¼ ìƒì„±í•˜ê³  ìë™ìœ¼ë¡œ F0 ë¶„ì„ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤."""
                demo_audio_path = generate_f0_demo_audio()
                if demo_audio_path:
                    # ì´ˆê¸° í”¼ì•„ë…¸ë¡¤ ë°ì´í„°
                    initial_piano_roll = {
                        "notes": [],
                        "tempo": 120,
                        "timeSignature": {"numerator": 4, "denominator": 4},
                        "editMode": "select",
                        "snapSetting": "1/4",
                        "pixelsPerBeat": 80
                    }

                    # F0 ë¶„ì„ ìˆ˜í–‰
                    updated_piano_roll, status, _ = analyze_audio_f0(initial_piano_roll, demo_audio_path, "pyin")

                    return updated_piano_roll, status, demo_audio_path, demo_audio_path
                else:
                    return initial_value_f0, "ë°ëª¨ ì˜¤ë””ì˜¤ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", None, None

            btn_generate_demo.click(
                fn=create_and_analyze_demo,
                outputs=[piano_roll_f0, f0_status_text, audio_input, reference_audio],
                show_progress=True
            )

            # ë…¸íŠ¸ ë³€ê²½ ì‹œ JSON ì¶œë ¥ ì—…ë°ì´íŠ¸
            def update_f0_json_output(piano_roll_data):
                return piano_roll_data

            piano_roll_f0.change(
                fn=update_f0_json_output,
                inputs=[piano_roll_f0],
                outputs=[output_json_f0],
                show_progress=False
            )

            # ì¬ìƒ ì´ë²¤íŠ¸ ë¡œê¹…
            def log_f0_play_event(event_data=None):
                print("ğŸ“Š F0 Play event triggered:", event_data)
                return f"ì¬ìƒ ì‹œì‘: {event_data if event_data else 'ì¬ìƒ ì¤‘'}"

            def log_f0_pause_event(event_data=None):
                print("ğŸ“Š F0 Pause event triggered:", event_data)
                return f"ì¼ì‹œì •ì§€: {event_data if event_data else 'ì¼ì‹œì •ì§€'}"

            def log_f0_stop_event(event_data=None):
                print("ğŸ“Š F0 Stop event triggered:", event_data)
                return f"ì •ì§€: {event_data if event_data else 'ì •ì§€'}"

            piano_roll_f0.play(log_f0_play_event, outputs=f0_status_text)
            piano_roll_f0.pause(log_f0_pause_event, outputs=f0_status_text)
            piano_roll_f0.stop(log_f0_stop_event, outputs=f0_status_text)

if __name__ == "__main__":
    demo.launch()

```

## `PianoRoll`

### Initialization

<table>
<thead>
<tr>
<th align="left">name</th>
<th align="left" style="width: 25%;">type</th>
<th align="left">default</th>
<th align="left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>value</code></td>
<td align="left" style="width: 25%;">

```python
dict | None
```

</td>
<td align="left"><code>None</code></td>
<td align="left">default MIDI notes data to provide in piano roll. If a function is provided, the function will be called each time the app loads to set the initial value of this component.</td>
</tr>

<tr>
<td align="left"><code>audio_data</code></td>
<td align="left" style="width: 25%;">

```python
str | None
```

</td>
<td align="left"><code>None</code></td>
<td align="left">ë°±ì—”ë“œì—ì„œ ì „ë‹¬ë°›ì€ ì˜¤ë””ì˜¤ ë°ì´í„° (base64 ì¸ì½”ë”©ëœ ì˜¤ë””ì˜¤ ë˜ëŠ” URL)</td>
</tr>

<tr>
<td align="left"><code>curve_data</code></td>
<td align="left" style="width: 25%;">

```python
dict | None
```

</td>
<td align="left"><code>None</code></td>
<td align="left">ë°±ì—”ë“œì—ì„œ ì „ë‹¬ë°›ì€ ì„ í˜• ë°ì´í„° (í”¼ì¹˜ ê³¡ì„ , loudness ê³¡ì„  ë“±)</td>
</tr>

<tr>
<td align="left"><code>segment_data</code></td>
<td align="left" style="width: 25%;">

```python
list | None
```

</td>
<td align="left"><code>None</code></td>
<td align="left">ë°±ì—”ë“œì—ì„œ ì „ë‹¬ë°›ì€ êµ¬ê°„ ë°ì´í„° (ë°œìŒ íƒ€ì´ë° ë“±)</td>
</tr>

<tr>
<td align="left"><code>use_backend_audio</code></td>
<td align="left" style="width: 25%;">

```python
bool
```

</td>
<td align="left"><code>False</code></td>
<td align="left">ë°±ì—”ë“œ ì˜¤ë””ì˜¤ë¥¼ ì‚¬ìš©í• ì§€ ì—¬ë¶€ (Trueì‹œ í”„ë¡ íŠ¸ì—”ë“œ ì˜¤ë””ì˜¤ ì—”ì§„ ë¹„í™œì„±í™”)</td>
</tr>

<tr>
<td align="left"><code>label</code></td>
<td align="left" style="width: 25%;">

```python
str | I18nData | None
```

</td>
<td align="left"><code>None</code></td>
<td align="left">the label for this component, displayed above the component if `show_label` is `True` and is also used as the header if there are a table of examples for this component. If None and used in a `gr.Interface`, the label will be the name of the parameter this component corresponds to.</td>
</tr>

<tr>
<td align="left"><code>every</code></td>
<td align="left" style="width: 25%;">

```python
"Timer | float | None"
```

</td>
<td align="left"><code>None</code></td>
<td align="left">Continously calls `value` to recalculate it if `value` is a function (has no effect otherwise). Can provide a Timer whose tick resets `value`, or a float that provides the regular interval for the reset Timer.</td>
</tr>

<tr>
<td align="left"><code>inputs</code></td>
<td align="left" style="width: 25%;">

```python
Component | Sequence[Component] | set[Component] | None
```

</td>
<td align="left"><code>None</code></td>
<td align="left">Components that are used as inputs to calculate `value` if `value` is a function (has no effect otherwise). `value` is recalculated any time the inputs change.</td>
</tr>

<tr>
<td align="left"><code>show_label</code></td>
<td align="left" style="width: 25%;">

```python
bool | None
```

</td>
<td align="left"><code>None</code></td>
<td align="left">if True, will display label.</td>
</tr>

<tr>
<td align="left"><code>scale</code></td>
<td align="left" style="width: 25%;">

```python
int | None
```

</td>
<td align="left"><code>None</code></td>
<td align="left">relative size compared to adjacent Components. For example if Components A and B are in a Row, and A has scale=2, and B has scale=1, A will be twice as wide as B. Should be an integer. scale applies in Rows, and to top-level Components in Blocks where fill_height=True.</td>
</tr>

<tr>
<td align="left"><code>min_width</code></td>
<td align="left" style="width: 25%;">

```python
int
```

</td>
<td align="left"><code>160</code></td>
<td align="left">minimum pixel width, will wrap if not sufficient screen space to satisfy this value. If a certain scale value results in this Component being narrower than min_width, the min_width parameter will be respected first.</td>
</tr>

<tr>
<td align="left"><code>interactive</code></td>
<td align="left" style="width: 25%;">

```python
bool | None
```

</td>
<td align="left"><code>None</code></td>
<td align="left">if True, will be rendered as an editable piano roll; if False, editing will be disabled. If not provided, this is inferred based on whether the component is used as an input or output.</td>
</tr>

<tr>
<td align="left"><code>visible</code></td>
<td align="left" style="width: 25%;">

```python
bool
```

</td>
<td align="left"><code>True</code></td>
<td align="left">If False, component will be hidden.</td>
</tr>

<tr>
<td align="left"><code>elem_id</code></td>
<td align="left" style="width: 25%;">

```python
str | None
```

</td>
<td align="left"><code>None</code></td>
<td align="left">An optional string that is assigned as the id of this component in the HTML DOM. Can be used for targeting CSS styles.</td>
</tr>

<tr>
<td align="left"><code>elem_classes</code></td>
<td align="left" style="width: 25%;">

```python
list[str] | str | None
```

</td>
<td align="left"><code>None</code></td>
<td align="left">An optional list of strings that are assigned as the classes of this component in the HTML DOM. Can be used for targeting CSS styles.</td>
</tr>

<tr>
<td align="left"><code>render</code></td>
<td align="left" style="width: 25%;">

```python
bool
```

</td>
<td align="left"><code>True</code></td>
<td align="left">If False, component will not render be rendered in the Blocks context. Should be used if the intention is to assign event listeners now but render the component later.</td>
</tr>

<tr>
<td align="left"><code>key</code></td>
<td align="left" style="width: 25%;">

```python
int | str | tuple[int | str, ...] | None
```

</td>
<td align="left"><code>None</code></td>
<td align="left">in a gr.render, Components with the same key across re-renders are treated as the same component, not a new component. Properties set in 'preserved_by_key' are not reset across a re-render.</td>
</tr>

<tr>
<td align="left"><code>preserved_by_key</code></td>
<td align="left" style="width: 25%;">

```python
list[str] | str | None
```

</td>
<td align="left"><code>"value"</code></td>
<td align="left">A list of parameters from this component's constructor. Inside a gr.render() function, if a component is re-rendered with the same key, these (and only these) parameters will be preserved in the UI (if they have been changed by the user or an event listener) instead of re-rendered based on the values provided during constructor.</td>
</tr>

<tr>
<td align="left"><code>width</code></td>
<td align="left" style="width: 25%;">

```python
int | None
```

</td>
<td align="left"><code>1000</code></td>
<td align="left">width of the piano roll component in pixels.</td>
</tr>

<tr>
<td align="left"><code>height</code></td>
<td align="left" style="width: 25%;">

```python
int | None
```

</td>
<td align="left"><code>600</code></td>
<td align="left">height of the piano roll component in pixels.</td>
</tr>
</tbody></table>


### Events

| name | description |
|:-----|:------------|
| `change` | Triggered when the value of the PianoRoll changes either because of user input (e.g. a user types in a textbox) OR because of a function update (e.g. an image receives a value from the output of an event trigger). See `.input()` for a listener that is only triggered by user input. |
| `input` | This listener is triggered when the user changes the value of the PianoRoll. |
| `play` | This listener is triggered when the user plays the media in the PianoRoll. |
| `pause` | This listener is triggered when the media in the PianoRoll stops for any reason. |
| `stop` | This listener is triggered when the user reaches the end of the media playing in the PianoRoll. |
| `clear` | This listener is triggered when the user clears the PianoRoll using the clear button for the component. |



