from typing import Optional, List

import shap
import numpy as np
import pandas as pd
from sklearn.base import BaseEstimator, TransformerMixin


class _PyBoostWrapper(BaseEstimator, TransformerMixin):
    """A universal estimator wrapper for PyBoost used for validation testing and report preparation.

    This wrapper facilitates the integration of PyBoost estimators with scikit-learn pipelines,
    enabling feature selection and handling of categorical features.

    Args:
        estimator (callable): The estimator object after applying the `fit` method.
        used_features (Optional[List[str]], optional): List of feature names to be used. Defaults to None.
        categorical_features (Optional[List[str]], optional): List of categorical feature names. Defaults to None.
        task (str, optional): The type of task, e.g., "binary", "multiclass". Defaults to "binary".
        metric_name (str, optional): The name of the evaluation metric. Defaults to "gini".
    """

    def __init__(
        self,
        estimator: callable,
        used_features: Optional[List[str]] = None,
        categorical_features: Optional[List[str]] = None,
        task: str = "binary",
        metric_name: str = "gini",
    ):
        self.estimator = estimator
        self.used_features = used_features
        self.categorical_features = categorical_features
        self.task = task
        self.metric_name = metric_name

    def _validate_input_data(self, X: pd.DataFrame) -> pd.DataFrame:
        """Prepare the input data by selecting the required features for the model.

        This method filters the input DataFrame to include only the specified used features.
        If no features are specified, it returns a copy of the original DataFrame.

        Args:
            X (pd.DataFrame): The feature matrix to be used by the model.

        Returns:
            pd.DataFrame: The transformed feature matrix ready for model input.
        """
        if self.used_features:
            X_ = X[self.used_features]
        else:
            X_ = X.copy()

        return X_

    @property
    def get_estimator_params(self) -> dict:
        """Retrieve the hyperparameters of the estimator.

        This property fetches all hyperparameters of the underlying estimator and
        adds the evaluation metric to the parameter dictionary.

        Returns:
            dict: A dictionary containing the estimator's hyperparameters.
        """
        params = self.estimator.get_all_params()
        params["eval_metric"] = self.metric_name.upper()
        return params

    def get_shap_importance(self, X: pd.DataFrame) -> pd.DataFrame:
        """Calculate feature importance based on SHAP values.

        This method computes the SHAP values for the input features and summarizes
        the importance of each feature by averaging the absolute SHAP values.

        Args:
            X (pd.DataFrame): The feature matrix used to calculate feature importance.

        Returns:
            tuple:
                - np.array: The SHAP values for each sample and feature.
                - pd.DataFrame: A DataFrame containing feature names and their corresponding importance scores.

        Raises:
            ValueError: If the SHAP values cannot be computed.
        """
        x = self._validate_input_data(X)
        explainer = shap.TreeExplainer(self.estimator)
        shap_values = explainer.shap_values(x)

        if isinstance(shap_values, list):
            shap_values = shap_values[0]

        shap_importance = pd.DataFrame(
            {
                "feature": list(x.columns),
                "importance": np.round(np.abs(shap_values).mean(axis=0), 5),
            }
        )
        shap_importance = shap_importance.sort_values(by="importance", ascending=False)
        shap_importance = shap_importance.reset_index(drop=True)

        return shap_values, shap_importance

    def transform(self, X: pd.DataFrame) -> np.ndarray:
        """Apply the estimator to the input data and generate predictions.

        This method transforms the input data using the underlying estimator. Depending
        on the estimator's capabilities, it may return transformed features, probability
        estimates, or direct predictions.

        Args:
            X (pd.DataFrame): The feature matrix to be transformed or used for prediction.

        Returns:
            np.ndarray: The predictions generated by the estimator.

        Raises:
            AttributeError: If the estimator does not have the required prediction methods.
        """
        data = self._validate_input_data(X)
        if hasattr(self.estimator, "transform"):
            return self.estimator.transform(data)
        elif hasattr(self.estimator, "predict_proba"):
            predicts = self.estimator.predict_proba(data)
            return (
                predicts
                if self.task in ("multiclass", "multilabel")
                else predicts[:, 1]
            )
        else:
            return self.estimator.predict(data)