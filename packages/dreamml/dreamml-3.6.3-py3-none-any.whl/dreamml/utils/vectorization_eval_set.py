from copy import deepcopy
import pandas as pd
from typing import Dict, Tuple


def get_eval_set_with_embeddings(
    vectorizer, eval_set: Dict[str, Tuple[pd.DataFrame, pd.Series]]
):
    """
    Enhances the evaluation set by adding embeddings generated by the provided vectorizer.

    This function iterates over each sample in the evaluation set, transforms the input features
    using the specified vectorizer, and appends the resulting embeddings to the original features
    if the vectorizer is not a Bag of Words (BOW) model. For BOW vectorizers, it replaces the original
    features with the embeddings.

    Args:
        vectorizer: An object that transforms input features into embeddings. It must have a `transform`
            method and a `name` attribute to identify the type of vectorizer.
        eval_set (Dict[str, Tuple[pd.DataFrame, pd.Series]]): A dictionary where each key is a sample
            name and each value is a tuple containing a DataFrame of input features and a Series of
            target labels.

    Returns:
        Dict[str, Tuple[pd.DataFrame, pd.Series]]: The updated evaluation set with embeddings added
            to each sample's input features.

    Raises:
        AttributeError: If the vectorizer does not have the required `transform` method or `name` attribute.
        ValueError: If there is a mismatch in the dimensions when concatenating DataFrames.
        TypeError: If the input types of `eval_set` do not match the expected types.
    """
    for sample_name, (X_sample, y_sample) in eval_set.items():
        embeddings_df = vectorizer.transform(X_sample)
        if vectorizer.name == "bow":
            eval_set[sample_name] = (embeddings_df, y_sample)
            continue
        X_sample = pd.concat([X_sample, embeddings_df], axis=1)
        eval_set[sample_name] = (X_sample, y_sample)
    return eval_set