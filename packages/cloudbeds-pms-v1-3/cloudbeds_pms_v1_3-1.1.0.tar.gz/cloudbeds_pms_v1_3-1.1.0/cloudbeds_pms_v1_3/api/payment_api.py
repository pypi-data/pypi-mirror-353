# coding: utf-8

"""
    Cloudbeds API

    <p>     Welcome to the documentation for <strong>Cloudbeds API Version v1.3</strong>!     If you are looking to learn how to use the Cloudbeds API to access guest information, reservations, or similar data     for your Cloudbeds customers, then you've come to the right place. </p>  <p>     In this document you will find all the API methods we provide along with explanations for parameters and response     examples. </p>  <p>     If you have questions about different implementation steps (e.g. how to implement OAuth 2.0), please refer to our     <a href=\"https://integrations.cloudbeds.com/hc/en-us\">Integrations Portal</a>. </p>  <p>     Be sure to <a href=\"https://go.pardot.com/l/308041/2018-07-24/qb2lg\">subscribe</a> to the monthly     Cloudbeds API announcement mailing list to receive information on new additions and improvements to the     Cloudbeds API and related developer tools. </p>  <p>     <strong>Endpoint:</strong> https://api.cloudbeds.com/api/v1.3/{method} </p>  <p>     <strong>HTTPS:</strong> Our API requires HTTPS. We'll respond with an appropriate error if you're not using it. </p>  <p>     <strong>Request Format:</strong> HTTP GET, POST and PUT (Content-Type: application/x-www-form-urlencoded) </p>  <p>     <strong>Response Format:</strong> JSON </p>  <p>     <strong>Response Header:</strong> X-Request-ID is added to response headers in all calls to help accelerate support     and troubleshooting. </p>  <p>     <strong>         <a href=\"https://integrations.cloudbeds.com/hc/en-us/articles/14104678058267-API-Documentation#postman-collection\">             <img src=\"https://run.pstmn.io/button.svg\" alt=\"Run in Postman\">         </a>     </strong> use this link to access our Public collection in Postman. </p>

    The version of the OpenAPI document: v1.3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import date, datetime
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Optional, Union
from typing_extensions import Annotated
from cloudbeds_pms_v1_3.models.get_payment_methods_response import GetPaymentMethodsResponse
from cloudbeds_pms_v1_3.models.get_payments_capabilities_response import GetPaymentsCapabilitiesResponse
from cloudbeds_pms_v1_3.models.get_payments_response import GetPaymentsResponse
from cloudbeds_pms_v1_3.models.get_pending_transactions_response import GetPendingTransactionsResponse
from cloudbeds_pms_v1_3.models.post_card_response import PostCardResponse
from cloudbeds_pms_v1_3.models.post_charge_response import PostChargeResponse
from cloudbeds_pms_v1_3.models.post_custom_payment_method_response import PostCustomPaymentMethodResponse
from cloudbeds_pms_v1_3.models.post_payment_cash_response import PostPaymentCashResponse
from cloudbeds_pms_v1_3.models.post_payment_credit_card_response import PostPaymentCreditCardResponse
from cloudbeds_pms_v1_3.models.post_payment_response import PostPaymentResponse
from cloudbeds_pms_v1_3.models.post_void_payment_response import PostVoidPaymentResponse

from cloudbeds_pms_v1_3.api_client import ApiClient, RequestSerialized
from cloudbeds_pms_v1_3.api_response import ApiResponse
from cloudbeds_pms_v1_3.rest import RESTResponseType


class PaymentApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_payment_methods_get(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="ID for the property to be queried")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="Language that payment methods name should return (if available).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetPaymentMethodsResponse:
        """getPaymentMethods

        Get a list of active methods for a property, or list of properties

        :param property_id: ID for the property to be queried
        :type property_id: str
        :param lang: Language that payment methods name should return (if available).
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_payment_methods_get_serialize(
            property_id=property_id,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPaymentMethodsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_payment_methods_get_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="ID for the property to be queried")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="Language that payment methods name should return (if available).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetPaymentMethodsResponse]:
        """getPaymentMethods

        Get a list of active methods for a property, or list of properties

        :param property_id: ID for the property to be queried
        :type property_id: str
        :param lang: Language that payment methods name should return (if available).
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_payment_methods_get_serialize(
            property_id=property_id,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPaymentMethodsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_payment_methods_get_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="ID for the property to be queried")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="Language that payment methods name should return (if available).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getPaymentMethods

        Get a list of active methods for a property, or list of properties

        :param property_id: ID for the property to be queried
        :type property_id: str
        :param lang: Language that payment methods name should return (if available).
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_payment_methods_get_serialize(
            property_id=property_id,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPaymentMethodsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_payment_methods_get_serialize(
        self,
        property_id,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getPaymentMethods',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_payments_capabilities_get(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="ID for the property to be queried")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetPaymentsCapabilitiesResponse:
        """getPaymentsCapabilities

        Lists the payment capabilities of a given property

        :param property_id: ID for the property to be queried
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_payments_capabilities_get_serialize(
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPaymentsCapabilitiesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_payments_capabilities_get_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="ID for the property to be queried")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetPaymentsCapabilitiesResponse]:
        """getPaymentsCapabilities

        Lists the payment capabilities of a given property

        :param property_id: ID for the property to be queried
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_payments_capabilities_get_serialize(
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPaymentsCapabilitiesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_payments_capabilities_get_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="ID for the property to be queried")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getPaymentsCapabilities

        Lists the payment capabilities of a given property

        :param property_id: ID for the property to be queried
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_payments_capabilities_get_serialize(
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPaymentsCapabilitiesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_payments_capabilities_get_serialize(
        self,
        property_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getPaymentsCapabilities',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_payments_get(
        self,
        reservation_id: Annotated[StrictStr, Field(description="¹ ID for the reservation to be queried.")],
        house_account_id: Annotated[StrictStr, Field(description="¹ ID for the house account to be queried.")],
        guest_id: Annotated[StrictStr, Field(description="¹ ID for the guest to be queried.")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        created_from: Annotated[Optional[datetime], Field(description="Datetime (lower limit) to be queried. If not sent, and reservationID informed, will use reservation date. In other cases, current date -7 days is used.")] = None,
        created_to: Annotated[Optional[datetime], Field(description="Datetime (upper limit) to be queried. If not sent, and reservationID informed, will use check-out date. In other cases, current date is used.")] = None,
        include_payment_allocation: Annotated[Optional[StrictBool], Field(description="Adds payment allocation to response, when available.")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Page size")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetPaymentsResponse:
        """getPayments

        Get a list of transactions for a reservation/house account/guest, with its respective payment allocation<br /> ¹ one of these fields are required ² only if data.isAllocated = true (and includePaymentAllocation = true)

        :param reservation_id: ¹ ID for the reservation to be queried. (required)
        :type reservation_id: str
        :param house_account_id: ¹ ID for the house account to be queried. (required)
        :type house_account_id: str
        :param guest_id: ¹ ID for the guest to be queried. (required)
        :type guest_id: str
        :param property_id: Property ID
        :type property_id: str
        :param created_from: Datetime (lower limit) to be queried. If not sent, and reservationID informed, will use reservation date. In other cases, current date -7 days is used.
        :type created_from: datetime
        :param created_to: Datetime (upper limit) to be queried. If not sent, and reservationID informed, will use check-out date. In other cases, current date is used.
        :type created_to: datetime
        :param include_payment_allocation: Adds payment allocation to response, when available.
        :type include_payment_allocation: bool
        :param page_number: Page number
        :type page_number: int
        :param page_size: Page size
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_payments_get_serialize(
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            guest_id=guest_id,
            property_id=property_id,
            created_from=created_from,
            created_to=created_to,
            include_payment_allocation=include_payment_allocation,
            page_number=page_number,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPaymentsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_payments_get_with_http_info(
        self,
        reservation_id: Annotated[StrictStr, Field(description="¹ ID for the reservation to be queried.")],
        house_account_id: Annotated[StrictStr, Field(description="¹ ID for the house account to be queried.")],
        guest_id: Annotated[StrictStr, Field(description="¹ ID for the guest to be queried.")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        created_from: Annotated[Optional[datetime], Field(description="Datetime (lower limit) to be queried. If not sent, and reservationID informed, will use reservation date. In other cases, current date -7 days is used.")] = None,
        created_to: Annotated[Optional[datetime], Field(description="Datetime (upper limit) to be queried. If not sent, and reservationID informed, will use check-out date. In other cases, current date is used.")] = None,
        include_payment_allocation: Annotated[Optional[StrictBool], Field(description="Adds payment allocation to response, when available.")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Page size")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetPaymentsResponse]:
        """getPayments

        Get a list of transactions for a reservation/house account/guest, with its respective payment allocation<br /> ¹ one of these fields are required ² only if data.isAllocated = true (and includePaymentAllocation = true)

        :param reservation_id: ¹ ID for the reservation to be queried. (required)
        :type reservation_id: str
        :param house_account_id: ¹ ID for the house account to be queried. (required)
        :type house_account_id: str
        :param guest_id: ¹ ID for the guest to be queried. (required)
        :type guest_id: str
        :param property_id: Property ID
        :type property_id: str
        :param created_from: Datetime (lower limit) to be queried. If not sent, and reservationID informed, will use reservation date. In other cases, current date -7 days is used.
        :type created_from: datetime
        :param created_to: Datetime (upper limit) to be queried. If not sent, and reservationID informed, will use check-out date. In other cases, current date is used.
        :type created_to: datetime
        :param include_payment_allocation: Adds payment allocation to response, when available.
        :type include_payment_allocation: bool
        :param page_number: Page number
        :type page_number: int
        :param page_size: Page size
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_payments_get_serialize(
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            guest_id=guest_id,
            property_id=property_id,
            created_from=created_from,
            created_to=created_to,
            include_payment_allocation=include_payment_allocation,
            page_number=page_number,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPaymentsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_payments_get_without_preload_content(
        self,
        reservation_id: Annotated[StrictStr, Field(description="¹ ID for the reservation to be queried.")],
        house_account_id: Annotated[StrictStr, Field(description="¹ ID for the house account to be queried.")],
        guest_id: Annotated[StrictStr, Field(description="¹ ID for the guest to be queried.")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        created_from: Annotated[Optional[datetime], Field(description="Datetime (lower limit) to be queried. If not sent, and reservationID informed, will use reservation date. In other cases, current date -7 days is used.")] = None,
        created_to: Annotated[Optional[datetime], Field(description="Datetime (upper limit) to be queried. If not sent, and reservationID informed, will use check-out date. In other cases, current date is used.")] = None,
        include_payment_allocation: Annotated[Optional[StrictBool], Field(description="Adds payment allocation to response, when available.")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Page size")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getPayments

        Get a list of transactions for a reservation/house account/guest, with its respective payment allocation<br /> ¹ one of these fields are required ² only if data.isAllocated = true (and includePaymentAllocation = true)

        :param reservation_id: ¹ ID for the reservation to be queried. (required)
        :type reservation_id: str
        :param house_account_id: ¹ ID for the house account to be queried. (required)
        :type house_account_id: str
        :param guest_id: ¹ ID for the guest to be queried. (required)
        :type guest_id: str
        :param property_id: Property ID
        :type property_id: str
        :param created_from: Datetime (lower limit) to be queried. If not sent, and reservationID informed, will use reservation date. In other cases, current date -7 days is used.
        :type created_from: datetime
        :param created_to: Datetime (upper limit) to be queried. If not sent, and reservationID informed, will use check-out date. In other cases, current date is used.
        :type created_to: datetime
        :param include_payment_allocation: Adds payment allocation to response, when available.
        :type include_payment_allocation: bool
        :param page_number: Page number
        :type page_number: int
        :param page_size: Page size
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_payments_get_serialize(
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            guest_id=guest_id,
            property_id=property_id,
            created_from=created_from,
            created_to=created_to,
            include_payment_allocation=include_payment_allocation,
            page_number=page_number,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPaymentsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_payments_get_serialize(
        self,
        reservation_id,
        house_account_id,
        guest_id,
        property_id,
        created_from,
        created_to,
        include_payment_allocation,
        page_number,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        if reservation_id is not None:
            
            _query_params.append(('reservationID', reservation_id))
            
        if house_account_id is not None:
            
            _query_params.append(('houseAccountID', house_account_id))
            
        if guest_id is not None:
            
            _query_params.append(('guestID', guest_id))
            
        if created_from is not None:
            if isinstance(created_from, datetime):
                _query_params.append(
                    (
                        'createdFrom',
                        created_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('createdFrom', created_from))
            
        if created_to is not None:
            if isinstance(created_to, datetime):
                _query_params.append(
                    (
                        'createdTo',
                        created_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('createdTo', created_to))
            
        if include_payment_allocation is not None:
            
            _query_params.append(('includePaymentAllocation', include_payment_allocation))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getPayments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_pending_transactions_get(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br /> It can be omitted if the API key is single-property, or to get results from all properties on an association.")] = None,
        include_debit: Annotated[Optional[StrictBool], Field(description="If the response should include debit transactions")] = None,
        include_credit: Annotated[Optional[StrictBool], Field(description="If the response should include credit transactions")] = None,
        include_deleted: Annotated[Optional[StrictBool], Field(description="If the response should include deleted transactions")] = None,
        include_children: Annotated[Optional[StrictBool], Field(description="If the response should include children transactions (requires the parameter transactionIDs)")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier, used to filter transactions result If reservationID is informed, and dates are not, all transactions with the reservationID will be returned.")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="Sub Reservation Identifier, used to filter transactions result")] = None,
        room_id: Annotated[Optional[StrictStr], Field(description="Room ID, used to filter transactions result")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Guest ID, used to filter transactions result")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account ID, used to filter transactions result")] = None,
        transaction_ids: Annotated[Optional[StrictStr], Field(description="List of transaction IDs to be returned, comma-separated, i.e. 37,345,89.")] = None,
        results_from: Annotated[Optional[date], Field(description="Inferior limit date, used to filter transactions result (posted transaction date)")] = None,
        results_to: Annotated[Optional[date], Field(description="Superior limit date, used to filter transactions result (posted transaction date)")] = None,
        modified_from: Annotated[Optional[date], Field(description="Inferior limit date, used to filter transactions result")] = None,
        modified_to: Annotated[Optional[date], Field(description="Superior limit date, used to filter transactions result")] = None,
        created_from: Annotated[Optional[datetime], Field(description="Inferior limit datetime, used to filter transactions result (creation date of the transaction). If informed, all other dates are ignored (except createdTo). If createdFrom is informed, but createdTo is not, the call will return all results since this datetime. Necessary only if createdTo is sent. If time portion not given, assumes 00:00:00.")] = None,
        created_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter transactions result (creation date of the transaction). If informed (together with createdFrom), all other dates are ignored. If time portion not given, assumes 23:59:59.")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Results page number")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Results page size. Max = 100")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Sort response results by field")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Order response in DESCending or ASCending order, used together with sortBy")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetPendingTransactionsResponse:
        """getPendingTransactions

        Get a list of pending transactions for a property, or list of properties, for the date range specified. If no date range or reservation is specified, it will return the transactions for the last 7 days, unless stated otherwise.<br /> Please note that some reservations modification may not be reflected in this timestamp. ### Group account support

        :param property_id: ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br /> It can be omitted if the API key is single-property, or to get results from all properties on an association.
        :type property_id: str
        :param include_debit: If the response should include debit transactions
        :type include_debit: bool
        :param include_credit: If the response should include credit transactions
        :type include_credit: bool
        :param include_deleted: If the response should include deleted transactions
        :type include_deleted: bool
        :param include_children: If the response should include children transactions (requires the parameter transactionIDs)
        :type include_children: bool
        :param reservation_id: Reservation Unique Identifier, used to filter transactions result If reservationID is informed, and dates are not, all transactions with the reservationID will be returned.
        :type reservation_id: str
        :param sub_reservation_id: Sub Reservation Identifier, used to filter transactions result
        :type sub_reservation_id: str
        :param room_id: Room ID, used to filter transactions result
        :type room_id: str
        :param guest_id: Guest ID, used to filter transactions result
        :type guest_id: str
        :param house_account_id: House Account ID, used to filter transactions result
        :type house_account_id: str
        :param transaction_ids: List of transaction IDs to be returned, comma-separated, i.e. 37,345,89.
        :type transaction_ids: str
        :param results_from: Inferior limit date, used to filter transactions result (posted transaction date)
        :type results_from: date
        :param results_to: Superior limit date, used to filter transactions result (posted transaction date)
        :type results_to: date
        :param modified_from: Inferior limit date, used to filter transactions result
        :type modified_from: date
        :param modified_to: Superior limit date, used to filter transactions result
        :type modified_to: date
        :param created_from: Inferior limit datetime, used to filter transactions result (creation date of the transaction). If informed, all other dates are ignored (except createdTo). If createdFrom is informed, but createdTo is not, the call will return all results since this datetime. Necessary only if createdTo is sent. If time portion not given, assumes 00:00:00.
        :type created_from: datetime
        :param created_to: Superior limit datetime, used to filter transactions result (creation date of the transaction). If informed (together with createdFrom), all other dates are ignored. If time portion not given, assumes 23:59:59.
        :type created_to: datetime
        :param page_number: Results page number
        :type page_number: int
        :param page_size: Results page size. Max = 100
        :type page_size: int
        :param sort_by: Sort response results by field
        :type sort_by: str
        :param order_by: Order response in DESCending or ASCending order, used together with sortBy
        :type order_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pending_transactions_get_serialize(
            property_id=property_id,
            include_debit=include_debit,
            include_credit=include_credit,
            include_deleted=include_deleted,
            include_children=include_children,
            reservation_id=reservation_id,
            sub_reservation_id=sub_reservation_id,
            room_id=room_id,
            guest_id=guest_id,
            house_account_id=house_account_id,
            transaction_ids=transaction_ids,
            results_from=results_from,
            results_to=results_to,
            modified_from=modified_from,
            modified_to=modified_to,
            created_from=created_from,
            created_to=created_to,
            page_number=page_number,
            page_size=page_size,
            sort_by=sort_by,
            order_by=order_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPendingTransactionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_pending_transactions_get_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br /> It can be omitted if the API key is single-property, or to get results from all properties on an association.")] = None,
        include_debit: Annotated[Optional[StrictBool], Field(description="If the response should include debit transactions")] = None,
        include_credit: Annotated[Optional[StrictBool], Field(description="If the response should include credit transactions")] = None,
        include_deleted: Annotated[Optional[StrictBool], Field(description="If the response should include deleted transactions")] = None,
        include_children: Annotated[Optional[StrictBool], Field(description="If the response should include children transactions (requires the parameter transactionIDs)")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier, used to filter transactions result If reservationID is informed, and dates are not, all transactions with the reservationID will be returned.")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="Sub Reservation Identifier, used to filter transactions result")] = None,
        room_id: Annotated[Optional[StrictStr], Field(description="Room ID, used to filter transactions result")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Guest ID, used to filter transactions result")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account ID, used to filter transactions result")] = None,
        transaction_ids: Annotated[Optional[StrictStr], Field(description="List of transaction IDs to be returned, comma-separated, i.e. 37,345,89.")] = None,
        results_from: Annotated[Optional[date], Field(description="Inferior limit date, used to filter transactions result (posted transaction date)")] = None,
        results_to: Annotated[Optional[date], Field(description="Superior limit date, used to filter transactions result (posted transaction date)")] = None,
        modified_from: Annotated[Optional[date], Field(description="Inferior limit date, used to filter transactions result")] = None,
        modified_to: Annotated[Optional[date], Field(description="Superior limit date, used to filter transactions result")] = None,
        created_from: Annotated[Optional[datetime], Field(description="Inferior limit datetime, used to filter transactions result (creation date of the transaction). If informed, all other dates are ignored (except createdTo). If createdFrom is informed, but createdTo is not, the call will return all results since this datetime. Necessary only if createdTo is sent. If time portion not given, assumes 00:00:00.")] = None,
        created_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter transactions result (creation date of the transaction). If informed (together with createdFrom), all other dates are ignored. If time portion not given, assumes 23:59:59.")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Results page number")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Results page size. Max = 100")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Sort response results by field")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Order response in DESCending or ASCending order, used together with sortBy")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetPendingTransactionsResponse]:
        """getPendingTransactions

        Get a list of pending transactions for a property, or list of properties, for the date range specified. If no date range or reservation is specified, it will return the transactions for the last 7 days, unless stated otherwise.<br /> Please note that some reservations modification may not be reflected in this timestamp. ### Group account support

        :param property_id: ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br /> It can be omitted if the API key is single-property, or to get results from all properties on an association.
        :type property_id: str
        :param include_debit: If the response should include debit transactions
        :type include_debit: bool
        :param include_credit: If the response should include credit transactions
        :type include_credit: bool
        :param include_deleted: If the response should include deleted transactions
        :type include_deleted: bool
        :param include_children: If the response should include children transactions (requires the parameter transactionIDs)
        :type include_children: bool
        :param reservation_id: Reservation Unique Identifier, used to filter transactions result If reservationID is informed, and dates are not, all transactions with the reservationID will be returned.
        :type reservation_id: str
        :param sub_reservation_id: Sub Reservation Identifier, used to filter transactions result
        :type sub_reservation_id: str
        :param room_id: Room ID, used to filter transactions result
        :type room_id: str
        :param guest_id: Guest ID, used to filter transactions result
        :type guest_id: str
        :param house_account_id: House Account ID, used to filter transactions result
        :type house_account_id: str
        :param transaction_ids: List of transaction IDs to be returned, comma-separated, i.e. 37,345,89.
        :type transaction_ids: str
        :param results_from: Inferior limit date, used to filter transactions result (posted transaction date)
        :type results_from: date
        :param results_to: Superior limit date, used to filter transactions result (posted transaction date)
        :type results_to: date
        :param modified_from: Inferior limit date, used to filter transactions result
        :type modified_from: date
        :param modified_to: Superior limit date, used to filter transactions result
        :type modified_to: date
        :param created_from: Inferior limit datetime, used to filter transactions result (creation date of the transaction). If informed, all other dates are ignored (except createdTo). If createdFrom is informed, but createdTo is not, the call will return all results since this datetime. Necessary only if createdTo is sent. If time portion not given, assumes 00:00:00.
        :type created_from: datetime
        :param created_to: Superior limit datetime, used to filter transactions result (creation date of the transaction). If informed (together with createdFrom), all other dates are ignored. If time portion not given, assumes 23:59:59.
        :type created_to: datetime
        :param page_number: Results page number
        :type page_number: int
        :param page_size: Results page size. Max = 100
        :type page_size: int
        :param sort_by: Sort response results by field
        :type sort_by: str
        :param order_by: Order response in DESCending or ASCending order, used together with sortBy
        :type order_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pending_transactions_get_serialize(
            property_id=property_id,
            include_debit=include_debit,
            include_credit=include_credit,
            include_deleted=include_deleted,
            include_children=include_children,
            reservation_id=reservation_id,
            sub_reservation_id=sub_reservation_id,
            room_id=room_id,
            guest_id=guest_id,
            house_account_id=house_account_id,
            transaction_ids=transaction_ids,
            results_from=results_from,
            results_to=results_to,
            modified_from=modified_from,
            modified_to=modified_to,
            created_from=created_from,
            created_to=created_to,
            page_number=page_number,
            page_size=page_size,
            sort_by=sort_by,
            order_by=order_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPendingTransactionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_pending_transactions_get_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br /> It can be omitted if the API key is single-property, or to get results from all properties on an association.")] = None,
        include_debit: Annotated[Optional[StrictBool], Field(description="If the response should include debit transactions")] = None,
        include_credit: Annotated[Optional[StrictBool], Field(description="If the response should include credit transactions")] = None,
        include_deleted: Annotated[Optional[StrictBool], Field(description="If the response should include deleted transactions")] = None,
        include_children: Annotated[Optional[StrictBool], Field(description="If the response should include children transactions (requires the parameter transactionIDs)")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier, used to filter transactions result If reservationID is informed, and dates are not, all transactions with the reservationID will be returned.")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="Sub Reservation Identifier, used to filter transactions result")] = None,
        room_id: Annotated[Optional[StrictStr], Field(description="Room ID, used to filter transactions result")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Guest ID, used to filter transactions result")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account ID, used to filter transactions result")] = None,
        transaction_ids: Annotated[Optional[StrictStr], Field(description="List of transaction IDs to be returned, comma-separated, i.e. 37,345,89.")] = None,
        results_from: Annotated[Optional[date], Field(description="Inferior limit date, used to filter transactions result (posted transaction date)")] = None,
        results_to: Annotated[Optional[date], Field(description="Superior limit date, used to filter transactions result (posted transaction date)")] = None,
        modified_from: Annotated[Optional[date], Field(description="Inferior limit date, used to filter transactions result")] = None,
        modified_to: Annotated[Optional[date], Field(description="Superior limit date, used to filter transactions result")] = None,
        created_from: Annotated[Optional[datetime], Field(description="Inferior limit datetime, used to filter transactions result (creation date of the transaction). If informed, all other dates are ignored (except createdTo). If createdFrom is informed, but createdTo is not, the call will return all results since this datetime. Necessary only if createdTo is sent. If time portion not given, assumes 00:00:00.")] = None,
        created_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter transactions result (creation date of the transaction). If informed (together with createdFrom), all other dates are ignored. If time portion not given, assumes 23:59:59.")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Results page number")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Results page size. Max = 100")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Sort response results by field")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Order response in DESCending or ASCending order, used together with sortBy")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getPendingTransactions

        Get a list of pending transactions for a property, or list of properties, for the date range specified. If no date range or reservation is specified, it will return the transactions for the last 7 days, unless stated otherwise.<br /> Please note that some reservations modification may not be reflected in this timestamp. ### Group account support

        :param property_id: ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br /> It can be omitted if the API key is single-property, or to get results from all properties on an association.
        :type property_id: str
        :param include_debit: If the response should include debit transactions
        :type include_debit: bool
        :param include_credit: If the response should include credit transactions
        :type include_credit: bool
        :param include_deleted: If the response should include deleted transactions
        :type include_deleted: bool
        :param include_children: If the response should include children transactions (requires the parameter transactionIDs)
        :type include_children: bool
        :param reservation_id: Reservation Unique Identifier, used to filter transactions result If reservationID is informed, and dates are not, all transactions with the reservationID will be returned.
        :type reservation_id: str
        :param sub_reservation_id: Sub Reservation Identifier, used to filter transactions result
        :type sub_reservation_id: str
        :param room_id: Room ID, used to filter transactions result
        :type room_id: str
        :param guest_id: Guest ID, used to filter transactions result
        :type guest_id: str
        :param house_account_id: House Account ID, used to filter transactions result
        :type house_account_id: str
        :param transaction_ids: List of transaction IDs to be returned, comma-separated, i.e. 37,345,89.
        :type transaction_ids: str
        :param results_from: Inferior limit date, used to filter transactions result (posted transaction date)
        :type results_from: date
        :param results_to: Superior limit date, used to filter transactions result (posted transaction date)
        :type results_to: date
        :param modified_from: Inferior limit date, used to filter transactions result
        :type modified_from: date
        :param modified_to: Superior limit date, used to filter transactions result
        :type modified_to: date
        :param created_from: Inferior limit datetime, used to filter transactions result (creation date of the transaction). If informed, all other dates are ignored (except createdTo). If createdFrom is informed, but createdTo is not, the call will return all results since this datetime. Necessary only if createdTo is sent. If time portion not given, assumes 00:00:00.
        :type created_from: datetime
        :param created_to: Superior limit datetime, used to filter transactions result (creation date of the transaction). If informed (together with createdFrom), all other dates are ignored. If time portion not given, assumes 23:59:59.
        :type created_to: datetime
        :param page_number: Results page number
        :type page_number: int
        :param page_size: Results page size. Max = 100
        :type page_size: int
        :param sort_by: Sort response results by field
        :type sort_by: str
        :param order_by: Order response in DESCending or ASCending order, used together with sortBy
        :type order_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pending_transactions_get_serialize(
            property_id=property_id,
            include_debit=include_debit,
            include_credit=include_credit,
            include_deleted=include_deleted,
            include_children=include_children,
            reservation_id=reservation_id,
            sub_reservation_id=sub_reservation_id,
            room_id=room_id,
            guest_id=guest_id,
            house_account_id=house_account_id,
            transaction_ids=transaction_ids,
            results_from=results_from,
            results_to=results_to,
            modified_from=modified_from,
            modified_to=modified_to,
            created_from=created_from,
            created_to=created_to,
            page_number=page_number,
            page_size=page_size,
            sort_by=sort_by,
            order_by=order_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPendingTransactionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_pending_transactions_get_serialize(
        self,
        property_id,
        include_debit,
        include_credit,
        include_deleted,
        include_children,
        reservation_id,
        sub_reservation_id,
        room_id,
        guest_id,
        house_account_id,
        transaction_ids,
        results_from,
        results_to,
        modified_from,
        modified_to,
        created_from,
        created_to,
        page_number,
        page_size,
        sort_by,
        order_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        if include_debit is not None:
            
            _query_params.append(('includeDebit', include_debit))
            
        if include_credit is not None:
            
            _query_params.append(('includeCredit', include_credit))
            
        if include_deleted is not None:
            
            _query_params.append(('includeDeleted', include_deleted))
            
        if include_children is not None:
            
            _query_params.append(('includeChildren', include_children))
            
        if reservation_id is not None:
            
            _query_params.append(('reservationID', reservation_id))
            
        if sub_reservation_id is not None:
            
            _query_params.append(('subReservationID', sub_reservation_id))
            
        if room_id is not None:
            
            _query_params.append(('roomID', room_id))
            
        if guest_id is not None:
            
            _query_params.append(('guestID', guest_id))
            
        if house_account_id is not None:
            
            _query_params.append(('houseAccountID', house_account_id))
            
        if transaction_ids is not None:
            
            _query_params.append(('transactionIDs', transaction_ids))
            
        if results_from is not None:
            if isinstance(results_from, date):
                _query_params.append(
                    (
                        'resultsFrom',
                        results_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('resultsFrom', results_from))
            
        if results_to is not None:
            if isinstance(results_to, date):
                _query_params.append(
                    (
                        'resultsTo',
                        results_to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('resultsTo', results_to))
            
        if modified_from is not None:
            if isinstance(modified_from, date):
                _query_params.append(
                    (
                        'modifiedFrom',
                        modified_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('modifiedFrom', modified_from))
            
        if modified_to is not None:
            if isinstance(modified_to, date):
                _query_params.append(
                    (
                        'modifiedTo',
                        modified_to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('modifiedTo', modified_to))
            
        if created_from is not None:
            if isinstance(created_from, datetime):
                _query_params.append(
                    (
                        'createdFrom',
                        created_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('createdFrom', created_from))
            
        if created_to is not None:
            if isinstance(created_to, datetime):
                _query_params.append(
                    (
                        'createdTo',
                        created_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('createdTo', created_to))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if order_by is not None:
            
            _query_params.append(('orderBy', order_by))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getPendingTransactions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_charge_post(
        self,
        property_id: Optional[StrictStr] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation ID")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account ID")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="Group ID")] = None,
        accounts_receivable_ledger_id: Annotated[Optional[StrictStr], Field(description="Accounts Receivable Ledger ID")] = None,
        amount: Annotated[Optional[StrictStr], Field(description="Amount to charge")] = None,
        currency: Annotated[Optional[StrictStr], Field(description="Currency to charge")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Description of the payment to display on folio")] = None,
        payment_method_id: Annotated[Optional[StrictStr], Field(description="Payment method UUID")] = None,
        is_deposit: Annotated[Optional[StrictBool], Field(description="determine if this payment is a deposit (default: false)")] = None,
        redirect_url: Annotated[Optional[StrictStr], Field(description="client will be redirected to this page after he completed 3ds challenge. User will be redirected with HTTP get redirect and parameter **result** will be added to query string with possible values: - **failed** if 3ds challenge is not passed - **successful** if 3ds challenge is passed If not provided for card with 3ds the request will be rejected")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostChargeResponse:
        """postCharge

        Use a payment method to process a payment on a reservation, group profile, accounts receivable ledger, or house account.

        :param property_id: 
        :type property_id: str
        :param reservation_id: Reservation ID
        :type reservation_id: str
        :param house_account_id: House Account ID
        :type house_account_id: str
        :param group_id: Group ID
        :type group_id: str
        :param accounts_receivable_ledger_id: Accounts Receivable Ledger ID
        :type accounts_receivable_ledger_id: str
        :param amount: Amount to charge
        :type amount: str
        :param currency: Currency to charge
        :type currency: str
        :param description: Description of the payment to display on folio
        :type description: str
        :param payment_method_id: Payment method UUID
        :type payment_method_id: str
        :param is_deposit: determine if this payment is a deposit (default: false)
        :type is_deposit: bool
        :param redirect_url: client will be redirected to this page after he completed 3ds challenge. User will be redirected with HTTP get redirect and parameter **result** will be added to query string with possible values: - **failed** if 3ds challenge is not passed - **successful** if 3ds challenge is passed If not provided for card with 3ds the request will be rejected
        :type redirect_url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_charge_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            group_id=group_id,
            accounts_receivable_ledger_id=accounts_receivable_ledger_id,
            amount=amount,
            currency=currency,
            description=description,
            payment_method_id=payment_method_id,
            is_deposit=is_deposit,
            redirect_url=redirect_url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostChargeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_charge_post_with_http_info(
        self,
        property_id: Optional[StrictStr] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation ID")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account ID")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="Group ID")] = None,
        accounts_receivable_ledger_id: Annotated[Optional[StrictStr], Field(description="Accounts Receivable Ledger ID")] = None,
        amount: Annotated[Optional[StrictStr], Field(description="Amount to charge")] = None,
        currency: Annotated[Optional[StrictStr], Field(description="Currency to charge")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Description of the payment to display on folio")] = None,
        payment_method_id: Annotated[Optional[StrictStr], Field(description="Payment method UUID")] = None,
        is_deposit: Annotated[Optional[StrictBool], Field(description="determine if this payment is a deposit (default: false)")] = None,
        redirect_url: Annotated[Optional[StrictStr], Field(description="client will be redirected to this page after he completed 3ds challenge. User will be redirected with HTTP get redirect and parameter **result** will be added to query string with possible values: - **failed** if 3ds challenge is not passed - **successful** if 3ds challenge is passed If not provided for card with 3ds the request will be rejected")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostChargeResponse]:
        """postCharge

        Use a payment method to process a payment on a reservation, group profile, accounts receivable ledger, or house account.

        :param property_id: 
        :type property_id: str
        :param reservation_id: Reservation ID
        :type reservation_id: str
        :param house_account_id: House Account ID
        :type house_account_id: str
        :param group_id: Group ID
        :type group_id: str
        :param accounts_receivable_ledger_id: Accounts Receivable Ledger ID
        :type accounts_receivable_ledger_id: str
        :param amount: Amount to charge
        :type amount: str
        :param currency: Currency to charge
        :type currency: str
        :param description: Description of the payment to display on folio
        :type description: str
        :param payment_method_id: Payment method UUID
        :type payment_method_id: str
        :param is_deposit: determine if this payment is a deposit (default: false)
        :type is_deposit: bool
        :param redirect_url: client will be redirected to this page after he completed 3ds challenge. User will be redirected with HTTP get redirect and parameter **result** will be added to query string with possible values: - **failed** if 3ds challenge is not passed - **successful** if 3ds challenge is passed If not provided for card with 3ds the request will be rejected
        :type redirect_url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_charge_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            group_id=group_id,
            accounts_receivable_ledger_id=accounts_receivable_ledger_id,
            amount=amount,
            currency=currency,
            description=description,
            payment_method_id=payment_method_id,
            is_deposit=is_deposit,
            redirect_url=redirect_url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostChargeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_charge_post_without_preload_content(
        self,
        property_id: Optional[StrictStr] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation ID")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account ID")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="Group ID")] = None,
        accounts_receivable_ledger_id: Annotated[Optional[StrictStr], Field(description="Accounts Receivable Ledger ID")] = None,
        amount: Annotated[Optional[StrictStr], Field(description="Amount to charge")] = None,
        currency: Annotated[Optional[StrictStr], Field(description="Currency to charge")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Description of the payment to display on folio")] = None,
        payment_method_id: Annotated[Optional[StrictStr], Field(description="Payment method UUID")] = None,
        is_deposit: Annotated[Optional[StrictBool], Field(description="determine if this payment is a deposit (default: false)")] = None,
        redirect_url: Annotated[Optional[StrictStr], Field(description="client will be redirected to this page after he completed 3ds challenge. User will be redirected with HTTP get redirect and parameter **result** will be added to query string with possible values: - **failed** if 3ds challenge is not passed - **successful** if 3ds challenge is passed If not provided for card with 3ds the request will be rejected")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postCharge

        Use a payment method to process a payment on a reservation, group profile, accounts receivable ledger, or house account.

        :param property_id: 
        :type property_id: str
        :param reservation_id: Reservation ID
        :type reservation_id: str
        :param house_account_id: House Account ID
        :type house_account_id: str
        :param group_id: Group ID
        :type group_id: str
        :param accounts_receivable_ledger_id: Accounts Receivable Ledger ID
        :type accounts_receivable_ledger_id: str
        :param amount: Amount to charge
        :type amount: str
        :param currency: Currency to charge
        :type currency: str
        :param description: Description of the payment to display on folio
        :type description: str
        :param payment_method_id: Payment method UUID
        :type payment_method_id: str
        :param is_deposit: determine if this payment is a deposit (default: false)
        :type is_deposit: bool
        :param redirect_url: client will be redirected to this page after he completed 3ds challenge. User will be redirected with HTTP get redirect and parameter **result** will be added to query string with possible values: - **failed** if 3ds challenge is not passed - **successful** if 3ds challenge is passed If not provided for card with 3ds the request will be rejected
        :type redirect_url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_charge_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            group_id=group_id,
            accounts_receivable_ledger_id=accounts_receivable_ledger_id,
            amount=amount,
            currency=currency,
            description=description,
            payment_method_id=payment_method_id,
            is_deposit=is_deposit,
            redirect_url=redirect_url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostChargeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_charge_post_serialize(
        self,
        property_id,
        reservation_id,
        house_account_id,
        group_id,
        accounts_receivable_ledger_id,
        amount,
        currency,
        description,
        payment_method_id,
        is_deposit,
        redirect_url,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if house_account_id is not None:
            _form_params.append(('houseAccountID', house_account_id))
        if group_id is not None:
            _form_params.append(('groupID', group_id))
        if accounts_receivable_ledger_id is not None:
            _form_params.append(('accountsReceivableLedgerID', accounts_receivable_ledger_id))
        if amount is not None:
            _form_params.append(('amount', amount))
        if currency is not None:
            _form_params.append(('currency', currency))
        if description is not None:
            _form_params.append(('description', description))
        if payment_method_id is not None:
            _form_params.append(('paymentMethodId', payment_method_id))
        if is_deposit is not None:
            _form_params.append(('isDeposit', is_deposit))
        if redirect_url is not None:
            _form_params.append(('redirectUrl', redirect_url))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postCharge',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_credit_card_post(
        self,
        property_id: Optional[StrictStr] = None,
        reservation_id: Optional[StrictStr] = None,
        card_token: Annotated[Optional[StrictStr], Field(description="cardToken provided by Stripe JS, not recommended, not required if paymentMethodId is provided")] = None,
        payment_method_id: Annotated[Optional[StrictStr], Field(description="Payment Method ID provided by the payments SDK")] = None,
        return_url: Annotated[Optional[StrictStr], Field(description="client will be redirected to this page after he completed 3ds challenge. User will be redirected with HTTP get redirect and parameter **result** will be added to query string with possible values: - **failed** if 3ds challenge is not passed - **successful** if 3ds challenge is passed If not provided for card with 3ds the request will be rejected")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostCardResponse:
        """postCreditCard

        Returns the rate of the room type selected, based on the provided parameters

        :param property_id: 
        :type property_id: str
        :param reservation_id: 
        :type reservation_id: str
        :param card_token: cardToken provided by Stripe JS, not recommended, not required if paymentMethodId is provided
        :type card_token: str
        :param payment_method_id: Payment Method ID provided by the payments SDK
        :type payment_method_id: str
        :param return_url: client will be redirected to this page after he completed 3ds challenge. User will be redirected with HTTP get redirect and parameter **result** will be added to query string with possible values: - **failed** if 3ds challenge is not passed - **successful** if 3ds challenge is passed If not provided for card with 3ds the request will be rejected
        :type return_url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_credit_card_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            card_token=card_token,
            payment_method_id=payment_method_id,
            return_url=return_url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostCardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_credit_card_post_with_http_info(
        self,
        property_id: Optional[StrictStr] = None,
        reservation_id: Optional[StrictStr] = None,
        card_token: Annotated[Optional[StrictStr], Field(description="cardToken provided by Stripe JS, not recommended, not required if paymentMethodId is provided")] = None,
        payment_method_id: Annotated[Optional[StrictStr], Field(description="Payment Method ID provided by the payments SDK")] = None,
        return_url: Annotated[Optional[StrictStr], Field(description="client will be redirected to this page after he completed 3ds challenge. User will be redirected with HTTP get redirect and parameter **result** will be added to query string with possible values: - **failed** if 3ds challenge is not passed - **successful** if 3ds challenge is passed If not provided for card with 3ds the request will be rejected")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostCardResponse]:
        """postCreditCard

        Returns the rate of the room type selected, based on the provided parameters

        :param property_id: 
        :type property_id: str
        :param reservation_id: 
        :type reservation_id: str
        :param card_token: cardToken provided by Stripe JS, not recommended, not required if paymentMethodId is provided
        :type card_token: str
        :param payment_method_id: Payment Method ID provided by the payments SDK
        :type payment_method_id: str
        :param return_url: client will be redirected to this page after he completed 3ds challenge. User will be redirected with HTTP get redirect and parameter **result** will be added to query string with possible values: - **failed** if 3ds challenge is not passed - **successful** if 3ds challenge is passed If not provided for card with 3ds the request will be rejected
        :type return_url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_credit_card_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            card_token=card_token,
            payment_method_id=payment_method_id,
            return_url=return_url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostCardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_credit_card_post_without_preload_content(
        self,
        property_id: Optional[StrictStr] = None,
        reservation_id: Optional[StrictStr] = None,
        card_token: Annotated[Optional[StrictStr], Field(description="cardToken provided by Stripe JS, not recommended, not required if paymentMethodId is provided")] = None,
        payment_method_id: Annotated[Optional[StrictStr], Field(description="Payment Method ID provided by the payments SDK")] = None,
        return_url: Annotated[Optional[StrictStr], Field(description="client will be redirected to this page after he completed 3ds challenge. User will be redirected with HTTP get redirect and parameter **result** will be added to query string with possible values: - **failed** if 3ds challenge is not passed - **successful** if 3ds challenge is passed If not provided for card with 3ds the request will be rejected")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postCreditCard

        Returns the rate of the room type selected, based on the provided parameters

        :param property_id: 
        :type property_id: str
        :param reservation_id: 
        :type reservation_id: str
        :param card_token: cardToken provided by Stripe JS, not recommended, not required if paymentMethodId is provided
        :type card_token: str
        :param payment_method_id: Payment Method ID provided by the payments SDK
        :type payment_method_id: str
        :param return_url: client will be redirected to this page after he completed 3ds challenge. User will be redirected with HTTP get redirect and parameter **result** will be added to query string with possible values: - **failed** if 3ds challenge is not passed - **successful** if 3ds challenge is passed If not provided for card with 3ds the request will be rejected
        :type return_url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_credit_card_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            card_token=card_token,
            payment_method_id=payment_method_id,
            return_url=return_url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostCardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_credit_card_post_serialize(
        self,
        property_id,
        reservation_id,
        card_token,
        payment_method_id,
        return_url,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if card_token is not None:
            _form_params.append(('cardToken', card_token))
        if payment_method_id is not None:
            _form_params.append(('paymentMethodId', payment_method_id))
        if return_url is not None:
            _form_params.append(('returnUrl', return_url))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postCreditCard',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_custom_payment_method_post(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID, if not sent will retrieve property ID from credentials, only one property ID call.")] = None,
        method: Annotated[Optional[StrictStr], Field(description="Payment Method, value used in future calls. Must be unique for each property and no whitespaces are allowed (use camel case or underline instead). Will be verified against existing Payment Methods, if it exists, will try to enable it.")] = None,
        method_name: Annotated[Optional[StrictStr], Field(description="Payment Method Name, value used to represent the Payment Method. Can use spaces. If nothing is sent, will use value for method.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostCustomPaymentMethodResponse:
        """postCustomPaymentMethod

        Add a Custom Payment Method to a property. This call does not allow to add Payment Methods: credit cards, bank transfer or Pay Pal.

        :param property_id: Property ID, if not sent will retrieve property ID from credentials, only one property ID call.
        :type property_id: str
        :param method: Payment Method, value used in future calls. Must be unique for each property and no whitespaces are allowed (use camel case or underline instead). Will be verified against existing Payment Methods, if it exists, will try to enable it.
        :type method: str
        :param method_name: Payment Method Name, value used to represent the Payment Method. Can use spaces. If nothing is sent, will use value for method.
        :type method_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_custom_payment_method_post_serialize(
            property_id=property_id,
            method=method,
            method_name=method_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostCustomPaymentMethodResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_custom_payment_method_post_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID, if not sent will retrieve property ID from credentials, only one property ID call.")] = None,
        method: Annotated[Optional[StrictStr], Field(description="Payment Method, value used in future calls. Must be unique for each property and no whitespaces are allowed (use camel case or underline instead). Will be verified against existing Payment Methods, if it exists, will try to enable it.")] = None,
        method_name: Annotated[Optional[StrictStr], Field(description="Payment Method Name, value used to represent the Payment Method. Can use spaces. If nothing is sent, will use value for method.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostCustomPaymentMethodResponse]:
        """postCustomPaymentMethod

        Add a Custom Payment Method to a property. This call does not allow to add Payment Methods: credit cards, bank transfer or Pay Pal.

        :param property_id: Property ID, if not sent will retrieve property ID from credentials, only one property ID call.
        :type property_id: str
        :param method: Payment Method, value used in future calls. Must be unique for each property and no whitespaces are allowed (use camel case or underline instead). Will be verified against existing Payment Methods, if it exists, will try to enable it.
        :type method: str
        :param method_name: Payment Method Name, value used to represent the Payment Method. Can use spaces. If nothing is sent, will use value for method.
        :type method_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_custom_payment_method_post_serialize(
            property_id=property_id,
            method=method,
            method_name=method_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostCustomPaymentMethodResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_custom_payment_method_post_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID, if not sent will retrieve property ID from credentials, only one property ID call.")] = None,
        method: Annotated[Optional[StrictStr], Field(description="Payment Method, value used in future calls. Must be unique for each property and no whitespaces are allowed (use camel case or underline instead). Will be verified against existing Payment Methods, if it exists, will try to enable it.")] = None,
        method_name: Annotated[Optional[StrictStr], Field(description="Payment Method Name, value used to represent the Payment Method. Can use spaces. If nothing is sent, will use value for method.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postCustomPaymentMethod

        Add a Custom Payment Method to a property. This call does not allow to add Payment Methods: credit cards, bank transfer or Pay Pal.

        :param property_id: Property ID, if not sent will retrieve property ID from credentials, only one property ID call.
        :type property_id: str
        :param method: Payment Method, value used in future calls. Must be unique for each property and no whitespaces are allowed (use camel case or underline instead). Will be verified against existing Payment Methods, if it exists, will try to enable it.
        :type method: str
        :param method_name: Payment Method Name, value used to represent the Payment Method. Can use spaces. If nothing is sent, will use value for method.
        :type method_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_custom_payment_method_post_serialize(
            property_id=property_id,
            method=method,
            method_name=method_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostCustomPaymentMethodResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_custom_payment_method_post_serialize(
        self,
        property_id,
        method,
        method_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if method is not None:
            _form_params.append(('method', method))
        if method_name is not None:
            _form_params.append(('methodName', method_name))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postCustomPaymentMethod',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_payment_cash_post(
        self,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier")] = None,
        amount: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Amount paid on this payment")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostPaymentCashResponse:
        """postPaymentCash

        Add a payment done by cash to a specified reservation

        :param reservation_id: Reservation identifier
        :type reservation_id: str
        :param amount: Amount paid on this payment
        :type amount: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_payment_cash_post_serialize(
            reservation_id=reservation_id,
            amount=amount,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostPaymentCashResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_payment_cash_post_with_http_info(
        self,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier")] = None,
        amount: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Amount paid on this payment")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostPaymentCashResponse]:
        """postPaymentCash

        Add a payment done by cash to a specified reservation

        :param reservation_id: Reservation identifier
        :type reservation_id: str
        :param amount: Amount paid on this payment
        :type amount: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_payment_cash_post_serialize(
            reservation_id=reservation_id,
            amount=amount,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostPaymentCashResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_payment_cash_post_without_preload_content(
        self,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier")] = None,
        amount: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Amount paid on this payment")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postPaymentCash

        Add a payment done by cash to a specified reservation

        :param reservation_id: Reservation identifier
        :type reservation_id: str
        :param amount: Amount paid on this payment
        :type amount: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_payment_cash_post_serialize(
            reservation_id=reservation_id,
            amount=amount,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostPaymentCashResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_payment_cash_post_serialize(
        self,
        reservation_id,
        amount,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if amount is not None:
            _form_params.append(('amount', amount))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postPaymentCash',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_payment_credit_card_post(
        self,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier")] = None,
        amount: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Amount paid on this payment")] = None,
        card_id: Annotated[Optional[StrictStr], Field(description="Credit Card ID used on payment. Can be retrieved with reservation information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostPaymentCreditCardResponse:
        """postPaymentCreditCard

        Add a payment done by credit card to a specified reservation

        :param reservation_id: Reservation identifier
        :type reservation_id: str
        :param amount: Amount paid on this payment
        :type amount: float
        :param card_id: Credit Card ID used on payment. Can be retrieved with reservation information
        :type card_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_payment_credit_card_post_serialize(
            reservation_id=reservation_id,
            amount=amount,
            card_id=card_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostPaymentCreditCardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_payment_credit_card_post_with_http_info(
        self,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier")] = None,
        amount: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Amount paid on this payment")] = None,
        card_id: Annotated[Optional[StrictStr], Field(description="Credit Card ID used on payment. Can be retrieved with reservation information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostPaymentCreditCardResponse]:
        """postPaymentCreditCard

        Add a payment done by credit card to a specified reservation

        :param reservation_id: Reservation identifier
        :type reservation_id: str
        :param amount: Amount paid on this payment
        :type amount: float
        :param card_id: Credit Card ID used on payment. Can be retrieved with reservation information
        :type card_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_payment_credit_card_post_serialize(
            reservation_id=reservation_id,
            amount=amount,
            card_id=card_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostPaymentCreditCardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_payment_credit_card_post_without_preload_content(
        self,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier")] = None,
        amount: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Amount paid on this payment")] = None,
        card_id: Annotated[Optional[StrictStr], Field(description="Credit Card ID used on payment. Can be retrieved with reservation information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postPaymentCreditCard

        Add a payment done by credit card to a specified reservation

        :param reservation_id: Reservation identifier
        :type reservation_id: str
        :param amount: Amount paid on this payment
        :type amount: float
        :param card_id: Credit Card ID used on payment. Can be retrieved with reservation information
        :type card_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_payment_credit_card_post_serialize(
            reservation_id=reservation_id,
            amount=amount,
            card_id=card_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostPaymentCreditCardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_payment_credit_card_post_serialize(
        self,
        reservation_id,
        amount,
        card_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if amount is not None:
            _form_params.append(('amount', amount))
        if card_id is not None:
            _form_params.append(('cardID', card_id))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postPaymentCreditCard',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_payment_post(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account identifier is necessary if reservationID not sent")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="The Sub Reservation identifier. reservationID is still mandatory if subReservationID is sent.")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Payment type. Use the call [getPaymentMethods](#api-Payment-getPaymentMethods) to get the properties enabled payment methods.")] = None,
        amount: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Amount paid on this transaction")] = None,
        card_type: Annotated[Optional[StrictStr], Field(description="If type = credit, cardType is necessary. Allowed values are property based, but possible strings are: \\\"visa\\\",\\\"master\\\",\\\"amex\\\",\\\"aura\\\",\\\"diners\\\",\\\"hiper\\\",\\\"elo\\\",\\\"Discover\\\",\\\"jcb\\\",\\\"maestro\\\",\\\"dan\\\",\\\"PostCard\\\",\\\"Eurocard\\\",\\\"union_pay\\\"")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Note to be added to payment")] = None,
        is_deposit: Annotated[Optional[StrictBool], Field(description="determine if this payment is a deposit (default: false)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostPaymentResponse:
        """postPayment

        Add a payment to a specified reservation or house account. If both Reservation ID and HouseAccountID are informed, only the former is taken in consideration.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier
        :type reservation_id: str
        :param house_account_id: House Account identifier is necessary if reservationID not sent
        :type house_account_id: str
        :param sub_reservation_id: The Sub Reservation identifier. reservationID is still mandatory if subReservationID is sent.
        :type sub_reservation_id: str
        :param type: Payment type. Use the call [getPaymentMethods](#api-Payment-getPaymentMethods) to get the properties enabled payment methods.
        :type type: str
        :param amount: Amount paid on this transaction
        :type amount: float
        :param card_type: If type = credit, cardType is necessary. Allowed values are property based, but possible strings are: \\\"visa\\\",\\\"master\\\",\\\"amex\\\",\\\"aura\\\",\\\"diners\\\",\\\"hiper\\\",\\\"elo\\\",\\\"Discover\\\",\\\"jcb\\\",\\\"maestro\\\",\\\"dan\\\",\\\"PostCard\\\",\\\"Eurocard\\\",\\\"union_pay\\\"
        :type card_type: str
        :param description: Note to be added to payment
        :type description: str
        :param is_deposit: determine if this payment is a deposit (default: false)
        :type is_deposit: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_payment_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            sub_reservation_id=sub_reservation_id,
            type=type,
            amount=amount,
            card_type=card_type,
            description=description,
            is_deposit=is_deposit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostPaymentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_payment_post_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account identifier is necessary if reservationID not sent")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="The Sub Reservation identifier. reservationID is still mandatory if subReservationID is sent.")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Payment type. Use the call [getPaymentMethods](#api-Payment-getPaymentMethods) to get the properties enabled payment methods.")] = None,
        amount: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Amount paid on this transaction")] = None,
        card_type: Annotated[Optional[StrictStr], Field(description="If type = credit, cardType is necessary. Allowed values are property based, but possible strings are: \\\"visa\\\",\\\"master\\\",\\\"amex\\\",\\\"aura\\\",\\\"diners\\\",\\\"hiper\\\",\\\"elo\\\",\\\"Discover\\\",\\\"jcb\\\",\\\"maestro\\\",\\\"dan\\\",\\\"PostCard\\\",\\\"Eurocard\\\",\\\"union_pay\\\"")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Note to be added to payment")] = None,
        is_deposit: Annotated[Optional[StrictBool], Field(description="determine if this payment is a deposit (default: false)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostPaymentResponse]:
        """postPayment

        Add a payment to a specified reservation or house account. If both Reservation ID and HouseAccountID are informed, only the former is taken in consideration.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier
        :type reservation_id: str
        :param house_account_id: House Account identifier is necessary if reservationID not sent
        :type house_account_id: str
        :param sub_reservation_id: The Sub Reservation identifier. reservationID is still mandatory if subReservationID is sent.
        :type sub_reservation_id: str
        :param type: Payment type. Use the call [getPaymentMethods](#api-Payment-getPaymentMethods) to get the properties enabled payment methods.
        :type type: str
        :param amount: Amount paid on this transaction
        :type amount: float
        :param card_type: If type = credit, cardType is necessary. Allowed values are property based, but possible strings are: \\\"visa\\\",\\\"master\\\",\\\"amex\\\",\\\"aura\\\",\\\"diners\\\",\\\"hiper\\\",\\\"elo\\\",\\\"Discover\\\",\\\"jcb\\\",\\\"maestro\\\",\\\"dan\\\",\\\"PostCard\\\",\\\"Eurocard\\\",\\\"union_pay\\\"
        :type card_type: str
        :param description: Note to be added to payment
        :type description: str
        :param is_deposit: determine if this payment is a deposit (default: false)
        :type is_deposit: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_payment_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            sub_reservation_id=sub_reservation_id,
            type=type,
            amount=amount,
            card_type=card_type,
            description=description,
            is_deposit=is_deposit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostPaymentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_payment_post_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account identifier is necessary if reservationID not sent")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="The Sub Reservation identifier. reservationID is still mandatory if subReservationID is sent.")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Payment type. Use the call [getPaymentMethods](#api-Payment-getPaymentMethods) to get the properties enabled payment methods.")] = None,
        amount: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Amount paid on this transaction")] = None,
        card_type: Annotated[Optional[StrictStr], Field(description="If type = credit, cardType is necessary. Allowed values are property based, but possible strings are: \\\"visa\\\",\\\"master\\\",\\\"amex\\\",\\\"aura\\\",\\\"diners\\\",\\\"hiper\\\",\\\"elo\\\",\\\"Discover\\\",\\\"jcb\\\",\\\"maestro\\\",\\\"dan\\\",\\\"PostCard\\\",\\\"Eurocard\\\",\\\"union_pay\\\"")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Note to be added to payment")] = None,
        is_deposit: Annotated[Optional[StrictBool], Field(description="determine if this payment is a deposit (default: false)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postPayment

        Add a payment to a specified reservation or house account. If both Reservation ID and HouseAccountID are informed, only the former is taken in consideration.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier
        :type reservation_id: str
        :param house_account_id: House Account identifier is necessary if reservationID not sent
        :type house_account_id: str
        :param sub_reservation_id: The Sub Reservation identifier. reservationID is still mandatory if subReservationID is sent.
        :type sub_reservation_id: str
        :param type: Payment type. Use the call [getPaymentMethods](#api-Payment-getPaymentMethods) to get the properties enabled payment methods.
        :type type: str
        :param amount: Amount paid on this transaction
        :type amount: float
        :param card_type: If type = credit, cardType is necessary. Allowed values are property based, but possible strings are: \\\"visa\\\",\\\"master\\\",\\\"amex\\\",\\\"aura\\\",\\\"diners\\\",\\\"hiper\\\",\\\"elo\\\",\\\"Discover\\\",\\\"jcb\\\",\\\"maestro\\\",\\\"dan\\\",\\\"PostCard\\\",\\\"Eurocard\\\",\\\"union_pay\\\"
        :type card_type: str
        :param description: Note to be added to payment
        :type description: str
        :param is_deposit: determine if this payment is a deposit (default: false)
        :type is_deposit: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_payment_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            sub_reservation_id=sub_reservation_id,
            type=type,
            amount=amount,
            card_type=card_type,
            description=description,
            is_deposit=is_deposit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostPaymentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_payment_post_serialize(
        self,
        property_id,
        reservation_id,
        house_account_id,
        sub_reservation_id,
        type,
        amount,
        card_type,
        description,
        is_deposit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if house_account_id is not None:
            _form_params.append(('houseAccountID', house_account_id))
        if sub_reservation_id is not None:
            _form_params.append(('subReservationID', sub_reservation_id))
        if type is not None:
            _form_params.append(('type', type))
        if amount is not None:
            _form_params.append(('amount', amount))
        if card_type is not None:
            _form_params.append(('cardType', card_type))
        if description is not None:
            _form_params.append(('description', description))
        if is_deposit is not None:
            _form_params.append(('isDeposit', is_deposit))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postPayment',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_void_payment_post(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account identifier is necessary if reservationID not sent")] = None,
        payment_id: Annotated[Optional[StrictStr], Field(description="paymentID of transaction that should be voided.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostVoidPaymentResponse:
        """postVoidPayment

        Voids a payment (using paymentID) to a specified reservation or house account.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier
        :type reservation_id: str
        :param house_account_id: House Account identifier is necessary if reservationID not sent
        :type house_account_id: str
        :param payment_id: paymentID of transaction that should be voided.
        :type payment_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_void_payment_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            payment_id=payment_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostVoidPaymentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_void_payment_post_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account identifier is necessary if reservationID not sent")] = None,
        payment_id: Annotated[Optional[StrictStr], Field(description="paymentID of transaction that should be voided.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostVoidPaymentResponse]:
        """postVoidPayment

        Voids a payment (using paymentID) to a specified reservation or house account.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier
        :type reservation_id: str
        :param house_account_id: House Account identifier is necessary if reservationID not sent
        :type house_account_id: str
        :param payment_id: paymentID of transaction that should be voided.
        :type payment_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_void_payment_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            payment_id=payment_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostVoidPaymentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_void_payment_post_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account identifier is necessary if reservationID not sent")] = None,
        payment_id: Annotated[Optional[StrictStr], Field(description="paymentID of transaction that should be voided.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postVoidPayment

        Voids a payment (using paymentID) to a specified reservation or house account.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier
        :type reservation_id: str
        :param house_account_id: House Account identifier is necessary if reservationID not sent
        :type house_account_id: str
        :param payment_id: paymentID of transaction that should be voided.
        :type payment_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_void_payment_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            payment_id=payment_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostVoidPaymentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_void_payment_post_serialize(
        self,
        property_id,
        reservation_id,
        house_account_id,
        payment_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if house_account_id is not None:
            _form_params.append(('houseAccountID', house_account_id))
        if payment_id is not None:
            _form_params.append(('paymentID', payment_id))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postVoidPayment',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


