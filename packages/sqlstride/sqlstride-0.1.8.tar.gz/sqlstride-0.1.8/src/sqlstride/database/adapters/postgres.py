# sqlstride/adapters/postgres.py
import subprocess

from etl.database.sql_dialects import postgres
from sqlalchemy import PoolProxiedConnection
from sqlstride.database.connector_proxy import build_connector

from .base import BaseAdapter
from ..database_object import DatabaseObject


class PostgresAdapter(BaseAdapter):
    dialect = postgres

    def __init__(self, config):
        connection: PoolProxiedConnection = build_connector(config).to_user_postgres()
        super().__init__(connection, config.default_schema, config.log_table, config.lock_table)

    def discover_objects(self):
        cur = self.cursor
        # Tables via pg_dump
        cur.execute("""
                    SELECT table_schema, table_name
                    FROM information_schema.tables
                    WHERE table_type = 'BASE TABLE'
                      AND table_schema NOT IN ('pg_catalog', 'information_schema');
                    """)
        for schema, table in cur.fetchall():
            ddl_query = f"""
WITH cols AS (SELECT c.table_schema,
                     c.table_name,
                     c.ordinal_position,

                  /* complete column-definition text */
                     FORMAT(
                             '%I %s%s%s%s',
                             c.column_name, -- column name
                     /* data type */
                             CASE
                                 WHEN c.data_type IN ('character', 'character varying')
                                     THEN 'varchar(' || c.character_maximum_length || ')'
                                 WHEN c.data_type IN ('numeric', 'decimal')
                                     THEN c.data_type || '(' || c.numeric_precision || ',' || c.numeric_scale || ')'
                                 ELSE c.data_type
                                 END,
                         /* identity / serial */
                             CASE
                                 WHEN pg_get_serial_sequence(
                                         FORMAT('%I.%I', c.table_schema, c.table_name), -- qualified table
                                         c.column_name
                                      ) IS NOT NULL
                                     THEN ' GENERATED BY DEFAULT AS IDENTITY'
                                 ELSE ''
                                 END,
                         /* default value */
                             CASE
                                 WHEN c.column_default IS NOT NULL
                                     THEN ' DEFAULT ' || c.column_default
                                 ELSE ''
                                 END,
                         /* nullability */
                             CASE
                                 WHEN c.is_nullable = 'NO'
                                     THEN ' NOT NULL'
                                 ELSE ''
                                 END
                     ) AS col_ddl
              FROM information_schema.columns AS c
              WHERE c.table_schema = '{schema}'
                AND c.table_name = '{table}'),

     pk AS (SELECT tc.table_schema,
                   tc.table_name,
                   FORMAT(
                           'CONSTRAINT %I PRIMARY KEY (%s)',
                           tc.constraint_name,
                           STRING_AGG(kcu.column_name, ', ' ORDER BY kcu.ordinal_position)
                   ) AS pk_ddl
            FROM information_schema.table_constraints AS tc
                     JOIN information_schema.key_column_usage AS kcu
                          ON tc.constraint_name = kcu.constraint_name
                              AND tc.table_schema = kcu.table_schema
                              AND tc.table_name = kcu.table_name
            WHERE tc.constraint_type = 'PRIMARY KEY'
              AND tc.table_schema = '{schema}'
              AND tc.table_name = '{table}'
            GROUP BY tc.table_schema, tc.table_name, tc.constraint_name)

SELECT FORMAT(
               'CREATE TABLE IF NOT EXISTS %I.%I (\n    %s%s\n);',
               c.table_schema,
               c.table_name,
           /* columns */
               STRING_AGG(c.col_ddl, ',\n    ' ORDER BY c.ordinal_position),
           /* primary key clause, if any */
               COALESCE(E',\n    ' || pk.pk_ddl, '')
       ) AS ddl
FROM cols AS c
         LEFT JOIN pk
                   ON pk.table_schema = c.table_schema
                       AND pk.table_name = c.table_name
GROUP BY c.table_schema, c.table_name, pk.pk_ddl;
                   """
            cur.execute(ddl_query)

            ddl, = cur.fetchone()          # returns the generated DDL string
            yield DatabaseObject("table", schema, table, ddl)

        # Views
        cur.execute("""
                    SELECT table_schema,
                           table_name,
                           pg_get_viewdef(format('%I.%I', table_schema, table_name)::regclass, true)
                    FROM information_schema.views
                    WHERE table_schema NOT IN ('pg_catalog', 'information_schema');
                    """)
        for schema, view, ddl in cur.fetchall():
            yield DatabaseObject("view", schema, view,
                                 f"CREATE OR REPLACE VIEW {schema}.{view} AS\n{ddl};")

        # Functions
        cur.execute("""
                    SELECT n.nspname AS schema_name,
                           p.proname AS function_name,
                           pg_get_functiondef(p.oid) AS function_def
                    FROM pg_proc p
                    JOIN pg_namespace n ON p.pronamespace = n.oid
                    WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
                    AND p.prokind = 'f';
                    """)
        for schema, function_name, ddl in cur.fetchall():
            # Replace CREATE FUNCTION with CREATE OR REPLACE FUNCTION for idempotent creation
            if ddl.startswith("CREATE FUNCTION"):
                ddl = ddl.replace("CREATE FUNCTION", "CREATE OR REPLACE FUNCTION", 1)
            yield DatabaseObject("function", schema, function_name, ddl)

        # Procedures
        cur.execute("""
                    SELECT n.nspname           AS schema_name,
       p.proname           AS procedure_name,
       pg_get_function_identity_arguments(p.oid) AS arg_signature,
       pg_get_functiondef(p.oid)                 AS procedure_def
FROM   pg_proc      AS p
JOIN   pg_namespace AS n ON n.oid = p.pronamespace
WHERE  p.prokind = 'p'                         -- procedures only
  AND  n.nspname !~ '^pg_'                     -- exclude all pg_* schemas
  AND  n.nspname NOT IN ('information_schema') -- still exclude explicitly
  -- optional language / visibility / extension filters here
ORDER  BY n.nspname, p.proname, arg_signature;
                    """)
        for schema, procedure_name, ddl in cur.fetchall():
            # Replace CREATE PROCEDURE with CREATE OR REPLACE PROCEDURE for idempotent creation
            if ddl.startswith("CREATE PROCEDURE"):
                ddl = ddl.replace("CREATE PROCEDURE", "CREATE OR REPLACE PROCEDURE", 1)
            yield DatabaseObject("procedure", schema, procedure_name, ddl)

        # Triggers
        cur.execute("""
                    SELECT 
                        n.nspname AS schema_name,
                        t.tgname AS trigger_name,
                        pg_get_triggerdef(t.oid) AS trigger_def
                    FROM pg_trigger t
                    JOIN pg_class c ON t.tgrelid = c.oid
                    JOIN pg_namespace n ON c.relnamespace = n.oid
                    WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
                    AND NOT t.tgisinternal;
                    """)
        for schema, trigger_name, ddl in cur.fetchall():
            # Replace CREATE TRIGGER with CREATE OR REPLACE TRIGGER for idempotent creation
            # Note: PostgreSQL doesn't support CREATE OR REPLACE TRIGGER directly,
            # so we need to use DROP TRIGGER IF EXISTS followed by CREATE TRIGGER
            if ddl.startswith("CREATE TRIGGER"):
                table_name = ddl.split(" ON ")[1].split(" ")[0]
                ddl = f"DROP TRIGGER IF EXISTS {trigger_name} ON {table_name};\n{ddl}"
            yield DatabaseObject("trigger", schema, trigger_name, ddl)

        # Materialized Views
        cur.execute("""
                    SELECT 
                        n.nspname AS schema_name,
                        c.relname AS matview_name,
                        pg_get_viewdef(c.oid) AS matview_def
                    FROM pg_class c
                    JOIN pg_namespace n ON c.relnamespace = n.oid
                    WHERE n.nspname NOT IN ('pg_catalog', 'information_schema')
                    AND c.relkind = 'm';
                    """)
        for schema, matview_name, ddl in cur.fetchall():
            # PostgreSQL doesn't support CREATE OR REPLACE MATERIALIZED VIEW
            # We need to use DROP MATERIALIZED VIEW IF EXISTS followed by CREATE MATERIALIZED VIEW
            full_ddl = f"DROP MATERIALIZED VIEW IF EXISTS {schema}.{matview_name} CASCADE;\nCREATE MATERIALIZED VIEW {schema}.{matview_name} AS\n{ddl};"
            yield DatabaseObject("materialized_view", schema, matview_name, full_ddl)
