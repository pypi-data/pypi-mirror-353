# Copyright International Business Machines Corp, 2025
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import asyncio

class BhostsCollector:
    """
    Collection module for bhosts commands
    """

    def __init__(self, metrics_generator) -> None:

        # Command used to collect data
        self.command = "bhosts"

        # Class used to create and manage metrics
        self.metrics_generator = metrics_generator

        # Tuple's List of: metric name, metric description, metric type (Gauge, Info, Counter), metric labels list to create metric, metric label to fetch data
        self.metrics_list = [
            ("ibm_lsf_host_status", "Host status", "Gauge", ['host_name', 'host_type', 'status', 'cluster_name'], ""), (
            "ibm_lsf_host_mem_avail",
            "Available (Total) mem which is the raw available mem, minus the amount reserved by LSF for jobs", "Gauge",
            ['host_name', 'host_type', 'cluster_name'], "AVAILABLE_MEM"),
            ("ibm_lsf_host_mem_reserved", "The mem that reserved and occupied by dispatched jobs", "Gauge",
             ['host_name', 'host_type', 'cluster_name'], "RESERVED_MEM"),
            ("ibm_lsf_host_max", "Total slots (MXJ)", "Gauge", ['host_name', 'host_type', 'cluster_name'], "MAX"),
            ("ibm_lsf_host_njobs", "Number of occupied slots (NJOBS)", "Gauge",
             ['host_name', 'host_type', 'cluster_name'], "NJOBS"), (
            "ibm_lsf_host_run", "Slots occupied by RUN jobs", "Gauge", ['host_name', 'host_type', 'cluster_name'],
            "RUN"),
            ("ibm_lsf_host_ssusp", "Slots occupied by SSUSP jobs", "Gauge", ['host_name', 'host_type', 'cluster_name'],
             "SSUSP"), (
            "ibm_lsf_host_ususp", "Slots occupied by USUSP jobs", "Gauge", ['host_name', 'host_type', 'cluster_name'],
            "USUSP"),
            ("ibm_lsf_host_rsv", "Slots occupied by RSV jobs", "Gauge", ['host_name', 'host_type', 'cluster_name'],
             "RSV"),
            ("ibm_lsf_host_gpu", "Available GPUs (bhosts)", "Gauge", ['host_name', 'host_type', 'cluster_name'], "RSV"),
            ("ibm_lsf_host_gpu_rsv", "Reserved GPUs (bhosts)", "Gauge", ['host_name', 'host_type', 'cluster_name'],
             "NGPUS_EXCL_ALLOC")]

        # Metrics list generated by metrics_generator class
        self.metrics = self.metrics_generator.create_metrics(self.metrics_list)

    def fill_metric_labels(self, hostStatuses, hosts, name, metric, label, type, cluster_name):
        tmp_hosts_gpu_label = ["NGPUS","NGPUS_ALLOC","NGPUS_EXCL_ALLOC","NGPUS_SHARED_ALLOC","NGPUS_SHARED_JEXCL_ALLOC","NGPUS_EXCL_AVAIL","NGPUS_SHARED_AVAIL"]
        for host in hosts['RECORDS'] or []:
            closed = False
            for gpu_label in tmp_hosts_gpu_label:
                if host[gpu_label] == "":
                    host[gpu_label] = 0
            if self.metrics_generator.debug:
                print(
                    f"ibm_lsf_bhosts_{type} cluster_name={cluster_name} hostname={host['HOST_NAME']} state={host['STATUS']} available_mem={host['AVAILABLE_MEM']} " \
                    f"reserved_mem={host['RESERVED_MEM']} slots_max={host['MAX']} slots_used={host['NJOBS']} " \
                    f"slots_run={host['RUN']} slots_ssusp={host['SSUSP']}  slots_ususp={host['USUSP']} slots_rsv={host['RSV']} " \
                    f"gpu={host['NGPUS']} gpu_rsv={host['NGPUS_EXCL_ALLOC']}")

            if name == "ibm_lsf_host_status":
                if not self.metrics_generator.detailed_host_status:
                    for status in hostStatuses:
                        if "closed_" in status:
                            if status == host['STATUS']:
                                metric.labels(host['HOST_NAME'], type, "closed", cluster_name).set(1.0)
                                closed = True
                        else:
                            if status == host['STATUS']:
                                metric.labels(host['HOST_NAME'], type, status, cluster_name).set(1.0)
                            else:
                                metric.labels(host['HOST_NAME'], type, status, cluster_name).set(0.0)
                    if not closed:
                        metric.labels(host['HOST_NAME'], type, "closed", cluster_name).set(0.0)
                else:
                    for status in hostStatuses:
                        if status == host['STATUS']:
                            metric.labels(host['HOST_NAME'], type, status, cluster_name).set(1.0)
                        else:
                            metric.labels(host['HOST_NAME'], type, status, cluster_name).set(0.0)
            else:
                if label == "AVAILABLE_MEM" or label == "RESERVED_MEM":
                    metric.labels(host['HOST_NAME'], type, cluster_name).set(
                        float(str(host[label]).replace('M', '') or 0.0))
                else:
                    metric.labels(host['HOST_NAME'], type, cluster_name).set(host[label])

    def fetch(self, cluster_info):
        """
        Collects info from bhosts -o all -json
        """
        asyncio.run(self.fetch_async(cluster_info), debug=self.metrics_generator.debug)

    async def fetch_async(self, cluster_info):
        """
        Collects info from bhosts -o all -json
        """
        cluster_name = cluster_info["cluster_name"]
        cmd = [self.command, '-o', 'all', '-R', 'select[mg]', '-json']
        hosts, _, return_bool = await self.metrics_generator.collect_data_async(cmd,
                                                                    {**os.environ, 'LSB_UNIT_FOR_JOBS_DISPLAY': 'M'},
                                                                    "ibm_lsf_bhosts_management",
                                                                    "bhosts_management unavailable")
        hostStatuses = ['ok', 'closed_Adm', 'closed_Busy', 'closed_Excl', 'closed_cu_Excl', 'closed_Full', 'closed_LIM',
                        'closed_Lock', 'closed_Wind', 'closed_EGO', 'unavail', 'unreach']

        if return_bool:
            for (metric, name, label) in self.metrics:
                # First of all clean up the metric
                metric.clear()
                self.fill_metric_labels(hostStatuses, hosts, name, metric, label, "management", cluster_name)

        if not self.metrics_generator.filter_metrics_compute_nodes:
            cmd = [self.command, '-o', 'all', '-R', 'select[!mg]', '-json']
            hosts, _, return_bool = await self.metrics_generator.collect_data_async(cmd, {**os.environ,
                                                                              'LSB_UNIT_FOR_JOBS_DISPLAY': 'M'},
                                                                        "ibm_lsf_bhosts_compute",
                                                                        "bhosts_compute unavailable")

            if return_bool:
                for (metric, name, label) in self.metrics:
                    self.fill_metric_labels(hostStatuses, hosts, name, metric, label, "compute", cluster_name)
