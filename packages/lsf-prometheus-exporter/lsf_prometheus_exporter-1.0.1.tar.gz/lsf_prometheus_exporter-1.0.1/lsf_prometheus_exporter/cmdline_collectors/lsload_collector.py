# Copyright International Business Machines Corp, 2025
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import asyncio

class LsloadCollector:
    """
    Collection module for lsload commands
    """

    def __init__(self, metrics_generator) -> None:

        # Command used to collect data
        self.command = "lsload"

        # Class used to create and manage metrics
        self.metrics_generator = metrics_generator

        # Tuple's List of: metric name, metric description, metric type (Gauge, Info, Counter), metric labels list to create metric, metric label to fetch data
        self.metrics_list = [
            ("ibm_lsf_host_r15s", "r15s (lsload)", "Gauge", ['host_name', 'host_type', 'cluster_name'], "r15s"),
            ("ibm_lsf_host_r1m", "r1m (lsload)", "Gauge", ['host_name', 'host_type', 'cluster_name'], "r1m"),
            ("ibm_lsf_host_r15m", "r15m (lsload)", "Gauge", ['host_name', 'host_type', 'cluster_name'], "r15m"),
            ("ibm_lsf_host_ut", "ut (lsload)", "Gauge", ['host_name', 'host_type', 'cluster_name'], "ut"),
            ("ibm_lsf_host_pg", "pg (lsload)", "Gauge", ['host_name', 'host_type', 'cluster_name'], "pg"),
            ("ibm_lsf_host_ls", "ls", "Gauge", ['host_name', 'host_type', 'cluster_name'], "ls"),
            ("ibm_lsf_host_it", "it", "Gauge", ['host_name', 'host_type', 'cluster_name'], "it"),
            ("ibm_lsf_host_tmp", "tmp", "Gauge", ['host_name', 'host_type', 'cluster_name'], "tmp"),
            ("ibm_lsf_host_swp", "swp", "Gauge", ['host_name', 'host_type', 'cluster_name'], "swp"), (
            "ibm_lsf_host_mem", "Mem (this is the raw memory availability reported by the OS)", "Gauge",
            ['host_name', 'host_type', 'cluster_name'], "mem")]

        # Metrics list generated by metrics_generator class
        self.metrics = self.metrics_generator.create_metrics(self.metrics_list)

    def fill_metric_labels(self, lsload_info, metric, label, type, cluster_name):
        for host in lsload_info['RECORDS']:
            if self.metrics_generator.debug:
                print(
                    f"ibm_lsf_lsload_{type} cluster_name={cluster_name} hostname={host['HOST_NAME']} state={host['status']} " \
                    f"r15s={host['r15s']} r1m={host['r1m']} r15m={host['r15m']} " \
                    f"ut={host['ut']} pg={host['pg']} ls={host['ls']} it={host['it']} " \
                    f"tmp={host['tmp']} swp={host['swp']} mem={host['mem']}")

            if "r1" in label:
                # convert from human readable % back to float
                metric.labels(host['HOST_NAME'], type, cluster_name).set(host[label] or 0.0)
            else:
                if label == "ut":
                    metric.labels(host['HOST_NAME'], type, cluster_name).set(
                        float(str(host[label]).replace('%', '') or 0.0) / 100)
                else:
                    # unformat lsload's output. assumed to be displayed in MBs
                    metric.labels(host['HOST_NAME'], type, cluster_name).set(
                        float(str(host[label]).replace('M', '') or 0.0))

    def fetch(self, cluster_info):
        """
        Collects info from lsload -o * -json
        """
        asyncio.run(self.fetch_async(cluster_info), debug=self.metrics_generator.debug)

    async def fetch_async(self, cluster_info):
        """
        Collects info from lsload -o * -json
        """
        cluster_name = cluster_info["cluster_name"]
        # management_node command call
        cmd = [self.command, '-o', '\"*\"', '-R', 'select[mg]', '-json']
        lsload_info, _, return_bool = await self.metrics_generator.collect_data_async(cmd, "", "ibm_lsf_lsload_mg",
                                                                          "lsload_mg unavailable")

        if return_bool:
            for (metric, name, label) in self.metrics:
                # First of all clean up the metric
                metric.clear()
                self.fill_metric_labels(lsload_info, metric, label, "management", cluster_name)

        # compute_node command call
        if not self.metrics_generator.filter_metrics_compute_nodes:
            cmd = [self.command, '-o', '\"*\"', '-R', 'select[!mg]', '-json']
            lsload_info, _, return_bool = await self.metrics_generator.collect_data_async(cmd, "", "ibm_lsf_lsload_compute",
                                                                              "lsload_compute unavailable")
            if return_bool:
                for (metric, name, label) in self.metrics:
                    self.fill_metric_labels(lsload_info, metric, label, "compute", cluster_name)
