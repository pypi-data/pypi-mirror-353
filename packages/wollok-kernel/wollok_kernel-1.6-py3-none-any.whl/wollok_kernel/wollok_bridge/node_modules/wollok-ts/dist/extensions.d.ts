export declare const keys: <T>(o: T) => Extract<keyof T, string>[];
export declare const last: <T>(xs: readonly T[]) => T | undefined;
export declare const valueAsListOrEmpty: <T>(value: T | undefined) => T[];
export declare const divideOn: (separator: string) => (str: string) => [string, string];
export declare const get: <T>(obj: any, path: string) => T | undefined;
export declare function discriminate<A, B = unknown>(isA: (obj: A | B) => obj is A): (list: ReadonlyArray<A | B>) => [A[], B[]];
export declare function discriminate<T>(isA: (obj: T) => boolean): (list: ReadonlyArray<T>) => [T[], T[]];
export declare const zipObj: (fieldNames: ReadonlyArray<string>, fieldValues: ReadonlyArray<any>) => Record<string, any>;
export declare const mapObject: <T, R = any>(tx: (value: T[keyof T], key: keyof T) => R, obj: T) => { [K in keyof T]: R; };
export declare const sum: (array: ReadonlyArray<number>) => number;
export declare const sumBy: <T>(array: readonly T[], tx: (elem: T) => number) => number;
export declare const traverse: <R>(generator: Generator<unknown, R, unknown>) => R;
export declare const hash: (str: string) => number;
export type List<T> = ReadonlyArray<T>;
export declare const isEmpty: <T>(value: List<T> | undefined) => boolean;
export declare const notEmpty: <T>(value: List<T> | undefined) => boolean;
export declare const duplicates: <T>(list: List<T>) => List<T>;
export declare const uniqueBy: <T>(collection: T[], property: keyof T) => T[];
export declare const excludeNullish: <T>(list: (T | undefined)[]) => T[];
export declare const count: <T>(list: List<T>, condition: (element: T) => boolean) => number;
export declare function raise(error: Error): never;
export declare const MIXINS: unique symbol;
export type TypeDefinition<T> = ClassDefinition<T> | MixinDefinition<T>;
export type ClassDefinition<T> = abstract new (...args: any) => T;
export type MixinDefinition<T> = (...args: any) => ClassDefinition<T>;
export type Mixable<T> = ClassDefinition<T> & {
    [MIXINS]?: MixinDefinition<T>[];
};
export type ConstructorFor<D extends TypeDefinition<any>> = D extends TypeDefinition<infer T> ? ClassDefinition<T> : never;
export type InstanceOf<D extends TypeDefinition<any>> = InstanceType<ConstructorFor<D>>;
export declare const is: <D extends TypeDefinition<any>>(definition: D) => (obj: any) => obj is InstanceType<ConstructorFor<D>>;
declare const OTHERWISE: "OTHERWISE";
export type TypeDefinitionMatch<T> = TypeDefinition<T> | typeof OTHERWISE;
export declare const match: <T>(matched: T) => <R, Cs extends any[]>(...cases: { [i in keyof Cs]: readonly [TypeDefinitionMatch<Cs[i]>, (m: Cs[i]) => R]; }) => R;
export declare const when: <T>(definition: TypeDefinition<T>) => <R>(handler: (m: T) => R) => readonly [TypeDefinition<T>, (m: T) => R];
export declare const otherwise: <T, R>(handler: (m: T) => R) => readonly ["OTHERWISE", (m: T) => R];
export declare const anyPredicate: <Element>(...conditions: ((x: Element) => boolean)[]) => (x: Element) => boolean;
export declare const regex: (regex: RegExp) => (value: string) => boolean;
export declare const hasWhitespace: (value: string) => boolean;
export {};
