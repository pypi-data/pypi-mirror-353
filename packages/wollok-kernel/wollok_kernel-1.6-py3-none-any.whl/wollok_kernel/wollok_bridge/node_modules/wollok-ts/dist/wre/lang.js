"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const extensions_1 = require("../extensions");
const helpers_1 = require("../helpers");
const runtimeModel_1 = require("../interpreter/runtimeModel");
const model_1 = require("../model");
const { abs, ceil, random, floor, round } = Math;
const { isInteger } = Number;
const { UTC } = Date;
function* internalFilter(evaluation, self, closure, newCollection) {
    (0, runtimeModel_1.assertIsNotNull)(closure, 'filter', 'closure');
    const result = [];
    for (const elem of [...self.innerCollection]) {
        const satisfies = (yield* evaluation.send(constants_1.APPLY_METHOD, closure, elem));
        (0, helpers_1.assertNotVoid)(satisfies, 'Message filter: closure produces no value. Check the return type of the closure (missing return?)');
        if (satisfies.innerBoolean) {
            result.push(elem);
        }
    }
    return yield* newCollection(evaluation, result);
}
function* internalFindOrElse(evaluation, self, predicate, continuation) {
    (0, runtimeModel_1.assertIsNotNull)(predicate, 'findOrElse', 'predicate');
    (0, runtimeModel_1.assertIsNotNull)(continuation, 'findOrElse', 'continuation');
    for (const elem of [...self.innerCollection]) {
        const value = (yield* evaluation.send(constants_1.APPLY_METHOD, predicate, elem));
        (0, helpers_1.assertNotVoid)(value, 'Message findOrElse: predicate produces no value. Check the return type of the closure (missing return?)');
        if (value.innerBoolean)
            return elem;
    }
    return yield* evaluation.send(constants_1.APPLY_METHOD, continuation);
}
function* internalFold(evaluation, self, initialValue, closure) {
    (0, runtimeModel_1.assertIsNotNull)(closure, 'fold', 'closure');
    let acum = initialValue;
    for (const elem of [...self.innerCollection]) {
        acum = (yield* evaluation.send(constants_1.APPLY_METHOD, closure, acum, elem));
        (0, helpers_1.assertNotVoid)(acum, 'Message fold: closure produces no value. Check the return type of the closure (missing return?)');
    }
    return acum;
}
function* internalMax(evaluation, self) {
    const method = evaluation.environment.getNodeByFQN(constants_1.COLLECTION_MODULE).lookupMethod('max', 0);
    return yield* evaluation.invoke(method, self);
}
function* internalRemove(self, element) {
    const values = self.innerCollection;
    const index = values.indexOf(element);
    if (index >= 0)
        values.splice(index, 1);
}
function* internalSize(evaluation, self) {
    return yield* evaluation.reify(self.innerCollection.length);
}
function* internalClear(self) {
    const values = self.innerCollection;
    values.splice(0, values.length);
}
function* internalJoin(evaluation, self, separator) {
    const method = evaluation.environment.getNodeByFQN(constants_1.COLLECTION_MODULE).lookupMethod('join', separator ? 1 : 0);
    return yield* evaluation.invoke(method, self, ...separator ? [separator] : []);
}
function* internalContains(evaluation, self, value) {
    const method = evaluation.environment.getNodeByFQN(constants_1.COLLECTION_MODULE).lookupMethod('contains', 1);
    return yield* evaluation.invoke(method, self, value);
}
const lang = {
    Exception: {
        *initialize(self) {
            const stackTraceElements = [];
            const customFrames = this.frameStack.slice(0, -1).filter(frame => frame.isCustom());
            for (const frame of customFrames) {
                const stackTraceElement = yield* this.send('createStackTraceElement', self, yield* this.reify(frame.description), yield* this.reify(frame.sourceInfo));
                stackTraceElements.unshift(stackTraceElement);
            }
            self.set('<stackTrace>', yield* this.list(...stackTraceElements));
        },
        *getFullStackTrace(self) {
            return self.get('<stackTrace>');
        },
        *getStackTrace(self) {
            return yield* this.send('getFullStackTrace', self);
        },
    },
    Object: {
        *identity(self) {
            return yield* this.reify(self.id);
        },
        *kindName(self) {
            if (self.innerValue === null)
                return yield* this.reify('null');
            const onlyModuleName = self.module.fullyQualifiedName.split('.').pop();
            const aOrAn = onlyModuleName.match(/^[AEIOUaeiou]+.*/) ? 'an' : 'a';
            const kindName = self.module.is(model_1.Singleton) && self.module.name ||
                aOrAn + ' ' + onlyModuleName;
            return yield* this.reify(kindName);
        },
        *className(self) {
            return yield* this.reify(self.module.fullyQualifiedName);
        },
        *generateDoesNotUnderstandMessage(_self, target, messageName, parametersSize) {
            (0, runtimeModel_1.assertIsString)(target, 'generateDoesNotUnderstandMessage', 'target', false);
            (0, runtimeModel_1.assertIsString)(messageName, 'generateDoesNotUnderstandMessage', 'messageName', false);
            (0, runtimeModel_1.assertIsNumber)(parametersSize, 'generateDoesNotUnderstandMessage', 'parametersSize', false);
            const argsText = new Array(parametersSize.innerNumber).fill(null).map((_, i) => `arg ${i}`);
            const text = `${target.innerString} does not understand ${messageName.innerString}(${argsText})`;
            return yield* this.reify(text);
        },
        *checkNotNull(_self, value, message) {
            (0, runtimeModel_1.assertIsString)(message, 'checkNotNull', 'message', false);
            if (value.innerValue === null)
                throw new RangeError(`Message ${message.innerValue} does not allow to receive null values`);
        },
    },
    Collection: {
        *findOrElse(self, predicate, continuation) {
            return yield* internalFindOrElse(this, self, predicate, continuation);
        },
    },
    Set: {
        *anyOne(self) {
            const values = self.innerCollection;
            if ((0, extensions_1.isEmpty)(values))
                throw new RangeError('anyOne: list should not be empty');
            return values[floor(random() * values.length)];
        },
        *fold(self, initialValue, closure) {
            return yield* internalFold(this, self, initialValue, closure);
        },
        *filter(self, closure) {
            return yield* internalFilter(this, self, closure, (evaluation, result) => evaluation.set(...result));
        },
        *max(self) {
            return yield* internalMax(this, self);
        },
        *findOrElse(self, predicate, continuation) {
            return yield* internalFindOrElse(this, self, predicate, continuation);
        },
        *add(self, element) {
            if (!(yield* this.send('contains', self, element)).innerBoolean)
                yield* this.send('unsafeAdd', self, element);
        },
        *unsafeAdd(self, element) {
            self.innerCollection.push(element);
        },
        *remove(self, element) {
            return yield* internalRemove(self, element);
        },
        *size(self) {
            return yield* internalSize(this, self);
        },
        *clear(self) {
            return yield* internalClear(self);
        },
        *join(self, separator) {
            return yield* internalJoin(this, self, separator);
        },
        *contains(self, value) {
            return yield* internalContains(this, self, value);
        },
        *['=='](self, other) {
            if (self.module !== other.module)
                return yield* this.reify(false);
            if (self.innerCollection.length !== other.innerCollection.length)
                return yield* this.reify(false);
            for (const elem of [...self.innerCollection])
                if (!(yield* this.send('contains', other, elem)).innerBoolean)
                    return yield* this.reify(false);
            return yield* this.reify(true);
        },
    },
    List: {
        *get(self, index) {
            (0, runtimeModel_1.assertIsNumber)(index, 'get', 'index');
            const values = self.innerCollection;
            const indexValue = index.innerNumber;
            if (indexValue < 0 || indexValue >= values.length)
                throw new RangeError(`get: index should be between 0 and ${values.length - 1}`);
            return values[round(indexValue)];
        },
        *sortBy(self, closure) {
            (0, runtimeModel_1.assertIsNotNull)(closure, 'sortBy', 'closure');
            function* quickSort(list) {
                if (list.length < 2)
                    return [...list];
                const [head, ...tail] = list;
                const before = [];
                const after = [];
                for (const elem of tail) {
                    const comparison = (yield* this.send(constants_1.APPLY_METHOD, closure, elem, head));
                    (0, helpers_1.assertNotVoid)(comparison, 'Message sortBy: closure produces no value. Check the return type of the closure (missing return?)');
                    if (comparison.innerBoolean)
                        before.push(elem);
                    else
                        after.push(elem);
                }
                const sortedBefore = yield* quickSort.call(this, before);
                const sortedAfter = yield* quickSort.call(this, after);
                return [...sortedBefore, head, ...sortedAfter];
            }
            const values = self.innerCollection;
            const sorted = yield* quickSort.call(this, values);
            values.splice(0, values.length);
            values.push(...sorted);
        },
        *filter(self, closure) {
            return yield* internalFilter(this, self, closure, (evaluation, result) => evaluation.list(...result));
        },
        *contains(self, value) {
            return yield* internalContains(this, self, value);
        },
        *max(self) {
            return yield* internalMax(this, self);
        },
        *fold(self, initialValue, closure) {
            return yield* internalFold(this, self, initialValue, closure);
        },
        *findOrElse(self, predicate, continuation) {
            return yield* internalFindOrElse(this, self, predicate, continuation);
        },
        *add(self, element) {
            self.innerCollection.push(element);
        },
        *remove(self, element) {
            return yield* internalRemove(self, element);
        },
        *size(self) {
            return yield* internalSize(this, self);
        },
        *clear(self) {
            return yield* internalClear(self);
        },
        *join(self, separator) {
            return yield* internalJoin(this, self, separator);
        },
        *['=='](self, other) {
            if (self.module !== other.module)
                return yield* this.reify(false);
            const values = self.innerCollection;
            const otherValues = other.innerCollection;
            if (values.length !== otherValues.length)
                return yield* this.reify(false);
            for (let index = 0; index < values.length; index++)
                if (!(yield* this.send('==', values[index], otherValues[index])).innerBoolean)
                    return yield* this.reify(false);
            return yield* this.reify(true);
        },
        *withoutDuplicates(self) {
            const result = [];
            for (const elem of [...self.innerCollection]) {
                let alreadyIncluded = false;
                for (const included of result)
                    if ((yield* this.send('==', elem, included)).innerBoolean) {
                        alreadyIncluded = true;
                        break;
                    }
                if (!alreadyIncluded)
                    result.push(elem);
            }
            return yield* this.list(...result);
        },
    },
    Dictionary: {
        *initialize(self) {
            return yield* this.send('clear', self);
        },
        *put(self, key, value) {
            var _a, _b;
            (0, runtimeModel_1.assertIsNotNull)(key, 'put', '_key');
            (0, runtimeModel_1.assertIsNotNull)(value, 'put', '_value');
            const buckets = self.get('<buckets>').innerCollection;
            const index = (0, extensions_1.hash)(`${(_b = (_a = key.innerNumber) !== null && _a !== void 0 ? _a : key.innerString) !== null && _b !== void 0 ? _b : key.module.fullyQualifiedName}`) % buckets.length;
            const bucket = buckets[index].innerCollection;
            for (let i = 0; i < bucket.length; i++) {
                const entry = bucket[i].innerCollection;
                if ((yield* this.send('==', entry[0], key)).innerBoolean) {
                    entry[1] = value;
                    return;
                }
            }
            bucket.push(yield* this.list(key, value));
        },
        *basicGet(self, key) {
            var _a, _b;
            (0, runtimeModel_1.assertIsNotNull)(key, 'basicGet', '_key');
            const buckets = self.get('<buckets>').innerCollection;
            const index = (0, extensions_1.hash)(`${(_b = (_a = key.innerNumber) !== null && _a !== void 0 ? _a : key.innerString) !== null && _b !== void 0 ? _b : key.module.fullyQualifiedName}`) % buckets.length;
            const bucket = buckets[index].innerCollection;
            for (const entry of bucket) {
                const [entryKey, entryValue] = entry.innerCollection;
                if ((yield* this.send('==', entryKey, key)).innerBoolean)
                    return entryValue;
            }
            return yield* this.reify(null);
        },
        *remove(self, key) {
            var _a, _b;
            const buckets = self.get('<buckets>').innerCollection;
            const index = (0, extensions_1.hash)(`${(_b = (_a = key.innerNumber) !== null && _a !== void 0 ? _a : key.innerString) !== null && _b !== void 0 ? _b : key.module.fullyQualifiedName}`) % buckets.length;
            const bucket = buckets[index].innerCollection;
            for (let i = 0; i < bucket.length; i++) {
                const [entryKey] = bucket[i].innerCollection;
                if ((yield* this.send('==', entryKey, key)).innerBoolean) {
                    bucket.splice(i, 1);
                    return;
                }
            }
        },
        *keys(self) {
            const buckets = self.get('<buckets>').innerCollection;
            const response = [];
            for (const bucket of buckets) {
                for (const entry of bucket.innerCollection) {
                    const [entryKey] = entry.innerCollection;
                    response.push(entryKey);
                }
            }
            return yield* this.list(...response);
        },
        *values(self) {
            const buckets = self.get('<buckets>').innerCollection;
            const response = [];
            for (const bucket of buckets) {
                for (const entry of bucket.innerCollection) {
                    const [, entryValue] = entry.innerCollection;
                    response.push(entryValue);
                }
            }
            return yield* this.list(...response);
        },
        *forEach(self, closure) {
            (0, runtimeModel_1.assertIsNotNull)(closure, 'forEach', 'closure');
            const buckets = self.get('<buckets>').innerCollection;
            for (const bucket of buckets) {
                for (const entry of bucket.innerCollection) {
                    const [entryKey, entryValue] = entry.innerCollection;
                    yield* this.send(constants_1.APPLY_METHOD, closure, entryKey, entryValue);
                }
            }
        },
        *clear(self) {
            const buckets = [];
            for (let i = 0; i < 16; i++)
                buckets.push(yield* this.list());
            self.set('<buckets>', yield* this.list(...buckets));
        },
    },
    Number: {
        *coerceToInteger(self) {
            const num = self.innerNumber.toString();
            const decimalPosition = num.indexOf('.');
            return decimalPosition >= 0
                ? yield* this.reify(Number(num.slice(0, decimalPosition + 1)))
                : self;
        },
        *coerceToPositiveInteger(self) {
            if (self.innerNumber < 0)
                throw new RangeError('coerceToPositiveInteger: self should be zero or positive number');
            const num = self.innerNumber.toString();
            const decimalPosition = num.indexOf('.');
            return decimalPosition >= 0
                ? yield* this.reify(Number(num.slice(0, decimalPosition + 1)))
                : self;
        },
        *['==='](self, other) {
            return yield* this.reify(self.innerNumber === (other === null || other === void 0 ? void 0 : other.innerNumber));
        },
        *['+'](self, other) {
            (0, runtimeModel_1.assertIsNumber)(other, '(+)', 'other');
            return yield* this.reify(self.innerNumber + other.innerNumber);
        },
        *['-'](self, other) {
            (0, runtimeModel_1.assertIsNumber)(other, '(-)', 'other');
            return yield* this.reify(self.innerNumber - other.innerNumber);
        },
        *['*'](self, other) {
            (0, runtimeModel_1.assertIsNumber)(other, '(*)', 'other');
            return yield* this.reify(self.innerNumber * other.innerNumber);
        },
        *['/'](self, other) {
            (0, runtimeModel_1.assertIsNumber)(other, '(/)', 'other');
            if (other.innerNumber === 0)
                throw new RangeError('Message (/): quotient should not be zero');
            return yield* this.reify(self.innerNumber / other.innerNumber);
        },
        *['**'](self, other) {
            (0, runtimeModel_1.assertIsNumber)(other, '(**)', 'other');
            return yield* this.reify(self.innerNumber ** other.innerNumber);
        },
        *['%'](self, other) {
            (0, runtimeModel_1.assertIsNumber)(other, '(%)', 'other');
            return yield* this.reify(self.innerNumber % other.innerNumber);
        },
        *toString(self) {
            return yield* this.reify(`${self.innerNumber}`);
        },
        *['>'](self, other) {
            (0, runtimeModel_1.assertIsNumber)(other, '(>)', 'other');
            return yield* this.reify(self.innerNumber > other.innerNumber);
        },
        *['<'](self, other) {
            (0, runtimeModel_1.assertIsNumber)(other, '(<)', 'other');
            return yield* this.reify(self.innerNumber < other.innerNumber);
        },
        *abs(self) {
            return yield* this.reify(abs(self.innerNumber));
        },
        *invert(self) {
            return yield* this.reify(-self.innerNumber);
        },
        *roundUp(self, decimals) {
            (0, runtimeModel_1.assertIsNumber)(decimals, 'roundUp', '_decimals');
            if (decimals.innerNumber < 0)
                throw new RangeError('roundUp: decimals should be zero or positive number');
            return yield* this.reify(ceil(self.innerNumber * 10 ** decimals.innerNumber) / 10 ** decimals.innerNumber);
        },
        *truncate(self, decimals) {
            (0, runtimeModel_1.assertIsNumber)(decimals, 'truncate', '_decimals');
            if (decimals.innerNumber < 0)
                throw new RangeError('truncate: decimals should be zero or positive number');
            const num = self.innerNumber.toString();
            const decimalPosition = num.indexOf('.');
            return decimalPosition >= 0
                ? yield* this.reify(Number(num.slice(0, decimalPosition + decimals.innerNumber + 1)))
                : self;
        },
        *randomUpTo(self, max) {
            (0, runtimeModel_1.assertIsNumber)(max, 'randomUpTo', 'max');
            return yield* this.reify(random() * (max.innerNumber - self.innerNumber) + self.innerNumber);
        },
        *round(self) {
            return yield* this.reify(round(self.innerNumber));
        },
        *gcd(self, other) {
            (0, runtimeModel_1.assertIsNumber)(other, 'gcd', 'other');
            const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
            return yield* this.reify(gcd(self.innerNumber, other.innerNumber));
        },
        *isInteger(self) {
            return yield* this.reify(isInteger(self.innerNumber));
        },
    },
    String: {
        *length(self) {
            return yield* this.reify(self.innerString.length);
        },
        *concat(self, other) {
            (0, runtimeModel_1.assertIsNotNull)(other, 'concat', 'other');
            return yield* this.reify(self.innerString + (yield* this.send(constants_1.TO_STRING_METHOD, other)).innerString);
        },
        *startsWith(self, prefix) {
            (0, runtimeModel_1.assertIsString)(prefix, 'startsWith', 'prefix');
            return yield* this.reify(self.innerString.startsWith(prefix.innerString));
        },
        *endsWith(self, suffix) {
            (0, runtimeModel_1.assertIsString)(suffix, 'startsWith', 'suffix');
            return yield* this.reify(self.innerString.endsWith(suffix.innerString));
        },
        *indexOf(self, other) {
            (0, runtimeModel_1.assertIsString)(other, 'indexOf', 'other');
            const index = self.innerString.indexOf(other.innerString);
            if (index < 0)
                throw new RangeError('indexOf: other should be zero or positive number');
            return yield* this.reify(index);
        },
        *lastIndexOf(self, other) {
            (0, runtimeModel_1.assertIsString)(other, 'lastIndexOf', 'other');
            const index = self.innerString.lastIndexOf(other.innerString);
            if (index < 0)
                throw new RangeError('lastIndexOf: other should be zero or positive nummber');
            return yield* this.reify(index);
        },
        *toLowerCase(self) {
            return yield* this.reify(self.innerString.toLowerCase());
        },
        *toUpperCase(self) {
            return yield* this.reify(self.innerString.toUpperCase());
        },
        *trim(self) {
            return yield* this.reify(self.innerString.trim());
        },
        *reverse(self) {
            return yield* this.reify(self.innerString.split('').reverse().join(''));
        },
        *['<'](self, aString) {
            (0, runtimeModel_1.assertIsString)(aString, '(<)', 'aString');
            return yield* this.reify(self.innerString < aString.innerString);
        },
        *['>'](self, aString) {
            (0, runtimeModel_1.assertIsString)(aString, '(>)', 'aString');
            return yield* this.reify(self.innerString > aString.innerString);
        },
        *contains(self, element) {
            (0, runtimeModel_1.assertIsString)(element, 'contains', 'element');
            return yield* this.reify(self.innerString.indexOf(element.innerString) >= 0);
        },
        *substring(self, startIndex, endIndex) {
            (0, runtimeModel_1.assertIsNumber)(startIndex, 'substring', 'startIndex');
            const start = startIndex.innerNumber;
            const end = endIndex === null || endIndex === void 0 ? void 0 : endIndex.innerNumber;
            if (start < 0)
                throw new RangeError('substring: startIndex should be zero or positive number');
            if (endIndex && end === undefined || end !== undefined && end < 0)
                throw new RangeError('substring: endIndex should be zero or positive number');
            return yield* this.reify(self.innerString.substring(start, end));
        },
        *replace(self, expression, replacement) {
            (0, runtimeModel_1.assertIsString)(expression, 'replace', 'expression');
            (0, runtimeModel_1.assertIsString)(replacement, 'replace', 'replacement');
            return yield* this.reify(self.innerString.replace(new RegExp(expression.innerString, 'g'), replacement.innerString));
        },
        *toString(self) {
            return self;
        },
        *['=='](self, other) {
            return yield* this.reify(self.innerString === other.innerString);
        },
    },
    Boolean: {
        *['&&'](_self, other) {
            return other;
        },
        *and(_self, other) {
            return other;
        },
        *['||'](_self, other) {
            return other;
        },
        *or(_self, other) {
            return other;
        },
        *toString(self) {
            return yield* this.reify(`${self.innerBoolean}`);
        },
        *['=='](self, other) {
            return yield* this.reify(self === other);
        },
        *negate(self) {
            return yield* this.reify(!self.innerBoolean);
        },
    },
    Range: {
        *forEach(self, closure) {
            (0, runtimeModel_1.assertIsNotNull)(closure, 'forEach', 'closure');
            const start = self.get('start').innerNumber;
            const end = self.get('end').innerNumber;
            const step = self.get('step').innerNumber;
            if (start <= end && step > 0)
                for (let value = start; value <= end; value += step)
                    yield* this.send(constants_1.APPLY_METHOD, closure, yield* this.reify(value));
            if (start >= end && step < 0)
                for (let value = start; value >= end; value += step)
                    yield* this.send(constants_1.APPLY_METHOD, closure, yield* this.reify(value));
        },
        *anyOne(self) {
            const start = self.get('start').innerNumber;
            const end = self.get('end').innerNumber;
            const step = self.get('step').innerNumber;
            const values = [];
            if (start <= end && step > 0)
                for (let value = start; value <= end; value += step)
                    values.push(value);
            if (start >= end && step < 0)
                for (let value = start; value >= end; value += step)
                    values.push(value);
            return yield* this.reify(values[floor(random() * values.length)]);
        },
    },
    Closure: {
        *apply(self, args) {
            var _a;
            (0, runtimeModel_1.assertIsCollection)(args);
            const method = self.module.lookupMethod(constants_1.CLOSURE_EVALUATE_METHOD, args.innerCollection.length);
            if (!method)
                return yield* this.send('messageNotUnderstood', self, yield* this.reify(constants_1.APPLY_METHOD), args);
            const locals = yield* this.localsFor(method, args.innerCollection);
            const frame = new runtimeModel_1.Frame(method, self, locals);
            frame.set(constants_1.KEYWORDS.SELF, (_a = self.parentContext) === null || _a === void 0 ? void 0 : _a.get(constants_1.KEYWORDS.SELF));
            const result = yield* this.exec(method, frame);
            return result === undefined ? yield* this.reifyVoid() : result;
        },
        *toString(self) {
            var _a;
            return (_a = self.get(constants_1.CLOSURE_TO_STRING_METHOD)) !== null && _a !== void 0 ? _a : (yield* this.reify(`${self.module.fullyQualifiedName}#${self.id}`));
        },
    },
    calendar: {
        *today(_self) {
            const today = new Date();
            return yield* this.instantiate(constants_1.DATE_MODULE, {
                day: yield* this.reify(today.getDate()),
                month: yield* this.reify(today.getMonth() + 1),
                year: yield* this.reify(today.getFullYear()),
            });
        },
    },
    Date: {
        *shortDescription(self) {
            return yield* this.reify(`${self.get('month').innerNumber}/${self.get('day').innerNumber}/${self.get('year').innerNumber}`);
        },
        *isLeapYear(self) {
            return yield* this.reify(new Date(self.get('year').innerNumber, 1, 29).getDate() === 29);
        },
        *internalDayOfWeek(self) {
            const day = self.get('day').innerNumber;
            const month = self.get('month').innerNumber - 1;
            const year = self.get('year').innerNumber;
            const value = new Date(year, month, day);
            return yield* this.reify(value.getDay() == 0 ? 7 : value.getDay());
        },
        *plusDays(self, days) {
            (0, runtimeModel_1.assertIsNumber)(days, 'plusDays', '_days');
            const day = self.get('day').innerNumber;
            const month = self.get('month').innerNumber - 1;
            const year = self.get('year').innerNumber;
            const value = new Date(year, month, day + floor(days.innerNumber));
            return yield* this.instantiate(self.module, {
                day: yield* this.reify(value.getDate()),
                month: yield* this.reify(value.getMonth() + 1),
                year: yield* this.reify(value.getFullYear()),
            });
        },
        *minusDays(self, days) {
            (0, runtimeModel_1.assertIsNumber)(days, 'minusDays', '_days');
            const day = self.get('day').innerNumber;
            const month = self.get('month').innerNumber - 1;
            const year = self.get('year').innerNumber;
            const value = new Date(year, month, day - floor(days.innerNumber));
            return yield* this.instantiate(self.module, {
                day: yield* this.reify(value.getDate()),
                month: yield* this.reify(value.getMonth() + 1),
                year: yield* this.reify(value.getFullYear()),
            });
        },
        *plusMonths(self, months) {
            (0, runtimeModel_1.assertIsNumber)(months, 'plusMonths', '_months');
            const day = self.get('day').innerNumber;
            const month = self.get('month').innerNumber - 1;
            const year = self.get('year').innerNumber;
            const value = new Date(year, month + floor(months.innerNumber), day);
            while (months.innerNumber > 0 && value.getMonth() > (month + months.innerNumber) % 12)
                value.setDate(value.getDate() - 1);
            return yield* this.instantiate(self.module, {
                day: yield* this.reify(value.getDate()),
                month: yield* this.reify(value.getMonth() + 1),
                year: yield* this.reify(value.getFullYear()),
            });
        },
        *minusMonths(self, months) {
            (0, runtimeModel_1.assertIsNumber)(months, 'minusMonths', '_months');
            const day = self.get('day').innerNumber;
            const month = self.get('month').innerNumber - 1;
            const year = self.get('year').innerNumber;
            const value = new Date(year, month - floor(months.innerNumber), day);
            return yield* this.instantiate(self.module, {
                day: yield* this.reify(value.getDate()),
                month: yield* this.reify(value.getMonth() + 1),
                year: yield* this.reify(value.getFullYear()),
            });
        },
        *plusYears(self, years) {
            (0, runtimeModel_1.assertIsNumber)(years, 'plusYears', '_years');
            const day = self.get('day').innerNumber;
            const month = self.get('month').innerNumber - 1;
            const year = self.get('year').innerNumber;
            const value = new Date(year + floor(years.innerNumber), month, day);
            if (years.innerNumber > 0 && value.getDate() !== day) {
                value.setDate(value.getDate() - 1);
            }
            return yield* this.instantiate(self.module, {
                day: yield* this.reify(value.getDate()),
                month: yield* this.reify(value.getMonth() + 1),
                year: yield* this.reify(value.getFullYear()),
            });
        },
        *minusYears(self, years) {
            (0, runtimeModel_1.assertIsNumber)(years, 'minusYears', '_years');
            const day = self.get('day').innerNumber;
            const month = self.get('month').innerNumber - 1;
            const year = self.get('year').innerNumber;
            const value = new Date(year - floor(years.innerNumber), month, day);
            if (years.innerNumber > 0 && value.getDate() !== day) {
                value.setDate(value.getDate() - 1);
            }
            return yield* this.instantiate(self.module, {
                day: yield* this.reify(value.getDate()),
                month: yield* this.reify(value.getMonth() + 1),
                year: yield* this.reify(value.getFullYear()),
            });
        },
        *['=='](self, other) {
            return yield* this.reify(self.module === other.module &&
                self.get('day') === other.get('day') &&
                self.get('month') === other.get('month') &&
                self.get('year') === other.get('year'));
        },
        *['-'](self, aDate) {
            (0, runtimeModel_1.assertIsNotNull)(aDate, '(-)', '_aDate');
            if (aDate.module !== self.module)
                throw new TypeError(`Message (-): parameter ${(0, helpers_1.showParameter)(aDate)} should be a Date`);
            const ownDay = self.get('day').innerNumber;
            const ownMonth = self.get('month').innerNumber - 1;
            const ownYear = self.get('year').innerNumber;
            const otherDay = aDate.get('day').innerNumber;
            const otherMonth = aDate.get('month').innerNumber - 1;
            const otherYear = aDate.get('year').innerNumber;
            const msPerDay = 1000 * 60 * 60 * 24;
            const ownUTC = UTC(ownYear, ownMonth, ownDay);
            const otherUTC = UTC(otherYear, otherMonth, otherDay);
            return yield* this.reify(floor((ownUTC - otherUTC) / msPerDay));
        },
        *['<'](self, aDate) {
            (0, runtimeModel_1.assertIsNotNull)(aDate, '(<)', '_aDate');
            if (aDate.module !== self.module)
                throw new TypeError(`Message (<): parameter ${(0, helpers_1.showParameter)(aDate)} should be a Date`);
            const ownDay = self.get('day').innerNumber;
            const ownMonth = self.get('month').innerNumber - 1;
            const ownYear = self.get('year').innerNumber;
            const otherDay = aDate.get('day').innerNumber;
            const otherMonth = aDate.get('month').innerNumber - 1;
            const otherYear = aDate.get('year').innerNumber;
            const value = new Date(ownYear, ownMonth, ownDay);
            const otherValue = new Date(otherYear, otherMonth, otherDay);
            return yield* this.reify(value < otherValue);
        },
        *['>'](self, aDate) {
            (0, runtimeModel_1.assertIsNotNull)(aDate, '(>)', '_aDate');
            if (aDate.module !== self.module)
                throw new TypeError(`Message (>): parameter ${(0, helpers_1.showParameter)(aDate)} should be a Date`);
            const ownDay = self.get('day').innerNumber;
            const ownMonth = self.get('month').innerNumber - 1;
            const ownYear = self.get('year').innerNumber;
            const otherDay = aDate.get('day').innerNumber;
            const otherMonth = aDate.get('month').innerNumber - 1;
            const otherYear = aDate.get('year').innerNumber;
            const value = new Date(ownYear, ownMonth, ownDay);
            const otherValue = new Date(otherYear, otherMonth, otherDay);
            return yield* this.reify(value > otherValue);
        },
    },
    io: {
        *serve() {
            return yield* this.reify(false);
        },
    },
};
exports.default = lang;
//# sourceMappingURL=lang.js.map