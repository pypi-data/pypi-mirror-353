"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeRegistry = exports.WollokUnionType = exports.WollokParameterType = exports.WollokClosureType = exports.WollokMethodType = exports.WollokParametricType = exports.WollokModuleType = exports.WollokAtomicType = exports.TypeSystemProblem = exports.INSTANCE = exports.PARAM = exports.RETURN = exports.ELEMENT = exports.VOID = exports.ANY = void 0;
const constants_1 = require("../constants");
const model_1 = require("../model");
const { entries, fromEntries } = Object;
exports.ANY = 'Any';
exports.VOID = 'Void';
exports.ELEMENT = 'Element';
exports.RETURN = 'RETURN';
exports.PARAM = 'PARAM';
exports.INSTANCE = 'INSTANCE';
class TypeSystemProblem {
    constructor(code, values = []) {
        this.code = code;
        this.values = values;
    }
    get level() { return 'warning'; }
    get sourceMap() { return undefined; }
}
exports.TypeSystemProblem = TypeSystemProblem;
class WollokAtomicType {
    constructor(id) {
        this.id = id;
    }
    lookupMethod(_name, _arity, _options) {
        throw new Error('Atomic types have no methods');
    }
    atParam(_name) { throw new Error('Atomic types have no params'); }
    instanceFor(_instance, _send, _name) { return null; }
    contains(type) {
        return type instanceof WollokAtomicType && this.id === type.id;
    }
    asList() { return [this]; }
    isSubtypeOf(_type) { return false; }
    get name() { return this.id; }
    get kind() { return this.name; }
    get isComplete() { return true; }
}
exports.WollokAtomicType = WollokAtomicType;
class WollokModuleType {
    constructor(module) {
        this.module = module;
    }
    lookupMethod(name, arity, options) {
        return this.module.lookupMethod(name, arity, options);
    }
    contains(type) {
        return type instanceof WollokModuleType && (this.module === type.module ||
            this.module instanceof model_1.Singleton && type.module instanceof model_1.Singleton
                && this.module.isClosure() && type.module.isClosure());
    }
    atParam(_name) { throw new Error('Module types has no params'); }
    instanceFor(_instance, _send) { return null; }
    asList() { return [this]; }
    isSubtypeOf(type) {
        return type instanceof WollokModuleType && this.module !== type.module &&
            (type.module.fullyQualifiedName == constants_1.OBJECT_MODULE || this.module.inherits(type.module));
    }
    get name() { return this.module.name; }
    get kind() { var _a, _b; return (_b = (_a = this.module) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : constants_1.KEYWORDS.NULL; }
    get isComplete() { return true; }
    toString() { return this.module.toString(); }
}
exports.WollokModuleType = WollokModuleType;
class WollokParametricType extends WollokModuleType {
    constructor(base, params = {}) {
        super(base);
        this.params = new Map(entries(params));
    }
    contains(type) {
        return super.contains(type) && (!this.params.size || type instanceof WollokParametricType && this.sameParams(type));
    }
    atParam(name) { return this.params.get(name); }
    instanceFor(instance, send, name = exports.INSTANCE) {
        let changed = false;
        const resolvedParamTypes = fromEntries([...this.params]);
        this.params.forEach((tVar, paramName) => {
            const newInstance = tVar.instanceFor(instance, send, `${name}.${paramName}`);
            if (newInstance !== tVar) {
                resolvedParamTypes[paramName] = newInstance;
                changed = true;
            }
        });
        if (!changed)
            return super.instanceFor(instance, send);
        return instance.newInstance(name).setType(new WollokParametricType(this.module, resolvedParamTypes), false);
    }
    addMinType(minType) {
        this.params.forEach((paramTVar, name) => minType.atParam(name).allPossibleTypes().forEach(paramMinType => paramTVar.addMinType(paramMinType)));
    }
    addMaxType(minType) {
        this.params.forEach((paramTVar, name) => minType.atParam(name).allPossibleTypes().forEach(paramMaxType => paramTVar.addMaxType(paramMaxType)));
    }
    get name() {
        const innerTypes = [...this.params.values()].map(_ => _.type().name).join(', ');
        if (!innerTypes)
            return super.name;
        return `${super.name}<${innerTypes}>`;
    }
    get kind() {
        const innerTypes = [...this.params.keys()].join(', ');
        if (!innerTypes)
            return super.kind;
        return `${super.kind}<${innerTypes}>`;
    }
    get isComplete() {
        return [...this.params.values()].every((tVar) => tVar.hasTypeInfered());
    }
    sameParams(type) {
        return [...this.params.entries()].every(([name, tVar]) => type.atParam(name).type().name == exports.ANY || tVar.type().contains(type.atParam(name).type()));
    }
}
exports.WollokParametricType = WollokParametricType;
class WollokMethodType extends WollokParametricType {
    constructor(returnVar, params, extra = {}, base) {
        super(base, Object.assign(Object.assign(Object.assign({}, fromEntries(params.map((p, i) => [`${exports.PARAM}${i}`, p]))), { [exports.RETURN]: returnVar }), extra));
    }
    get name() {
        const params = [...this.params.entries()]
            .filter(([name, _]) => name !== exports.RETURN)
            .map(([_, tVar]) => tVar.type().name)
            .join(', ');
        const returnType = this.atParam(exports.RETURN).type().name;
        return `(${params}) => ${returnType}`;
    }
}
exports.WollokMethodType = WollokMethodType;
class WollokClosureType extends WollokMethodType {
    constructor(returnVar, params, closure) {
        super(returnVar, params, {}, closure);
    }
    get name() { return `{ ${super.name} }`; }
}
exports.WollokClosureType = WollokClosureType;
class WollokParameterType {
    constructor(id) {
        this.id = id;
    }
    instanceFor(instance, send) {
        return instance.atParam(this.name) || (send === null || send === void 0 ? void 0 : send.newInstance(this.name));
    }
    lookupMethod(_name, _arity, _options) {
        throw new Error('Parameters types have no methods');
    }
    atParam(_name) {
        throw new Error('Parameters types have no params');
    }
    contains(type) {
        if (this === type)
            return true;
        throw new Error('Parameters types don\'t contain other types');
    }
    asList() { return [this]; }
    isSubtypeOf(_type) {
        throw new Error('Parameters types cannot be subtype of other types (invariant)');
    }
    get name() { return this.id; }
    get kind() { return this.name; }
    get isComplete() { return true; }
}
exports.WollokParameterType = WollokParameterType;
class WollokUnionType {
    constructor(types) {
        this.types = types;
    }
    lookupMethod(_name, _arity, _options) {
        throw new Error('Halt');
    }
    atParam(_name) { throw new Error('Union types has no params'); }
    instanceFor(_instance) { return null; }
    contains(type) {
        return type.asList().every(t => this.types.some(_ => _.contains(t)));
    }
    asList() { return this.types; }
    isSubtypeOf(type) { return this.types.every(t => t.isSubtypeOf(type)); }
    get simplifiedTypes() {
        return this.types
            .reduce((acc, type) => [...acc.filter(t => !t.isSubtypeOf(type)), type], []);
    }
    get name() { return this.printBy(_ => _.name); }
    get kind() { return this.printBy(_ => _.kind); }
    printBy(property) {
        return `(${this.simplifiedTypes.map(property).join(' | ')})`;
    }
    get isComplete() {
        return this.types.every(t => t.isComplete);
    }
}
exports.WollokUnionType = WollokUnionType;
class TypeRegistry {
    constructor(tVars) {
        this.tVars = tVars;
    }
    getType(node) {
        var _a;
        const type = (_a = this.tVars.get(node)) === null || _a === void 0 ? void 0 : _a.type();
        if (!type)
            throw new Error(`No type variable for node ${node}`);
        return type;
    }
}
exports.TypeRegistry = TypeRegistry;
//# sourceMappingURL=wollokTypes.js.map