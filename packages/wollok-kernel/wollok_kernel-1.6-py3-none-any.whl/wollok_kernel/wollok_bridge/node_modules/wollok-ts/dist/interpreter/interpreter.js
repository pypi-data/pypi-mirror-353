"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionDirector = exports.executionFor = exports.DirectedInterpreter = exports.interprete = exports.Interpreter = exports.getStackTraceSanitized = exports.interpret = void 0;
const constants_1 = require("../constants");
const extensions_1 = require("../extensions");
const helpers_1 = require("../helpers");
const linker_1 = require("../linker");
const model_1 = require("../model");
const parse = __importStar(require("../parser"));
const wre_natives_1 = __importDefault(require("../wre/wre.natives"));
const runtimeModel_1 = require("./runtimeModel");
const interpret = (environment, natives) => new Interpreter(runtimeModel_1.Evaluation.build(environment, natives));
exports.interpret = interpret;
class AbstractInterpreter {
    constructor(evaluation) {
        this.evaluation = evaluation;
    }
    object(fullyQualifiedName) {
        return this.evaluation.object(fullyQualifiedName);
    }
    exec(node) {
        return this.do(function* () { return yield* this.exec(node); });
    }
    run(programOrTestFQN) {
        return this.exec(this.evaluation.environment.getNodeByFQN(programOrTestFQN));
    }
    send(message, receiver, ...args) {
        return this.do(function* () { return yield* this.send(message, receiver, ...args); });
    }
    invoke(method, receiver, ...args) {
        return this.do(function* () { return yield* this.invoke(method, receiver, ...args); });
    }
    reify(value) {
        return this.do(function* () { return yield* this.reify(value); });
    }
    list(...value) {
        return this.do(function* () { return yield* this.list(...value); });
    }
    set(...value) {
        return this.do(function* () { return yield* this.set(...value); });
    }
    error(moduleOrFQN, locals, error) {
        return this.do(function* () { return yield* this.error(moduleOrFQN, locals, error); });
    }
    instantiate(moduleOrFQN, locals = {}) {
        return this.do(function* () { return yield* this.instantiate(moduleOrFQN, locals); });
    }
}
const failureResult = (message, error) => ({
    result: message,
    error,
    errored: true,
});
const successResult = (result) => ({
    result,
    errored: false,
});
const getStackTraceSanitized = (e) => {
    var _a, _b, _c;
    const indexOfTsStack = (_a = e === null || e === void 0 ? void 0 : e.stack) === null || _a === void 0 ? void 0 : _a.indexOf(constants_1.WOLLOK_EXTRA_STACK_TRACE_HEADER);
    const fullStack = (_c = (_b = e === null || e === void 0 ? void 0 : e.stack) === null || _b === void 0 ? void 0 : _b.slice(0, indexOfTsStack !== null && indexOfTsStack !== void 0 ? indexOfTsStack : -1)) !== null && _c !== void 0 ? _c : '';
    return fullStack
        .replaceAll('\r', '')
        .replaceAll('\t', '  ')
        .replaceAll('     ', '  ')
        .replaceAll('    ', '  ')
        .split('\n')
        .filter(stackTraceElement => stackTraceElement.trim());
};
exports.getStackTraceSanitized = getStackTraceSanitized;
class Interpreter extends AbstractInterpreter {
    constructor(evaluation) { super(evaluation); }
    fork() {
        return new Interpreter(this.evaluation.copy());
    }
    do(executionDefinition) {
        const execution = executionDefinition.call(this.evaluation);
        let next = execution.next();
        while (!next.done)
            next = execution.next();
        return next.value;
    }
}
exports.Interpreter = Interpreter;
function interprete(interpreter, line, frame) {
    try {
        const sentenceOrImport = parse.Import.or(parse.Variable).or(parse.Assignment).or(parse.Expression).tryParse(line);
        const error = [sentenceOrImport, ...sentenceOrImport.descendants].flatMap(_ => { var _a; return (_a = _.problems) !== null && _a !== void 0 ? _a : []; }).find(_ => _.level === 'error');
        if (error)
            throw error;
        if (sentenceOrImport.is(model_1.Sentence)) {
            (0, linker_1.linkSentenceInNode)(sentenceOrImport, frame ? frame.node.parentPackage : interpreter.evaluation.environment.replNode());
            const unlinkedNode = [sentenceOrImport, ...sentenceOrImport.descendants].find(_ => _.is(model_1.Reference) && !_.target);
            if (unlinkedNode) {
                if (unlinkedNode.is(model_1.Reference)) {
                    if (!(frame !== null && frame !== void 0 ? frame : interpreter.evaluation.currentFrame).get(unlinkedNode.name))
                        return failureResult(`Unknown reference ${unlinkedNode.name}`);
                }
                else
                    return failureResult(`Unknown reference at ${unlinkedNode.sourceInfo}`);
            }
            const result = frame ?
                interpreter.do(function () { return interpreter.evaluation.exec(sentenceOrImport, frame); }) :
                interpreter.exec(sentenceOrImport);
            const stringResult = !result || (0, helpers_1.isVoid)(result)
                ? ''
                : result.showShortValue(interpreter);
            return successResult(stringResult);
        }
        if (sentenceOrImport.is(model_1.Import)) {
            const environment = interpreter.evaluation.environment;
            if (!environment.getNodeOrUndefinedByFQN(sentenceOrImport.entity.name)) {
                throw new Error(`Unknown reference ${sentenceOrImport.entity.name}`);
            }
            environment.newImportFor(sentenceOrImport);
            return successResult('');
        }
        return successResult('');
    }
    catch (error) {
        return (error.type === 'ParsimmonError' ? failureResult(`Syntax error:\n${error.message.split('\n').filter(extensions_1.notEmpty).slice(1).join('\n')}`) :
            error instanceof runtimeModel_1.WollokException ? failureResult('Evaluation Error!', error) :
                error instanceof parse.ParseError ? failureResult(`Syntax Error at offset ${error.sourceMap.start.offset}: ${line.slice(error.sourceMap.start.offset, error.sourceMap.end.offset)}`) :
                    failureResult('Uh-oh... Unexpected TypeScript Error!', error));
    }
}
exports.interprete = interprete;
class DirectedInterpreter extends AbstractInterpreter {
    constructor(evaluation) { super(evaluation); }
    fork() {
        return new DirectedInterpreter(this.evaluation.copy());
    }
    do(executionDefinition) {
        return new ExecutionDirector(this.evaluation, executionDefinition);
    }
}
exports.DirectedInterpreter = DirectedInterpreter;
const executionFor = (environment, natives = wre_natives_1.default) => new DirectedInterpreter(runtimeModel_1.Evaluation.build(environment, natives));
exports.executionFor = executionFor;
class ExecutionDirector {
    constructor(evaluation, execution) {
        this.breakpoints = [];
        this.evaluation = evaluation;
        this.execution = execution.call(evaluation);
    }
    addBreakpoint(breakpoint) {
        this.breakpoints.push(breakpoint);
    }
    removeBreakpoint(breakpoint) {
        const nextBreakpoints = this.breakpoints.filter(node => node !== breakpoint);
        this.breakpoints.splice(0, this.breakpoints.length);
        this.breakpoints.push(...nextBreakpoints);
    }
    finish() {
        let result = this.resume();
        while (!result.done)
            result = this.resume();
        return result;
    }
    resume(shouldHalt = () => false) {
        try {
            let next = this.execution.next();
            while (!next.done) {
                if (this.breakpoints.includes(next.value) || shouldHalt(next.value, this.evaluation))
                    return { done: false, next: next.value };
                next = this.execution.next();
            }
            return { done: true, result: next.value };
        }
        catch (error) {
            if (error instanceof runtimeModel_1.WollokException)
                return { done: true, error };
            throw error;
        }
    }
    stepIn() {
        return this.resume(() => true);
    }
    stepOut() {
        const currentHeight = this.evaluation.frameStack.length;
        return this.resume((_, evaluation) => evaluation.frameStack.length < currentHeight);
    }
    stepOver() {
        const currentHeight = this.evaluation.frameStack.length;
        return this.resume((_, evaluation) => evaluation.frameStack.length <= currentHeight);
    }
    stepThrough() {
        const currentHeight = this.evaluation.frameStack.length;
        const currentContext = this.evaluation.currentFrame;
        return this.resume((_, evaluation) => evaluation.frameStack.length <= currentHeight ||
            evaluation.currentFrame.contextHierarchy().includes(currentContext));
    }
}
exports.ExecutionDirector = ExecutionDirector;
//# sourceMappingURL=interpreter.js.map