"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sourceMapForValue = exports.sourceMapForUnreachableCode = exports.sourceMapForBody = exports.sourceMapForReturnValue = exports.sourceMapForSentences = exports.sourceMapForSentence = exports.sourceMapForConditionInIf = exports.sourceMapForOverrideMethod = exports.sourceMapForOnlyTest = exports.sourceMapForNodeNameOrFullNode = exports.sourceMapForNodeName = exports.buildSourceMap = void 0;
const constants_1 = require("../constants");
const extensions_1 = require("../extensions");
const model_1 = require("../model");
const helpers_1 = require("../helpers");
const buildSourceMap = (node, initialOffset, finalOffset) => node.sourceMap && new model_1.SourceMap({
    start: new model_1.SourceIndex(Object.assign(Object.assign({}, node.sourceMap.start.line === node.sourceMap.end.line ? { line: node.sourceMap.start.line, column: node.sourceMap.start.column + initialOffset } : node.sourceMap.start), { offset: node.sourceMap.start.offset + initialOffset })),
    end: new model_1.SourceIndex(Object.assign(Object.assign({}, node.sourceMap.start.line === node.sourceMap.end.line ? { line: node.sourceMap.start.line, column: node.sourceMap.start.column + initialOffset + finalOffset } : node.sourceMap.end), { offset: node.sourceMap.start.offset + finalOffset + initialOffset })),
});
exports.buildSourceMap = buildSourceMap;
const sourceMapForNodeName = (node) => {
    var _a, _b;
    if (!node.sourceMap)
        return undefined;
    const initialOffset = getOffsetForName(node);
    const finalOffset = (_b = (_a = node.name) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    return (0, exports.buildSourceMap)(node, initialOffset, finalOffset);
};
exports.sourceMapForNodeName = sourceMapForNodeName;
const sourceMapForNodeNameOrFullNode = (node) => node.name ? (0, exports.sourceMapForNodeName)(node) : node.sourceMap;
exports.sourceMapForNodeNameOrFullNode = sourceMapForNodeNameOrFullNode;
const sourceMapForOnlyTest = (node) => (0, exports.buildSourceMap)(node, 0, constants_1.KEYWORDS.ONLY.length);
exports.sourceMapForOnlyTest = sourceMapForOnlyTest;
const sourceMapForOverrideMethod = (node) => (0, exports.buildSourceMap)(node, 0, constants_1.KEYWORDS.OVERRIDE.length);
exports.sourceMapForOverrideMethod = sourceMapForOverrideMethod;
const sourceMapForConditionInIf = (node) => node.condition.sourceMap;
exports.sourceMapForConditionInIf = sourceMapForConditionInIf;
const sourceMapForSentence = (sentence) => { var _a; return sentence.is(model_1.Return) ? (_a = sentence.value) === null || _a === void 0 ? void 0 : _a.sourceMap : sentence.sourceMap; };
exports.sourceMapForSentence = sourceMapForSentence;
const sourceMapForSentences = (sentences) => new model_1.SourceMap({
    start: (0, exports.sourceMapForSentence)(sentences[0]).start,
    end: (0, exports.sourceMapForSentence)((0, extensions_1.last)(sentences)).end,
});
exports.sourceMapForSentences = sourceMapForSentences;
const sourceMapForReturnValue = (node) => {
    if (!node.body || node.body === constants_1.KEYWORDS.NATIVE || (0, extensions_1.isEmpty)(node.body.sentences))
        return node.sourceMap;
    const lastSentence = (0, extensions_1.last)(node.body.sentences);
    if (!lastSentence.is(model_1.Return))
        return lastSentence.sourceMap;
    return lastSentence.value.sourceMap;
};
exports.sourceMapForReturnValue = sourceMapForReturnValue;
const sourceMapForBody = (node) => {
    if (!node.body || node.body === constants_1.KEYWORDS.NATIVE || (0, extensions_1.isEmpty)(node.body.sentences))
        return node.sourceMap;
    return (0, exports.sourceMapForSentences)(node.body.sentences);
};
exports.sourceMapForBody = sourceMapForBody;
const sourceMapForUnreachableCode = (node) => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.If)(node => {
    const whichBody = (0, helpers_1.hasBooleanValue)(node.condition, true) ? node.elseBody : node.thenBody;
    return (0, exports.sourceMapForSentences)(whichBody.sentences);
}), (0, extensions_1.when)(model_1.Send)(node => new model_1.SourceMap({
    start: node.args[0].sourceMap.start,
    end: node.sourceMap.end,
})));
exports.sourceMapForUnreachableCode = sourceMapForUnreachableCode;
const sourceMapForValue = (node) => {
    if (!node.sourceMap)
        return undefined;
    return node.value ? node.value.sourceMap : node.sourceMap;
};
exports.sourceMapForValue = sourceMapForValue;
const getVariableOffset = (node) => (node.isConstant ? constants_1.KEYWORDS.CONST.length : constants_1.KEYWORDS.VAR.length) + 1;
const getOffsetForName = (node) => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Parameter)(() => 0), (0, extensions_1.when)(model_1.NamedArgument)(() => 0), (0, extensions_1.when)(model_1.Variable)(node => getVariableOffset(node)), (0, extensions_1.when)(model_1.Field)(node => getVariableOffset(node) + (node.isProperty ? constants_1.KEYWORDS.PROPERTY.length + 1 : 0)), (0, extensions_1.when)(model_1.Method)(node => (node.isOverride ? constants_1.KEYWORDS.OVERRIDE.length + 1 : 0) + node.kind.length + 1), (0, extensions_1.when)(model_1.Reference)(node => node.name.length + 1), (0, extensions_1.when)(model_1.Entity)(node => node.is(model_1.Singleton) ? constants_1.KEYWORDS.WKO.length + 1 : node.kind.length + 1));
//# sourceMappingURL=sourceMaps.js.map