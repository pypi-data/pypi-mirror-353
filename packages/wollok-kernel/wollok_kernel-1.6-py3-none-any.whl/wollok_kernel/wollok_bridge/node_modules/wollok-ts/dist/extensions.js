"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasWhitespace = exports.regex = exports.anyPredicate = exports.otherwise = exports.when = exports.match = exports.is = exports.MIXINS = exports.raise = exports.count = exports.excludeNullish = exports.uniqueBy = exports.duplicates = exports.notEmpty = exports.isEmpty = exports.hash = exports.traverse = exports.sumBy = exports.sum = exports.mapObject = exports.zipObj = exports.discriminate = exports.get = exports.divideOn = exports.valueAsListOrEmpty = exports.last = exports.keys = void 0;
exports.keys = Object.keys;
const last = (xs) => xs[xs.length - 1];
exports.last = last;
const valueAsListOrEmpty = (value) => value ? [value] : [];
exports.valueAsListOrEmpty = valueAsListOrEmpty;
const divideOn = (separator) => (str) => {
    const [head, ...tail] = str.split(separator);
    return [head, tail.join(separator)];
};
exports.divideOn = divideOn;
const get = (obj, path) => path.split('.').reduce((current, step) => current === null || current === void 0 ? void 0 : current[step], obj);
exports.get = get;
function discriminate(isA) {
    return (list) => {
        const as = [];
        const bs = [];
        for (const member of list)
            if (isA(member))
                as.push(member);
            else
                bs.push(member);
        return [as, bs];
    };
}
exports.discriminate = discriminate;
const zipObj = (fieldNames, fieldValues) => {
    const response = {};
    for (let i = 0; i < fieldNames.length; i++) {
        response[fieldNames[i]] = fieldValues[i];
    }
    return response;
};
exports.zipObj = zipObj;
const mapObject = (tx, obj) => {
    const response = {};
    for (const key of (0, exports.keys)(obj)) {
        response[key] = tx(obj[key], key);
    }
    return response;
};
exports.mapObject = mapObject;
const sum = (array) => array.reduce((acum, elem) => acum + elem, 0);
exports.sum = sum;
const sumBy = (array, tx) => array.reduce((acum, elem) => acum + tx(elem), 0);
exports.sumBy = sumBy;
const traverse = (generator) => {
    let result = generator.next();
    while (!result.done)
        result = generator.next();
    return result.value;
};
exports.traverse = traverse;
const hash = (str) => {
    let hashValue = 0;
    for (let index = 0; index < str.length; index++) {
        hashValue += str.charCodeAt(index) << index * 8;
    }
    return hashValue;
};
exports.hash = hash;
const isEmpty = (value) => !(0, exports.notEmpty)(value);
exports.isEmpty = isEmpty;
const notEmpty = (value) => { var _a; return ((_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0) > 0; };
exports.notEmpty = notEmpty;
const duplicates = (list) => list.filter((element, i) => list.includes(element, i + 1));
exports.duplicates = duplicates;
const uniqueBy = (collection, property) => collection.reduce((uniques, elem) => {
    if (!uniques.find(uniqueElement => uniqueElement[property] === elem[property]))
        uniques.push(elem);
    return uniques;
}, []);
exports.uniqueBy = uniqueBy;
const excludeNullish = (list) => list.filter((item) => item !== undefined);
exports.excludeNullish = excludeNullish;
const count = (list, condition) => list.filter(condition).length;
exports.count = count;
function raise(error) { throw error; }
exports.raise = raise;
exports.MIXINS = Symbol('mixins');
const is = (definition) => (obj) => {
    var _a;
    return !!obj && (obj instanceof definition || ((_a = obj.constructor[exports.MIXINS]) === null || _a === void 0 ? void 0 : _a.includes(definition)));
};
exports.is = is;
const OTHERWISE = 'OTHERWISE';
const match = (matched) => (...cases) => {
    for (const [key, handler] of cases)
        if (key === OTHERWISE || (0, exports.is)(key)(matched))
            return handler(matched);
    throw new Error(`${matched} exhausted all cases without a match`);
};
exports.match = match;
const when = (definition) => (handler) => [definition, handler];
exports.when = when;
const otherwise = (handler) => [OTHERWISE, handler];
exports.otherwise = otherwise;
const anyPredicate = (...conditions) => x => conditions.some(condition => condition(x));
exports.anyPredicate = anyPredicate;
const regex = (regex) => (value) => !value || regex.test(value !== null && value !== void 0 ? value : '');
exports.regex = regex;
exports.hasWhitespace = (0, exports.regex)(/\s/);
//# sourceMappingURL=extensions.js.map