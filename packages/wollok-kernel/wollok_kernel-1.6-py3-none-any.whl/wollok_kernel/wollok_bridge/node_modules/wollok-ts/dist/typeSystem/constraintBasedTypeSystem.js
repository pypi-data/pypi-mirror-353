"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.closeTypes = exports.reverseInference = exports.reversePropagateMessages = exports.maxTypeFromMessages = exports.bindReceivedMessages = exports.propagateMessages = exports.propagateMaxTypes = exports.propagateMinTypes = exports.inferTypes = void 0;
const constants_1 = require("../constants");
const extensions_1 = require("../extensions");
const model_1 = require("../model");
const typeVariables_1 = require("./typeVariables");
const wollokTypes_1 = require("./wollokTypes");
const { assign } = Object;
let logger = { log: () => { } };
function inferTypes(env, someLogger) {
    if (someLogger)
        logger = someLogger;
    const tVars = (0, typeVariables_1.newTypeVariables)(env);
    let globalChange = true;
    while (globalChange) {
        globalChange = [basicPropagation, inferFromMessages, reversePropagation, guessTypes].some(runStage(tVars));
    }
    assign(env, { typeRegistry: new wollokTypes_1.TypeRegistry(tVars) });
}
exports.inferTypes = inferTypes;
const runStage = (tVars) => (stages) => allValidTypeVariables(tVars).some((0, extensions_1.anyPredicate)(...stages));
const basicPropagation = [propagateMinTypes, propagateMaxTypes, propagateMessages];
function propagateMinTypes(tVar) {
    return propagateMinTypesUsing(tVar.allMinTypes(), tVar.validSupertypes())((targetTVar, type) => {
        if (targetTVar.closed)
            return reportTypeMismatchUnknownVictim(tVar, type, targetTVar);
        targetTVar.addMinType(type);
        logger.log(`PROPAGATE MIN TYPE (${type.name}) FROM |${tVar}| TO |${targetTVar}|`);
    });
}
exports.propagateMinTypes = propagateMinTypes;
function propagateMaxTypes(tVar) {
    if (tVar.messages.length)
        return false;
    return propagateMaxTypesUsing(tVar.allMaxTypes(), tVar.validSubtypes())((targetTVar, type) => {
        if (targetTVar.closed)
            return reportTypeMismatchUnknownVictim(tVar, type, targetTVar);
        targetTVar.addMaxType(type);
        logger.log(`PROPAGATE MAX TYPE (${type.name}) FROM |${tVar}| TO |${targetTVar}|`);
    });
}
exports.propagateMaxTypes = propagateMaxTypes;
function propagateMessages(tVar) {
    return propagateSendsUsing(tVar.messages, tVar.validSubtypes())((targetTVar, send) => {
        if (validateUnderstandMessage(targetTVar, send, tVar))
            return true;
        targetTVar.addSend(send);
        logger.log(`PROPAGATE SEND (${send}) FROM |${tVar}| TO |${targetTVar}|`);
    });
}
exports.propagateMessages = propagateMessages;
const propagate = (checker) => (elements, targetTVars) => (propagator) => {
    let changed = false;
    for (const type of elements) {
        for (const targetTVar of targetTVars) {
            if (!checker(targetTVar, type)) {
                if (propagator(targetTVar, type))
                    return true;
                changed = true;
            }
        }
    }
    return changed;
};
const propagateMinTypesUsing = propagate((targetTVar, type) => targetTVar.hasMinType(type));
const propagateMaxTypesUsing = propagate((targetTVar, type) => targetTVar.hasType(type));
const propagateSendsUsing = propagate((targetTVar, send) => targetTVar.hasSend(send));
const inferFromMessages = [bindReceivedMessages, maxTypeFromMessages];
function bindReceivedMessages(tVar) {
    const types = tVar.allPossibleTypes();
    let changed = false;
    for (const type of types) {
        for (const send of tVar.messages) {
            if (send.receiver !== tVar.node)
                continue;
            const message = send.message == constants_1.APPLY_METHOD ? constants_1.CLOSURE_EVALUATE_METHOD : send.message;
            const method = type.lookupMethod(message, send.args.length, { allowAbstractMethods: true });
            if (!method)
                return reportMethodNotFound(tVar, send, type);
            if (bindMethod(tVar, method, send))
                changed = true;
        }
    }
    return changed;
}
exports.bindReceivedMessages = bindReceivedMessages;
function bindMethod(receiver, method, send) {
    const methodInstance = (0, typeVariables_1.typeVariableFor)(method).instanceFor(receiver, (0, typeVariables_1.typeVariableFor)(send));
    const returnParam = methodInstance.atParam(wollokTypes_1.RETURN);
    if (returnParam.hasSupertype((0, typeVariables_1.typeVariableFor)(send)))
        return false;
    logger.log(`\nBIND MESSAGE |${send}| WITH METHOD |${method}|`);
    returnParam.addSupertype((0, typeVariables_1.typeVariableFor)(send));
    logger.log(`NEW SUPERTYPE |${(0, typeVariables_1.typeVariableFor)(send)}| FOR |${returnParam}|`);
    method.parameters.forEach((_param, i) => {
        const argTVAR = (0, typeVariables_1.typeVariableFor)(send.args[i]);
        const currentParam = methodInstance.atParam(`${wollokTypes_1.PARAM}${i}`);
        currentParam.addSubtype(argTVAR);
        logger.log(`NEW SUBTYPE |${argTVAR}| FOR |${currentParam}|`);
    });
    return true;
}
function maxTypeFromMessages(tVar) {
    if (tVar.closed)
        return false;
    if (!tVar.messages.length)
        return false;
    if (tVar.allMinTypes().length)
        return false;
    if (tVar.messages.every(send => send.message == constants_1.APPLY_METHOD))
        return false;
    let changed = false;
    const [possibleTypes, mnuMessages] = inferMaxTypesFromMessages([...tVar.messages]);
    for (const type of possibleTypes)
        if (!tVar.hasType(type)) {
            tVar.addMaxType(type);
            logger.log(`NEW MAX TYPE |${type}| FOR |${tVar}|`);
            changed = true;
        }
    for (const send of mnuMessages)
        if (send.receiver === tVar.node) {
            reportMethodNotFound(tVar, send, tVar.type());
            changed = true;
        }
    return changed;
}
exports.maxTypeFromMessages = maxTypeFromMessages;
function inferMaxTypesFromMessages(messages) {
    if (messages.every(allObjectsUnderstand))
        return [[objectType(messages[0])], []];
    let possibleTypes = allTypesThatUndestand(messages);
    const mnuMessages = [];
    while (!possibleTypes.length) {
        mnuMessages.push(messages.pop());
        if (!messages.length)
            return [[], []];
        possibleTypes = allTypesThatUndestand(messages);
    }
    return [possibleTypes, mnuMessages];
}
function allTypesThatUndestand(messages) {
    const { environment } = messages[0];
    return allModulesThatUnderstand(environment, messages).map(typeVariables_1.typeForModule);
}
function allObjectsUnderstand(send) {
    return send.environment.objectClass.lookupMethod(send.message, send.args.length, { allowAbstractMethods: true });
}
function objectType(node) {
    return (0, typeVariables_1.typeForModule)(node.environment.objectClass);
}
function allModulesThatUnderstand(environment, sends) {
    return environment.descendants
        .filter((0, extensions_1.is)(model_1.Module))
        .filter(module => sends.every(send => module.lookupMethod(send.message, send.args.length, { allowAbstractMethods: true })));
}
const reversePropagation = [reversePropagateMessages, reverseInference];
function reversePropagateMessages(tVar) {
    if (tVar.closed)
        return false;
    if (tVar.messages.length)
        return false;
    if (tVar.allMaxTypes().length)
        return false;
    let changed = false;
    for (const subTVar of tVar.validSubtypes()) {
        changed = changed || propagateSendsUsing(subTVar.messages, [tVar])((targetTVar, send) => {
            if (validateUnderstandMessage(targetTVar, send, subTVar))
                return true;
            targetTVar.addSend(send);
            logger.log(`REVERSE PROPAGATE SEND (${send}) FROM |${subTVar}| TO |${targetTVar}|`);
        });
    }
    return changed;
}
exports.reversePropagateMessages = reversePropagateMessages;
function reverseInference(tVar) {
    var _a;
    if (tVar.closed)
        return false;
    if (tVar.hasTypeInfered())
        return false;
    if (!tVar.synthetic && ((_a = tVar.node.parentPackage) === null || _a === void 0 ? void 0 : _a.isBaseWollokCode))
        return false;
    let changed = false;
    for (const subTVar of tVar.validSubtypes()) {
        changed = changed || propagateMaxTypesUsing(subTVar.allMaxTypes().filter(t => t.isComplete), [tVar])((targetTVar, type) => {
            targetTVar.addMinType(type);
            logger.log(`GUESS MIN TYPE (${type.name}) FROM |${subTVar}| TO |${targetTVar}|`);
        });
    }
    for (const superTVar of tVar.validSupertypes()) {
        changed = changed || propagateMinTypesUsing(superTVar.allMinTypes().filter(t => t.isComplete), [tVar])((targetTVar, type) => {
            targetTVar.addMaxType(type);
            logger.log(`GUESS MAX TYPE (${type.name}) FROM |${superTVar}| TO |${targetTVar}|`);
        });
    }
    return changed;
}
exports.reverseInference = reverseInference;
const guessTypes = [closeTypes];
function closeTypes(tVar) {
    let changed = false;
    if ((0, extensions_1.isEmpty)(tVar.allMaxTypes()) && (0, extensions_1.notEmpty)(tVar.allMinTypes()) && (0, extensions_1.isEmpty)(tVar.supertypes)) {
        tVar.typeInfo.maxTypes = tVar.allMinTypes();
        logger.log(`MAX TYPES |${new wollokTypes_1.WollokUnionType(tVar.typeInfo.maxTypes).name}| FROM MIN FOR |${tVar}|`);
        changed = true;
    }
    if ((0, extensions_1.isEmpty)(tVar.allMinTypes()) && (0, extensions_1.notEmpty)(tVar.allMaxTypes()) && (0, extensions_1.isEmpty)(tVar.subtypes)) {
        tVar.typeInfo.minTypes = tVar.allMaxTypes();
        logger.log(`MIN TYPES |${new wollokTypes_1.WollokUnionType(tVar.typeInfo.minTypes).name}| FROM MAX FOR |${tVar}|`);
        changed = true;
    }
    return changed;
}
exports.closeTypes = closeTypes;
function reportProblem(tVar, problem) {
    tVar.addProblem(problem);
    return true;
}
function reportTypeMismatchUnknownVictim(source, type, target) {
    return reportTypeMismatch(...selectVictim(source, type, target, target.type()));
}
function reportTypeMismatch(tVar, expected, actual) {
    logger.log(`\nERROR: TYPE Expected: ${expected.name} Actual: ${actual.name} FOR |${tVar}|`);
    return reportProblem(tVar, new wollokTypes_1.TypeSystemProblem('typeMismatch', [expected.name, actual.name]));
}
function reportMethodNotFound(tVar, send, type) {
    logger.log(`\nERROR: METHOD |${send.signature}| NOT FOUND ON TYPE |${type.name}| FOR |${tVar}|`);
    return reportProblem(tVar, new wollokTypes_1.TypeSystemProblem('methodNotFound', [send.signature, type.name]));
}
function selectVictim(source, type, target, targetType) {
    if (source.synthetic)
        return [target, targetType, type];
    if (target.synthetic)
        return [source, type, targetType];
    if (source.node.is(model_1.Reference))
        return [source, type, targetType];
    if (target.node.is(model_1.Reference))
        return [target, targetType, type];
    return [target, targetType, type];
}
function validateUnderstandMessage(tVar, send, source) {
    for (const type of tVar.allPossibleTypes()) {
        if (!type.lookupMethod(send.message, send.args.length, { allowAbstractMethods: true }))
            return (source === null || source === void 0 ? void 0 : source.hasTypeInfered()) ? reportTypeMismatch(tVar, source.type(), type) : reportMethodNotFound(tVar, send, type);
    }
    return false;
}
function allValidTypeVariables(tVars) {
    return [...tVars.values()].filter(tVar => !tVar.hasProblems);
}
//# sourceMappingURL=constraintBasedTypeSystem.js.map