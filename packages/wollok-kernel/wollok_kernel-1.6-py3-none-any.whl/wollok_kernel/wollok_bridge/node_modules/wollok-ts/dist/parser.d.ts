import Parsimmon, { Parser } from 'parsimmon';
import { List } from './extensions';
import { Annotation, Assignment as AssignmentNode, BaseProblem, Body as BodyNode, Catch as CatchNode, Class as ClassNode, Describe as DescribeNode, Entity as EntityNode, Expression as ExpressionNode, Field as FieldNode, If as IfNode, Import as ImportNode, Level, Literal as LiteralNode, Method as MethodNode, Mixin as MixinNode, Name, NamedArgument as NamedArgumentNode, New as NewNode, Package as PackageNode, Parameter as ParameterNode, ParameterizedType as ParameterizedTypeNode, Program as ProgramNode, Reference as ReferenceNode, Return as ReturnNode, Self as SelfNode, Send as SendNode, Sentence as SentenceNode, Singleton as SingletonNode, SourceIndex, SourceMap, Super as SuperNode, Test as TestNode, Throw as ThrowNode, Try as TryNode, Variable as VariableNode } from './model';
export declare const MALFORMED_ENTITY = "malformedEntity";
export declare const MALFORMED_MEMBER = "malformedMember";
export declare const MALFORMED_SENTENCE = "malformedSentence";
export declare const MALFORMED_MESSAGE_SEND = "malformedMessageSend";
export declare class ParseError implements BaseProblem {
    code: Name;
    sourceMap: SourceMap;
    constructor(code: Name, sourceMap: SourceMap);
    get level(): Level;
    get values(): List<string>;
}
export declare const sanitizeWhitespaces: (originalFrom: SourceIndex, originalTo: SourceIndex, input: string) => [SourceIndex, SourceIndex];
export declare const annotation: Parser<Annotation>;
export declare const File: (fileName: string) => Parser<PackageNode>;
export declare const Import: Parser<ImportNode>;
export declare const name: Parser<Name>;
export declare const packageName: Parser<Name>;
export declare const FullyQualifiedReference: Parser<ReferenceNode<any>>;
export declare const Reference: Parser<ReferenceNode<any>>;
export declare const Parameter: Parser<ParameterNode>;
export declare const NamedArgument: Parser<NamedArgumentNode>;
export declare const Body: Parser<BodyNode>;
export declare const ExpressionBody: Parser<BodyNode>;
export declare const Entity: Parser<EntityNode>;
export declare const Package: Parser<PackageNode>;
export declare const Program: Parser<ProgramNode>;
export declare const Test: Parser<TestNode>;
export declare const ParameterizedType: Parsimmon.Parser<ParameterizedTypeNode>;
export declare const Class: Parser<ClassNode>;
export declare const Singleton: Parser<SingletonNode>;
export declare const Mixin: Parser<MixinNode>;
export declare const Describe: Parser<DescribeNode>;
export declare const Field: Parser<FieldNode>;
export declare const Method: Parser<MethodNode>;
export declare const Sentence: Parser<SentenceNode>;
export declare const Variable: Parser<VariableNode>;
export declare const Return: Parser<ReturnNode>;
export declare const Assignment: Parser<AssignmentNode>;
export declare const Expression: Parser<ExpressionNode>;
export declare const Self: Parser<SelfNode>;
export declare const Super: Parser<SuperNode>;
export declare const New: Parser<NewNode>;
export declare const If: Parser<IfNode>;
export declare const Throw: Parser<ThrowNode>;
export declare const Try: Parser<TryNode>;
export declare const Catch: Parser<CatchNode>;
export declare const Send: Parser<SendNode>;
export declare const Literal: Parser<LiteralNode>;
