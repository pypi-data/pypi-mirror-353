"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Environment = exports.Closure = exports.Catch = exports.Try = exports.Throw = exports.If = exports.New = exports.Super = exports.Send = exports.Literal = exports.Self = exports.Reference = exports.Expression = exports.Assignment = exports.Return = exports.Sentence = exports.Method = exports.Field = exports.Describe = exports.Mixin = exports.Singleton = exports.Class = exports.Module = exports.Variable = exports.Test = exports.Program = exports.Package = exports.Entity = exports.Body = exports.Import = exports.NamedArgument = exports.ParameterizedType = exports.Parameter = exports.Node = exports.Annotation = exports.SourceMap = exports.SourceIndex = void 0;
const constants_1 = require("./constants");
const decorators_1 = require("./decorators");
const extensions_1 = require("./extensions");
const linker_1 = require("./linker");
const { isArray } = Array;
const { values, assign } = Object;
class SourceIndex {
    constructor(args) {
        this.offset = args.offset;
        this.line = args.line;
        this.column = args.column;
    }
    toString() { return `${this.line}:${this.column}`; }
}
exports.SourceIndex = SourceIndex;
class SourceMap {
    constructor(args) {
        this.start = args.start;
        this.end = args.end;
    }
    toString() { return `[${this.start}, ${this.end}]`; }
    covers(offset) { return this.start.offset <= offset && this.end.offset >= offset; }
    includes(other) { return this.start.offset <= other.start.offset && this.end.offset >= other.end.offset; }
}
exports.SourceMap = SourceMap;
class Annotation {
    constructor(name, args = {}) {
        this.name = name;
        this.args = args;
    }
}
exports.Annotation = Annotation;
class Node {
    constructor(payload) {
        this.metadata = [];
        assign(this, payload);
    }
    get categories() { return [this.constructor]; }
    get sourceFileName() {
        const parent = (0, decorators_1.getPotentiallyUninitializedLazy)(this, 'parent');
        return parent === null || parent === void 0 ? void 0 : parent.sourceFileName;
    }
    get sourceInfo() { var _a, _b, _c; return `${(_a = this.sourceFileName) !== null && _a !== void 0 ? _a : '--'}:${(_c = (_b = this.sourceMap) === null || _b === void 0 ? void 0 : _b.start.line) !== null && _c !== void 0 ? _c : '--'}`; }
    get label() { var _a, _b; return `[${this.kind}]{${(_b = (_a = this.id) === null || _a === void 0 ? void 0 : _a.slice(-6)) !== null && _b !== void 0 ? _b : '--'}} at ${this.sourceInfo}`; }
    get isSynthetic() { return !this.sourceMap; }
    get hasProblems() { return (0, extensions_1.notEmpty)(this.problems); }
    get type() { return this.environment.typeRegistry.getType(this); }
    get parentPackage() {
        return this.ancestors.find(node => node.is(Package));
    }
    toString(verbose = false) {
        return !verbose ? this.label : JSON.stringify(this, (key, value) => {
            if ('scope' === key)
                return;
            if ('sourceMap' === key)
                return `${value}`;
            return value;
        }, 2);
    }
    is(kindOrCategory) { return (0, extensions_1.is)(kindOrCategory)(this); }
    copy(delta = {}) {
        return new this.constructor(Object.assign(Object.assign({}, this), delta));
    }
    get children() {
        const extractChildren = (owner) => {
            if (owner instanceof Node)
                return [owner];
            if (isArray(owner))
                return owner.flatMap(extractChildren);
            return [];
        };
        return values(this).flatMap(extractChildren);
    }
    siblings() { return this.parent.children.filter(node => node !== this); }
    get descendants() {
        const pending = [];
        const response = [];
        let next = this;
        do {
            const children = next.children;
            response.push(...children);
            pending.push(...children);
            next = pending.shift();
        } while (next);
        return response;
    }
    get ancestors() { return [this.parent, ...this.parent.ancestors]; }
    transform(tx) {
        const applyTransform = (value) => {
            if (isArray(value))
                return value.map(applyTransform);
            if (value instanceof Node)
                return value.copy((0, extensions_1.mapObject)(applyTransform, tx(value)));
            return value;
        };
        return applyTransform(this);
    }
    forEach(tx) {
        this.reduce((_, node, parent) => {
            tx(node, parent);
            return undefined;
        }, undefined);
    }
    reduce(tx, initial) {
        const applyReduce = (acum, node, parent) => node.children.reduce((seed, child) => {
            return applyReduce(seed, child, node);
        }, tx(acum, node, parent));
        return applyReduce(initial, this, (0, decorators_1.getPotentiallyUninitializedLazy)(this, 'parent'));
    }
}
__decorate([
    decorators_1.lazy
], Node.prototype, "environment", void 0);
__decorate([
    decorators_1.lazy
], Node.prototype, "parent", void 0);
__decorate([
    decorators_1.cached
], Node.prototype, "toString", null);
__decorate([
    decorators_1.cached
], Node.prototype, "children", null);
__decorate([
    decorators_1.cached
], Node.prototype, "siblings", null);
__decorate([
    decorators_1.cached
], Node.prototype, "descendants", null);
__decorate([
    decorators_1.cached
], Node.prototype, "ancestors", null);
exports.Node = Node;
class Parameter extends Node {
    get kind() { return 'Parameter'; }
    constructor(_a) {
        var { isVarArg = false } = _a, payload = __rest(_a, ["isVarArg"]);
        super(Object.assign({ isVarArg }, payload));
    }
}
exports.Parameter = Parameter;
class ParameterizedType extends Node {
    get kind() { return 'ParameterizedType'; }
    constructor(_a) {
        var { args = [] } = _a, payload = __rest(_a, ["args"]);
        super(Object.assign({ args }, payload));
    }
}
exports.ParameterizedType = ParameterizedType;
class NamedArgument extends Node {
    get kind() { return 'NamedArgument'; }
    constructor(payload) { super(payload); }
}
exports.NamedArgument = NamedArgument;
class Import extends Node {
    get kind() { return 'Import'; }
    constructor(_a) {
        var { isGeneric = false } = _a, payload = __rest(_a, ["isGeneric"]);
        super(Object.assign({ isGeneric }, payload));
    }
    get importedEntity() {
        return this.entity.target;
    }
    allImportedEntities() {
        const importedEntity = this.importedEntity;
        return this.isGeneric
            ? [...importedEntity.members]
            : [importedEntity];
    }
}
exports.Import = Import;
class Body extends Node {
    get kind() { return 'Body'; }
    constructor(_a = {}) {
        var { sentences = [] } = _a, payload = __rest(_a, ["sentences"]);
        super(Object.assign({ sentences }, payload));
    }
    isEmpty() {
        return this.isSynthetic || this.parent.is(Method) || (0, extensions_1.notEmpty)(this.sentences);
    }
}
exports.Body = Body;
function Entity(supertype) {
    var _a;
    var _EntityType_isEntity, _b;
    class EntityType extends supertype {
        constructor() {
            super(...arguments);
            _EntityType_isEntity.set(this, void 0);
        }
        get label() { return `${this.fullyQualifiedName} ${super.label}`; }
        get fullyQualifiedName() {
            var _a, _c;
            const parent = (0, decorators_1.getPotentiallyUninitializedLazy)(this, 'parent');
            const label = this.is(Singleton)
                ? (_a = this.name) !== null && _a !== void 0 ? _a : `${this.superclass.fullyQualifiedName}#${(_c = this.id) !== null && _c !== void 0 ? _c : 'anonymous'}`
                : this.name.replace(/\.#/g, '');
            return (parent === null || parent === void 0 ? void 0 : parent.is(Package)) || (parent === null || parent === void 0 ? void 0 : parent.is(Describe))
                ? `${parent.fullyQualifiedName}.${label}`
                : label;
        }
        get isBaseWollokCode() {
            return this.fullyQualifiedName.startsWith(constants_1.WOLLOK_BASE_PACKAGE);
        }
    }
    _EntityType_isEntity = new WeakMap(), _b = extensions_1.MIXINS;
    EntityType[_b] = [Entity, ...(_a = supertype[extensions_1.MIXINS]) !== null && _a !== void 0 ? _a : []];
    __decorate([
        decorators_1.cached
    ], EntityType.prototype, "fullyQualifiedName", null);
    return EntityType;
}
exports.Entity = Entity;
class Package extends Entity(Node) {
    get kind() { return 'Package'; }
    constructor(_a) {
        var { name, imports = [], members = [] } = _a, payload = __rest(_a, ["name", "imports", "members"]);
        super(Object.assign({ imports, members }, payload));
        const [packageName, ...ancestorNames] = name.split('.').reverse();
        this.name = packageName;
        return ancestorNames.reduce((member, name) => new Package({ name, members: [member] }), this);
    }
    get sourceFileName() { var _a; return (_a = this.fileName) !== null && _a !== void 0 ? _a : super.sourceFileName; }
    get isGlobalPackage() { return linker_1.GLOBAL_PACKAGES.includes(this.fullyQualifiedName); }
    get isTestFile() { var _a, _b; return (_b = (_a = this.sourceFileName) === null || _a === void 0 ? void 0 : _a.endsWith(constants_1.TEST_FILE_EXTENSION)) !== null && _b !== void 0 ? _b : false; }
    get isWLKFile() { var _a, _b; return (_b = (_a = this.sourceFileName) === null || _a === void 0 ? void 0 : _a.endsWith(constants_1.WOLLOK_FILE_EXTENSION)) !== null && _b !== void 0 ? _b : false; }
    get isImportable() { return this.isWLKFile || !this.sourceFileName; }
    getNodeByQN(qualifiedName) {
        const node = this.getNodeOrUndefinedByQN(qualifiedName);
        if (!node)
            throw new Error(`Could not resolve reference to ${qualifiedName} from ${this.name}`);
        return node;
    }
    getNodeOrUndefinedByQN(qualifiedName) {
        return this.scope.resolve(qualifiedName);
    }
    isConstant(localName) {
        var _a, _b;
        return (_b = (_a = this.scope.resolve(localName)) === null || _a === void 0 ? void 0 : _a.isConstant) !== null && _b !== void 0 ? _b : false;
    }
    allScopedEntities() {
        return [
            ...this.scope.localEntities(),
            ...this.imports.flatMap(imp => imp.allImportedEntities()),
        ];
    }
}
__decorate([
    decorators_1.cached
], Package.prototype, "sourceFileName", null);
__decorate([
    decorators_1.cached
], Package.prototype, "getNodeOrUndefinedByQN", null);
exports.Package = Package;
class Program extends Entity(Node) {
    get kind() { return 'Program'; }
    constructor(payload) { super(payload); }
    sentences() { return this.body.sentences; }
}
__decorate([
    decorators_1.cached
], Program.prototype, "sentences", null);
exports.Program = Program;
class Test extends Entity(Node) {
    get kind() { return 'Test'; }
    constructor(_a) {
        var { isOnly = false } = _a, payload = __rest(_a, ["isOnly"]);
        super(Object.assign({ isOnly }, payload));
    }
    get sentences() { return this.body.sentences; }
}
__decorate([
    decorators_1.cached
], Test.prototype, "sentences", null);
exports.Test = Test;
class Variable extends Sentence(Entity(Node)) {
    get kind() { return 'Variable'; }
    constructor(_a) {
        var { value = new Literal({ value: null }) } = _a, payload = __rest(_a, ["value"]);
        super(Object.assign({ value }, payload));
    }
    get isAtPackageLevel() { return this.parent.is(Package); }
}
exports.Variable = Variable;
function Module(supertype) {
    var _a;
    var _ModuleType_isModule, _b;
    class ModuleType extends Entity(supertype) {
        constructor(...args) {
            var _a, _c;
            const _d = args[0], { members } = _d, payload = __rest(_d, ["members"]);
            const methods = (_a = members === null || members === void 0 ? void 0 : members.filter((0, extensions_1.is)(Method))) !== null && _a !== void 0 ? _a : [];
            const fields = (_c = members === null || members === void 0 ? void 0 : members.filter((0, extensions_1.is)(Field))) !== null && _c !== void 0 ? _c : [];
            const properties = fields.filter(field => field.isProperty);
            const propertyGetters = properties
                .filter(field => !methods.some(method => method.matchesSignature(field.name, 0)))
                .map(({ name }) => new Method({
                name,
                isOverride: false,
                parameters: [],
                body: new Body({ sentences: [new Return({ value: new Reference({ name }) })] }),
            }));
            const propertySetters = properties
                .filter(field => !field.isConstant && !methods.some(method => method.matchesSignature(field.name, 1)))
                .map(({ name }) => new Method({
                name,
                isOverride: false,
                parameters: [new Parameter({ name: '<value>', isVarArg: false })],
                body: new Body({
                    sentences: [
                        new Assignment({
                            variable: new Reference({ name }),
                            value: new Reference({ name: '<value>' }),
                        }),
                    ],
                }),
            }));
            super(Object.assign(Object.assign({}, payload), { members: members && [...members, ...propertyGetters, ...propertySetters] }));
            _ModuleType_isModule.set(this, void 0);
        }
        get hierarchy() {
            const hierarchyExcluding = (node, exclude = []) => {
                if (exclude.includes(node))
                    return [];
                const modules = [
                    ...node.mixins,
                    ...!node.superclass ? [] : [node.superclass],
                ];
                return modules.reduce(([hierarchy, excluded], module) => {
                    const inheritedHierarchy = hierarchyExcluding(module, excluded);
                    const filteredHierarchy = hierarchy.filter(node => !inheritedHierarchy.includes(node));
                    return [
                        [...filteredHierarchy, ...inheritedHierarchy],
                        [module, ...excluded],
                    ];
                }, [[node], [node, ...exclude]])[0];
            };
            return hierarchyExcluding(this);
        }
        get mixins() { return this.supertypes.map(supertype => supertype.reference.target).filter((0, extensions_1.is)(Mixin)); }
        get methods() { return this.members.filter((0, extensions_1.is)(Method)); }
        get fields() { return this.members.filter((0, extensions_1.is)(Field)); }
        get allMembers() { return this.hierarchy.flatMap(parent => parent.members); }
        get allFields() { return this.allMembers.filter((0, extensions_1.is)(Field)); }
        get allMethods() { return this.allMembers.filter((0, extensions_1.is)(Method)); }
        lookupField(name) { return this.allFields.find(field => field.name === name); }
        lookupMethod(name, arity, options) {
            let startReached = !(options === null || options === void 0 ? void 0 : options.lookupStartFQN);
            for (const module of this.hierarchy) {
                if (startReached) {
                    const found = module.methods.find(member => ((options === null || options === void 0 ? void 0 : options.allowAbstractMethods) || !member.isAbstract()) && member.matchesSignature(name, arity));
                    if (found)
                        return found;
                }
                if (module.fullyQualifiedName === (options === null || options === void 0 ? void 0 : options.lookupStartFQN))
                    startReached = true;
            }
            return undefined;
        }
        get isAbstract() {
            return this.abstractMethods.some(method => !this.lookupMethod(method.name, method.parameters.length));
        }
        get abstractMethods() {
            return this.hierarchy.flatMap(module => module.methods.filter(method => method.isAbstract()));
        }
        defaultValueFor(field) {
            if (!this.allFields.includes(field))
                throw new Error('Field does not belong to the module');
            return this.hierarchy.reduceRight((defaultValue, module) => { var _a, _c; return (_c = (_a = module.supertypes.flatMap(_ => _.args).find(({ name }) => name === field.name)) === null || _a === void 0 ? void 0 : _a.value) !== null && _c !== void 0 ? _c : defaultValue; }, field.value);
        }
        inherits(other) { return this.hierarchy.includes(other); }
    }
    _ModuleType_isModule = new WeakMap(), _b = extensions_1.MIXINS;
    ModuleType[_b] = [Module, ...(_a = Entity(supertype)[extensions_1.MIXINS]) !== null && _a !== void 0 ? _a : []];
    __decorate([
        decorators_1.cached
    ], ModuleType.prototype, "hierarchy", null);
    __decorate([
        decorators_1.cached
    ], ModuleType.prototype, "mixins", null);
    __decorate([
        decorators_1.cached
    ], ModuleType.prototype, "methods", null);
    __decorate([
        decorators_1.cached
    ], ModuleType.prototype, "fields", null);
    __decorate([
        decorators_1.cached
    ], ModuleType.prototype, "allMembers", null);
    __decorate([
        decorators_1.cached
    ], ModuleType.prototype, "allFields", null);
    __decorate([
        decorators_1.cached
    ], ModuleType.prototype, "allMethods", null);
    __decorate([
        decorators_1.cached
    ], ModuleType.prototype, "lookupField", null);
    __decorate([
        decorators_1.cached
    ], ModuleType.prototype, "lookupMethod", null);
    __decorate([
        decorators_1.cached
    ], ModuleType.prototype, "isAbstract", null);
    __decorate([
        decorators_1.cached
    ], ModuleType.prototype, "abstractMethods", null);
    __decorate([
        decorators_1.cached
    ], ModuleType.prototype, "defaultValueFor", null);
    return ModuleType;
}
exports.Module = Module;
class Class extends Module(Node) {
    get kind() { return 'Class'; }
    constructor(_a) {
        var { supertypes = [], members = [] } = _a, payload = __rest(_a, ["supertypes", "members"]);
        super(Object.assign({ supertypes, members }, payload));
    }
    get superclass() {
        var _a;
        const superclassReference = (_a = this.supertypes.find(supertype => { var _a; return (_a = supertype.reference.target) === null || _a === void 0 ? void 0 : _a.is(Class); })) === null || _a === void 0 ? void 0 : _a.reference;
        if (superclassReference)
            return superclassReference.target;
        else {
            const objectClass = this.environment.objectClass;
            return this === objectClass ? undefined : objectClass;
        }
    }
}
__decorate([
    decorators_1.cached
], Class.prototype, "superclass", null);
exports.Class = Class;
class Singleton extends Expression(Module(Node)) {
    get kind() { return 'Singleton'; }
    constructor(_a) {
        var { supertypes = [], members = [] } = _a, payload = __rest(_a, ["supertypes", "members"]);
        super(Object.assign({ supertypes, members }, payload));
    }
    get superclass() {
        var _a;
        const superclassReference = (_a = this.supertypes.find(supertype => { var _a; return (_a = supertype.reference.target) === null || _a === void 0 ? void 0 : _a.is(Class); })) === null || _a === void 0 ? void 0 : _a.reference;
        if (superclassReference)
            return superclassReference.target;
        else
            return this.environment.objectClass;
    }
    isClosure(arity) {
        return arity === undefined
            ? this.methods.some(_ => _.name === constants_1.CLOSURE_EVALUATE_METHOD)
            : !!this.lookupMethod(constants_1.CLOSURE_EVALUATE_METHOD, arity);
    }
}
__decorate([
    decorators_1.cached
], Singleton.prototype, "isClosure", null);
exports.Singleton = Singleton;
class Mixin extends Module(Node) {
    get kind() { return 'Mixin'; }
    constructor(_a) {
        var { supertypes = [], members = [] } = _a, payload = __rest(_a, ["supertypes", "members"]);
        super(Object.assign({ supertypes, members }, payload));
    }
    get superclass() { return undefined; }
}
exports.Mixin = Mixin;
class Describe extends Module(Node) {
    get kind() { return 'Describe'; }
    constructor(_a) {
        var { members = [] } = _a, payload = __rest(_a, ["members"]);
        super(Object.assign({ members }, payload));
        this.supertypes = [new ParameterizedType({ reference: new Reference({ name: constants_1.OBJECT_MODULE }) })];
    }
    get superclass() { return this.supertypes[0].reference.target; }
    get tests() { return this.members.filter((0, extensions_1.is)(Test)); }
}
exports.Describe = Describe;
class Field extends Node {
    get kind() { return 'Field'; }
    constructor(_a) {
        var { value = new Literal({ value: null }), isProperty = false } = _a, payload = __rest(_a, ["value", "isProperty"]);
        super(Object.assign({ value, isProperty }, payload));
    }
    get label() {
        return `${this.parent.fullyQualifiedName}.${this.name} ${super.label}`;
    }
}
exports.Field = Field;
class Method extends Node {
    get kind() { return 'Method'; }
    constructor(_a) {
        var { isOverride = false, parameters = [] } = _a, payload = __rest(_a, ["isOverride", "parameters"]);
        super(Object.assign({ isOverride, parameters }, payload));
        this.compiled = false;
    }
    get label() {
        return `${this.parent.fullyQualifiedName}.${this.name}/${this.parameters.length}`;
    }
    get fullLabel() {
        return `${this.name}(${this.parameters.map(_ => _.name).join(', ')})`;
    }
    isAbstract() { return !this.body; }
    isConcrete() { return !this.isAbstract() && !this.isNative(); }
    isNative() { return this.body === constants_1.KEYWORDS.NATIVE; }
    get hasNativeImplementation() { return this.isNative() || this.compiled; }
    get fromProperty() { return this.isSynthetic && this.parameters.length < 2 && !!this.parent.lookupField(this.name); }
    get hasVarArgs() { var _a; return !!((_a = (0, extensions_1.last)(this.parameters)) === null || _a === void 0 ? void 0 : _a.isVarArg); }
    get sentences() {
        return this.isConcrete() ? this.body.sentences : [];
    }
    matchesSignature(name, arity) {
        return this.name == name && (this.hasVarArgs && this.parameters.length - 1 <= arity ||
            this.parameters.length === arity);
    }
}
__decorate([
    decorators_1.cached
], Method.prototype, "fromProperty", null);
__decorate([
    decorators_1.cached
], Method.prototype, "hasVarArgs", null);
__decorate([
    decorators_1.cached
], Method.prototype, "sentences", null);
__decorate([
    decorators_1.cached
], Method.prototype, "matchesSignature", null);
exports.Method = Method;
function Sentence(supertype) {
    var _a;
    var _SentenceType_isSentence, _b;
    class SentenceType extends supertype {
        constructor() {
            super(...arguments);
            _SentenceType_isSentence.set(this, void 0);
        }
    }
    _SentenceType_isSentence = new WeakMap(), _b = extensions_1.MIXINS;
    SentenceType[_b] = [Sentence, ...(_a = supertype[extensions_1.MIXINS]) !== null && _a !== void 0 ? _a : []];
    return SentenceType;
}
exports.Sentence = Sentence;
class Return extends Sentence(Node) {
    get kind() { return 'Return'; }
    constructor(payload = {}) { super(payload); }
}
exports.Return = Return;
class Assignment extends Sentence(Node) {
    get kind() { return 'Assignment'; }
    constructor(payload) { super(payload); }
}
exports.Assignment = Assignment;
function Expression(supertype) {
    var _a;
    var _ExpressionType_isExpression, _b;
    class ExpressionType extends Sentence(supertype) {
        constructor() {
            super(...arguments);
            _ExpressionType_isExpression.set(this, void 0);
        }
    }
    _ExpressionType_isExpression = new WeakMap(), _b = extensions_1.MIXINS;
    ExpressionType[_b] = [Expression, ...(_a = Sentence(supertype)[extensions_1.MIXINS]) !== null && _a !== void 0 ? _a : []];
    return ExpressionType;
}
exports.Expression = Expression;
class Reference extends Expression(Node) {
    get kind() { return 'Reference'; }
    constructor(payload) { super(payload); }
    get label() {
        return `${this.name} ${super.label}`;
    }
    get target() { return this.scope.resolve(this.name); }
}
__decorate([
    decorators_1.cached
], Reference.prototype, "target", null);
exports.Reference = Reference;
class Self extends Expression(Node) {
    get kind() { return 'Self'; }
    constructor(payload = {}) { super(payload); }
}
exports.Self = Self;
class Literal extends Expression(Node) {
    get kind() { return 'Literal'; }
    constructor(payload) { super(payload); }
    isNumeric() { return typeof this.value === 'number'; }
    isString() { return typeof this.value === 'string'; }
    isBoolean() { return typeof this.value === 'boolean'; }
    isNull() { return this.value === null; }
    isCollection() { return isArray(this.value); }
}
exports.Literal = Literal;
class Send extends Expression(Node) {
    get kind() { return 'Send'; }
    constructor(_a) {
        var { args = [] } = _a, payload = __rest(_a, ["args"]);
        super(Object.assign({ args }, payload));
    }
    get signature() {
        return `${this.message}/${this.args.length}`;
    }
    get numArgs() {
        return this.args.length;
    }
    isPrefixOperator() {
        return this.originalOperator != undefined
            && Object.keys(constants_1.PREFIX_OPERATORS).includes(this.originalOperator)
            && (0, extensions_1.isEmpty)(this.args);
    }
    isInfixOperator() {
        return constants_1.INFIX_OPERATORS.flat().includes(this.message)
            && this.args.length === 1;
    }
}
exports.Send = Send;
class Super extends Expression(Node) {
    get kind() { return 'Super'; }
    constructor(_a = {}) {
        var { args = [] } = _a, payload = __rest(_a, ["args"]);
        super(Object.assign({ args }, payload));
    }
}
exports.Super = Super;
class New extends Expression(Node) {
    get kind() { return 'New'; }
    constructor(_a) {
        var { args = [] } = _a, payload = __rest(_a, ["args"]);
        super(Object.assign({ args }, payload));
    }
}
exports.New = New;
class If extends Expression(Node) {
    get kind() { return 'If'; }
    constructor(_a) {
        var { elseBody = new Body() } = _a, payload = __rest(_a, ["elseBody"]);
        super(Object.assign({ elseBody }, payload));
    }
    isIfExpression() {
        var _a, _b;
        return !!((_a = (0, extensions_1.last)(this.thenBody.sentences)) === null || _a === void 0 ? void 0 : _a.is(Expression)) && !!((_b = (0, extensions_1.last)(this.elseBody.sentences)) === null || _b === void 0 ? void 0 : _b.is(Expression));
    }
}
exports.If = If;
class Throw extends Expression(Node) {
    get kind() { return 'Throw'; }
    constructor(payload) { super(payload); }
}
exports.Throw = Throw;
class Try extends Expression(Node) {
    get kind() { return 'Try'; }
    constructor(_a) {
        var { catches = [], always = new Body() } = _a, payload = __rest(_a, ["catches", "always"]);
        super(Object.assign({ catches, always }, payload));
    }
}
exports.Try = Try;
class Catch extends Node {
    get kind() { return 'Catch'; }
    constructor(_a) {
        var { parameterType = new Reference({ name: constants_1.EXCEPTION_MODULE }) } = _a, payload = __rest(_a, ["parameterType"]);
        super(Object.assign({ parameterType }, payload));
    }
}
exports.Catch = Catch;
const Closure = (_a) => {
    var _b, _c;
    var { sentences, parameters, code } = _a, payload = __rest(_a, ["sentences", "parameters", "code"]);
    const initialSentences = (_b = sentences === null || sentences === void 0 ? void 0 : sentences.slice(0, -1)) !== null && _b !== void 0 ? _b : [];
    const lastSentence = (_c = sentences === null || sentences === void 0 ? void 0 : sentences.slice(-1).map(value => value.is(Expression) && (!value.is(If) || value.isIfExpression()) ? new Return({ value }) : value)) !== null && _c !== void 0 ? _c : [];
    return new Singleton(Object.assign({ supertypes: [new ParameterizedType({ reference: new Reference({ name: constants_1.CLOSURE_MODULE }) })], members: [
            new Method({ name: constants_1.CLOSURE_EVALUATE_METHOD, parameters, body: new Body({ sentences: [...initialSentences, ...lastSentence] }) }),
            ...code ? [
                new Field({ name: constants_1.CLOSURE_TO_STRING_METHOD, isConstant: true, value: new Literal({ value: code }) }),
            ] : [],
        ] }, payload));
};
exports.Closure = Closure;
class Environment extends Node {
    get kind() { return 'Environment'; }
    constructor(payload) { super(payload); }
    get sourceFileName() { return undefined; }
    get ancestors() { return []; }
    getNodeById(id) {
        const node = this.nodeCache.get(id);
        if (!node)
            throw new Error(`Missing node with id ${id}`);
        return node;
    }
    getNodeOrUndefinedByFQN(fullyQualifiedName) {
        const [, id] = fullyQualifiedName.split('#');
        if (id)
            return this.getNodeById(id);
        return this.scope.resolve(fullyQualifiedName);
    }
    getNodeByFQN(fullyQualifiedName) {
        const node = this.getNodeOrUndefinedByFQN(fullyQualifiedName);
        if (!node)
            throw new Error(`Could not resolve reference to ${fullyQualifiedName}`);
        return node;
    }
    get objectClass() { return this.getNodeByFQN(constants_1.OBJECT_MODULE); }
    get numberClass() { return this.getNodeByFQN(constants_1.NUMBER_MODULE); }
    get stringClass() { return this.getNodeByFQN(constants_1.STRING_MODULE); }
    get booleanClass() { return this.getNodeByFQN(constants_1.BOOLEAN_MODULE); }
    newImportFor(importNode) {
        const node = this.replNode();
        const imported = node.scope.resolve(importNode.entity.name);
        if (imported.is(Package)) {
            node.scope.include(imported.scope);
            return;
        }
        node.scope.register([imported.name, imported]);
    }
    replNode() {
        return this.getNodeByFQN(constants_1.REPL);
    }
}
__decorate([
    decorators_1.lazy
], Environment.prototype, "nodeCache", void 0);
__decorate([
    decorators_1.lazy
], Environment.prototype, "typeRegistry", void 0);
__decorate([
    decorators_1.cached
], Environment.prototype, "getNodeOrUndefinedByFQN", null);
exports.Environment = Environment;
//# sourceMappingURL=model.js.map