import { ConstructorFor, InstanceOf, List, Mixable, MixinDefinition, MIXINS, TypeDefinition } from './extensions';
import { TypeRegistry, WollokType } from './typeSystem/wollokTypes';
export type Name = string;
export type Id = string;
export interface Scope {
    resolve<N extends Node>(qualifiedName: Name, allowLookup?: boolean): N | undefined;
    resolveAll<N extends Node>(qualifiedName: Name): List<N>;
    include(...others: Scope[]): void;
    register(...contributions: [Name, Node][]): void;
    localContributions(): [Name, Node][];
    localEntities(): Node[];
}
export declare class SourceIndex {
    readonly offset: number;
    readonly line: number;
    readonly column: number;
    constructor(args: {
        offset: number;
        line: number;
        column: number;
    });
    toString(): string;
}
export declare class SourceMap {
    readonly start: SourceIndex;
    readonly end: SourceIndex;
    constructor(args: {
        start: SourceIndex;
        end: SourceIndex;
    });
    toString(): string;
    covers(offset: number): boolean;
    includes(other: SourceMap): boolean;
}
export declare class Annotation {
    readonly name: Name;
    readonly args: Record<Name, LiteralValue>;
    constructor(name: Name, args?: Record<Name, LiteralValue>);
}
export type Code = string;
export type Level = 'warning' | 'error';
export interface BaseProblem {
    readonly code: Code;
    readonly level: Level;
    readonly values: List<string>;
    readonly sourceMap?: SourceMap;
}
export interface Problem extends BaseProblem {
    readonly node: Node;
}
type AttributeKeys<T> = {
    [K in keyof T]-?: T[K] extends Function ? never : K;
}[keyof T];
type Payload<T, MandatoryFields extends keyof T = never> = Pick<T, MandatoryFields> & Partial<Pick<T, AttributeKeys<T>>>;
export declare abstract class Node {
    abstract get kind(): string;
    readonly id: Id;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap;
    readonly problems?: List<BaseProblem>;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    constructor(payload: Record<string, unknown>);
    get categories(): Function[];
    get sourceFileName(): string | undefined;
    get sourceInfo(): string;
    get label(): string;
    get isSynthetic(): boolean;
    get hasProblems(): boolean;
    get type(): WollokType;
    get parentPackage(): Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceOf<Q>;
    copy(delta?: Record<string, unknown>): this;
    get children(): List<Node>;
    siblings(): List<Node>;
    get descendants(): List<Node>;
    get ancestors(): List<Node>;
    transform(tx: (node: Node) => Node): this;
    forEach(tx: (node: Node, parent?: Node) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node) => T, initial: T): T;
}
export declare class Parameter extends Node {
    get kind(): 'Parameter';
    readonly name: Name;
    readonly isVarArg: boolean;
    parent: Method | Catch;
    constructor({ isVarArg, ...payload }: Payload<Parameter, 'name'>);
}
export declare class ParameterizedType extends Node {
    get kind(): 'ParameterizedType';
    readonly reference: Reference<Module | Class>;
    readonly args: List<NamedArgument>;
    parent: Module;
    constructor({ args, ...payload }: Payload<ParameterizedType, 'reference'>);
}
export declare class NamedArgument extends Node {
    get kind(): 'NamedArgument';
    readonly name: Name;
    readonly value: Expression;
    parent: ParameterizedType | New;
    constructor(payload: Payload<NamedArgument, 'name' | 'value'>);
}
export declare class Import extends Node {
    get kind(): 'Import';
    readonly entity: Reference<Entity>;
    readonly isGeneric: boolean;
    parent: Package;
    constructor({ isGeneric, ...payload }: Payload<Import, 'entity'>);
    get importedEntity(): Entity;
    allImportedEntities(): Entity[];
}
export declare class Body extends Node {
    get kind(): 'Body';
    readonly sentences: List<Sentence>;
    constructor({ sentences, ...payload }?: Payload<Body>);
    parent: Program | Test | Method | If | Try | Catch;
    isEmpty(): boolean;
}
export type Entity = InstanceType<ConstructorFor<typeof Entity>>;
export declare function Entity<S extends Mixable<Node>>(supertype: S): ((abstract new (...args: any) => {
    "__#1@#isEntity": any;
    readonly name?: string | undefined;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: (typeof Entity | MixinDefinition<Node>)[];
}) & S;
declare const Package_base: ((abstract new (...args: any) => {
    "__#1@#isEntity": any;
    readonly name?: string | undefined;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: (typeof Entity | MixinDefinition<Node>)[];
}) & typeof Node;
export declare class Package extends Package_base {
    get kind(): 'Package';
    readonly name: Name;
    readonly imports: List<Import>;
    readonly members: List<Entity>;
    readonly fileName?: string;
    parent: Package | Environment;
    constructor({ name, imports, members, ...payload }: Payload<Package, 'name'>);
    get sourceFileName(): string | undefined;
    get isGlobalPackage(): boolean;
    get isTestFile(): boolean;
    get isWLKFile(): boolean;
    get isImportable(): boolean;
    getNodeByQN<N extends Entity>(qualifiedName: Name): N;
    getNodeOrUndefinedByQN<N extends Entity>(qualifiedName: Name): N | undefined;
    isConstant(localName: string): boolean;
    allScopedEntities(): Node[];
}
declare const Program_base: ((abstract new (...args: any) => {
    "__#1@#isEntity": any;
    readonly name?: string | undefined;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: (typeof Entity | MixinDefinition<Node>)[];
}) & typeof Node;
export declare class Program extends Program_base {
    get kind(): 'Program';
    readonly name: Name;
    readonly body: Body;
    parent: Package;
    constructor(payload: Payload<Program, 'name' | 'body'>);
    sentences(): List<Sentence>;
}
declare const Test_base: ((abstract new (...args: any) => {
    "__#1@#isEntity": any;
    readonly name?: string | undefined;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: (typeof Entity | MixinDefinition<Node>)[];
}) & typeof Node;
export declare class Test extends Test_base {
    get kind(): 'Test';
    readonly isOnly: boolean;
    readonly name: Name;
    readonly body: Body;
    parent: Describe;
    constructor({ isOnly, ...payload }: Payload<Test, 'name' | 'body'>);
    get sentences(): List<Sentence>;
}
declare const Variable_base: ((abstract new (...args: any) => {
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: (MixinDefinition<Node> | typeof Sentence)[];
}) & ((abstract new (...args: any) => {
    "__#1@#isEntity": any;
    readonly name?: string | undefined;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q_1 extends TypeDefinition<Node>>(kindOrCategory: Q_1): this is InstanceType<ConstructorFor<Q_1>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: (typeof Entity | MixinDefinition<Node>)[];
}) & typeof Node;
export declare class Variable extends Variable_base {
    get kind(): 'Variable';
    readonly name: Name;
    readonly isConstant: boolean;
    readonly value: Expression;
    parent: Package | Body;
    constructor({ value, ...payload }: Payload<Variable, 'name' | 'isConstant'>);
    get isAtPackageLevel(): boolean;
}
export type Module = InstanceType<ConstructorFor<typeof Module>>;
export declare function Module<S extends Mixable<Node>>(supertype: S): ((abstract new (...args: any[]) => {
    "__#2@#isModule": any;
    readonly name?: string | undefined;
    readonly supertypes: List<ParameterizedType>;
    readonly members: List<Field | Method | Variable | Test>;
    readonly superclass: Class | undefined;
    readonly hierarchy: List<any>;
    readonly mixins: List<Mixin>;
    readonly methods: List<Method>;
    readonly fields: List<Field>;
    readonly allMembers: List<Field | Method | Variable | Test>;
    readonly allFields: List<Field>;
    readonly allMethods: List<Method>;
    lookupField(name: string): Field | undefined;
    lookupMethod(name: Name, arity: number, options?: {
        lookupStartFQN?: Name;
        allowAbstractMethods?: boolean;
    }): Method | undefined;
    readonly isAbstract: boolean;
    readonly abstractMethods: List<Method>;
    defaultValueFor(field: Field): Expression;
    inherits(other: any): boolean;
    "__#1@#isEntity": any;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & S;
declare const Class_base: ((abstract new (...args: any[]) => {
    "__#2@#isModule": any;
    readonly name?: string | undefined;
    readonly supertypes: List<ParameterizedType>;
    readonly members: List<Field | Method | Variable | Test>;
    readonly superclass: Class | undefined;
    readonly hierarchy: List<any>;
    readonly mixins: List<Mixin>;
    readonly methods: List<Method>;
    readonly fields: List<Field>;
    readonly allMembers: List<Field | Method | Variable | Test>;
    readonly allFields: List<Field>;
    readonly allMethods: List<Method>;
    lookupField(name: string): Field | undefined;
    lookupMethod(name: string, arity: number, options?: {
        lookupStartFQN?: string | undefined;
        allowAbstractMethods?: boolean | undefined;
    } | undefined): Method | undefined;
    readonly isAbstract: boolean;
    readonly abstractMethods: List<Method>;
    defaultValueFor(field: Field): {
        "__#4@#isExpression": any;
        "__#3@#isSentence": any;
        readonly kind: string;
        readonly id: string;
        readonly scope: Scope;
        readonly sourceMap?: SourceMap | undefined;
        readonly problems?: List<BaseProblem> | undefined;
        readonly metadata: List<Annotation>;
        environment: Environment;
        parent: Node;
        readonly categories: Function[];
        readonly sourceFileName: string | undefined;
        readonly sourceInfo: string;
        readonly label: string;
        readonly isSynthetic: boolean;
        readonly hasProblems: boolean;
        readonly type: WollokType;
        readonly parentPackage: Package | undefined;
        toString(verbose?: boolean): string;
        is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
        copy(delta?: Record<string, unknown>): any;
        readonly children: List<Node>;
        siblings(): List<Node>;
        readonly descendants: List<Node>;
        readonly ancestors: List<Node>;
        transform(tx: (node: Node) => Node): any;
        forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
        reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
    } & Node;
    inherits(other: any): boolean;
    "__#1@#isEntity": any;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q_1 extends TypeDefinition<Node>>(kindOrCategory: Q_1): this is InstanceType<ConstructorFor<Q_1>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & typeof Node;
export declare class Class extends Class_base {
    get kind(): 'Class';
    readonly name: Name;
    readonly supertypes: List<ParameterizedType>;
    readonly members: List<Field | Method>;
    parent: Package;
    constructor({ supertypes, members, ...payload }: Payload<Class, 'name'>);
    get superclass(): Class | undefined;
}
declare const Singleton_base: ((abstract new (...args: any) => {
    "__#4@#isExpression": any;
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & ((abstract new (...args: any[]) => {
    "__#2@#isModule": any;
    readonly name?: string | undefined;
    readonly supertypes: List<ParameterizedType>;
    readonly members: List<Field | Method | Variable | Test>;
    readonly superclass: Class | undefined;
    readonly hierarchy: List<any>;
    readonly mixins: List<Mixin>;
    readonly methods: List<Method>;
    readonly fields: List<Field>;
    readonly allMembers: List<Field | Method | Variable | Test>;
    readonly allFields: List<Field>;
    readonly allMethods: List<Method>;
    lookupField(name: string): Field | undefined;
    lookupMethod(name: string, arity: number, options?: {
        lookupStartFQN?: string | undefined;
        allowAbstractMethods?: boolean | undefined;
    } | undefined): Method | undefined;
    readonly isAbstract: boolean;
    readonly abstractMethods: List<Method>;
    defaultValueFor(field: Field): {
        "__#4@#isExpression": any;
        "__#3@#isSentence": any;
        readonly kind: string;
        readonly id: string;
        readonly scope: Scope;
        readonly sourceMap?: SourceMap | undefined;
        readonly problems?: List<BaseProblem> | undefined;
        readonly metadata: List<Annotation>;
        environment: Environment;
        parent: Node;
        readonly categories: Function[];
        readonly sourceFileName: string | undefined;
        readonly sourceInfo: string;
        readonly label: string;
        readonly isSynthetic: boolean;
        readonly hasProblems: boolean;
        readonly type: WollokType;
        readonly parentPackage: Package | undefined;
        toString(verbose?: boolean): string;
        is<Q_1 extends TypeDefinition<Node>>(kindOrCategory: Q_1): this is InstanceType<ConstructorFor<Q_1>>;
        copy(delta?: Record<string, unknown>): any;
        readonly children: List<Node>;
        siblings(): List<Node>;
        readonly descendants: List<Node>;
        readonly ancestors: List<Node>;
        transform(tx: (node: Node) => Node): any;
        forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
        reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
    } & Node;
    inherits(other: any): boolean;
    "__#1@#isEntity": any;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q_2 extends TypeDefinition<Node>>(kindOrCategory: Q_2): this is InstanceType<ConstructorFor<Q_2>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & typeof Node;
export declare class Singleton extends Singleton_base {
    get kind(): 'Singleton';
    readonly name?: Name;
    readonly supertypes: List<ParameterizedType>;
    readonly members: List<Field | Method>;
    parent: Package | Body;
    constructor({ supertypes, members, ...payload }: Payload<Singleton>);
    get superclass(): Class;
    isClosure(arity?: number): boolean;
}
declare const Mixin_base: ((abstract new (...args: any[]) => {
    "__#2@#isModule": any;
    readonly name?: string | undefined;
    readonly supertypes: List<ParameterizedType>;
    readonly members: List<Field | Method | Variable | Test>;
    readonly superclass: Class | undefined;
    readonly hierarchy: List<any>;
    readonly mixins: List<Mixin>;
    readonly methods: List<Method>;
    readonly fields: List<Field>;
    readonly allMembers: List<Field | Method | Variable | Test>;
    readonly allFields: List<Field>;
    readonly allMethods: List<Method>;
    lookupField(name: string): Field | undefined;
    lookupMethod(name: string, arity: number, options?: {
        lookupStartFQN?: string | undefined;
        allowAbstractMethods?: boolean | undefined;
    } | undefined): Method | undefined;
    readonly isAbstract: boolean;
    readonly abstractMethods: List<Method>;
    defaultValueFor(field: Field): {
        "__#4@#isExpression": any;
        "__#3@#isSentence": any;
        readonly kind: string;
        readonly id: string;
        readonly scope: Scope;
        readonly sourceMap?: SourceMap | undefined;
        readonly problems?: List<BaseProblem> | undefined;
        readonly metadata: List<Annotation>;
        environment: Environment;
        parent: Node;
        readonly categories: Function[];
        readonly sourceFileName: string | undefined;
        readonly sourceInfo: string;
        readonly label: string;
        readonly isSynthetic: boolean;
        readonly hasProblems: boolean;
        readonly type: WollokType;
        readonly parentPackage: Package | undefined;
        toString(verbose?: boolean): string;
        is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
        copy(delta?: Record<string, unknown>): any;
        readonly children: List<Node>;
        siblings(): List<Node>;
        readonly descendants: List<Node>;
        readonly ancestors: List<Node>;
        transform(tx: (node: Node) => Node): any;
        forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
        reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
    } & Node;
    inherits(other: any): boolean;
    "__#1@#isEntity": any;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q_1 extends TypeDefinition<Node>>(kindOrCategory: Q_1): this is InstanceType<ConstructorFor<Q_1>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & typeof Node;
export declare class Mixin extends Mixin_base {
    get kind(): 'Mixin';
    readonly name: Name;
    readonly supertypes: List<ParameterizedType>;
    readonly members: List<Field | Method>;
    parent: Package;
    constructor({ supertypes, members, ...payload }: Payload<Mixin, 'name'>);
    get superclass(): undefined;
}
declare const Describe_base: ((abstract new (...args: any[]) => {
    "__#2@#isModule": any;
    readonly name?: string | undefined;
    readonly supertypes: List<ParameterizedType>;
    readonly members: List<Field | Method | Variable | Test>;
    readonly superclass: Class | undefined;
    readonly hierarchy: List<any>;
    readonly mixins: List<Mixin>;
    readonly methods: List<Method>;
    readonly fields: List<Field>;
    readonly allMembers: List<Field | Method | Variable | Test>;
    readonly allFields: List<Field>;
    readonly allMethods: List<Method>;
    lookupField(name: string): Field | undefined;
    lookupMethod(name: string, arity: number, options?: {
        lookupStartFQN?: string | undefined;
        allowAbstractMethods?: boolean | undefined;
    } | undefined): Method | undefined;
    readonly isAbstract: boolean;
    readonly abstractMethods: List<Method>;
    defaultValueFor(field: Field): {
        "__#4@#isExpression": any;
        "__#3@#isSentence": any;
        readonly kind: string;
        readonly id: string;
        readonly scope: Scope;
        readonly sourceMap?: SourceMap | undefined;
        readonly problems?: List<BaseProblem> | undefined;
        readonly metadata: List<Annotation>;
        environment: Environment;
        parent: Node;
        readonly categories: Function[];
        readonly sourceFileName: string | undefined;
        readonly sourceInfo: string;
        readonly label: string;
        readonly isSynthetic: boolean;
        readonly hasProblems: boolean;
        readonly type: WollokType;
        readonly parentPackage: Package | undefined;
        toString(verbose?: boolean): string;
        is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
        copy(delta?: Record<string, unknown>): any;
        readonly children: List<Node>;
        siblings(): List<Node>;
        readonly descendants: List<Node>;
        readonly ancestors: List<Node>;
        transform(tx: (node: Node) => Node): any;
        forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
        reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
    } & Node;
    inherits(other: any): boolean;
    "__#1@#isEntity": any;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q_1 extends TypeDefinition<Node>>(kindOrCategory: Q_1): this is InstanceType<ConstructorFor<Q_1>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & typeof Node;
export declare class Describe extends Describe_base {
    get kind(): 'Describe';
    readonly name: Name;
    readonly members: List<Field | CodeContainer>;
    readonly supertypes: List<ParameterizedType>;
    parent: Package;
    constructor({ members, ...payload }: Payload<Describe, 'name'>);
    get superclass(): Class;
    get tests(): List<Test>;
}
export declare class Field extends Node {
    get kind(): 'Field';
    readonly name: Name;
    readonly isConstant: boolean;
    readonly isProperty: boolean;
    readonly value: Expression;
    constructor({ value, isProperty, ...payload }: Payload<Field, 'name' | 'isConstant'>);
    parent: Module;
    get label(): string;
}
export declare class Method extends Node {
    get kind(): 'Method';
    readonly name: Name;
    readonly isOverride: boolean;
    readonly parameters: List<Parameter>;
    readonly body?: Body | 'native';
    parent: Module;
    compiled: boolean;
    constructor({ isOverride, parameters, ...payload }: Payload<Method, 'name'>);
    get label(): string;
    get fullLabel(): string;
    isAbstract(): this is {
        body: undefined;
    };
    isConcrete(): this is {
        body: Body;
    };
    isNative(): this is {
        body?: Body;
    };
    get hasNativeImplementation(): boolean;
    get fromProperty(): boolean;
    get hasVarArgs(): boolean;
    get sentences(): List<Sentence>;
    matchesSignature(name: Name, arity: number): boolean;
}
export type Sentence = InstanceType<ConstructorFor<typeof Sentence>>;
export declare function Sentence<S extends Mixable<Node>>(supertype: S): ((abstract new (...args: any) => {
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: (MixinDefinition<Node> | typeof Sentence)[];
}) & S;
declare const Return_base: ((abstract new (...args: any) => {
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: (MixinDefinition<Node> | typeof Sentence)[];
}) & typeof Node;
export declare class Return extends Return_base {
    get kind(): 'Return';
    readonly value?: Expression;
    parent: Body;
    constructor(payload?: Payload<Return>);
}
declare const Assignment_base: ((abstract new (...args: any) => {
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: (MixinDefinition<Node> | typeof Sentence)[];
}) & typeof Node;
export declare class Assignment extends Assignment_base {
    get kind(): 'Assignment';
    readonly variable: Reference<Variable | Field>;
    readonly value: Expression;
    parent: Body;
    constructor(payload: Payload<Assignment, 'variable' | 'value'>);
}
export type Expression = InstanceType<ConstructorFor<typeof Expression>>;
export declare function Expression<S extends Mixable<Node>>(supertype: S): ((abstract new (...args: any) => {
    "__#4@#isExpression": any;
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & S;
declare const Reference_base: ((abstract new (...args: any) => {
    "__#4@#isExpression": any;
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & typeof Node;
export declare class Reference<N extends Node> extends Reference_base {
    get kind(): 'Reference';
    readonly name: Name;
    constructor(payload: Payload<Reference<N>, 'name'>);
    get label(): string;
    get target(): N | undefined;
}
declare const Self_base: ((abstract new (...args: any) => {
    "__#4@#isExpression": any;
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & typeof Node;
export declare class Self extends Self_base {
    get kind(): 'Self';
    constructor(payload?: Payload<Self>);
}
export type LiteralValue = number | string | boolean | null | readonly [Reference<Class>, List<Expression>];
declare const Literal_base: ((abstract new (...args: any) => {
    "__#4@#isExpression": any;
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T_1>(tx: (acum: T_1, node: Node, parent?: Node | undefined) => T_1, initial: T_1): T_1;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & typeof Node;
export declare class Literal<T extends LiteralValue = LiteralValue> extends Literal_base {
    get kind(): 'Literal';
    readonly value: T;
    constructor(payload: Payload<Literal<T>, 'value'>);
    isNumeric(): this is {
        value: number;
    };
    isString(): this is {
        value: string;
    };
    isBoolean(): this is {
        value: boolean;
    };
    isNull(): this is {
        value: null;
    };
    isCollection(): this is {
        value: readonly [Reference<Class>, List<Expression>];
    };
}
declare const Send_base: ((abstract new (...args: any) => {
    "__#4@#isExpression": any;
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & typeof Node;
export declare class Send extends Send_base {
    get kind(): 'Send';
    readonly receiver: Expression;
    readonly message: Name;
    readonly originalOperator?: Name;
    readonly args: List<Expression>;
    constructor({ args, ...payload }: Payload<Send, 'receiver' | 'message'>);
    get signature(): string;
    get numArgs(): number;
    isPrefixOperator(): boolean;
    isInfixOperator(): boolean;
}
declare const Super_base: ((abstract new (...args: any) => {
    "__#4@#isExpression": any;
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & typeof Node;
export declare class Super extends Super_base {
    get kind(): 'Super';
    readonly args: List<Expression>;
    constructor({ args, ...payload }?: Payload<Super>);
}
declare const New_base: ((abstract new (...args: any) => {
    "__#4@#isExpression": any;
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & typeof Node;
export declare class New extends New_base {
    get kind(): 'New';
    readonly instantiated: Reference<Module>;
    readonly args: List<NamedArgument>;
    constructor({ args, ...payload }: Payload<New, 'instantiated'>);
}
declare const If_base: ((abstract new (...args: any) => {
    "__#4@#isExpression": any;
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & typeof Node;
export declare class If extends If_base {
    get kind(): 'If';
    readonly condition: Expression;
    readonly thenBody: Body;
    readonly elseBody: Body;
    constructor({ elseBody, ...payload }: Payload<If, 'condition' | 'thenBody'>);
    isIfExpression(): boolean;
}
declare const Throw_base: ((abstract new (...args: any) => {
    "__#4@#isExpression": any;
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & typeof Node;
export declare class Throw extends Throw_base {
    get kind(): 'Throw';
    readonly exception: Expression;
    constructor(payload: Payload<Throw, 'exception'>);
}
declare const Try_base: ((abstract new (...args: any) => {
    "__#4@#isExpression": any;
    "__#3@#isSentence": any;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly label: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
}) & {
    [MIXINS]: MixinDefinition<Node>[];
}) & typeof Node;
export declare class Try extends Try_base {
    get kind(): 'Try';
    readonly body: Body;
    readonly catches: List<Catch>;
    readonly always: Body;
    constructor({ catches, always, ...payload }: Payload<Try, 'body'>);
}
export declare class Catch extends Node {
    get kind(): 'Catch';
    readonly parameter: Parameter;
    readonly parameterType: Reference<Module>;
    readonly body: Body;
    parent: Try;
    constructor({ parameterType, ...payload }: Payload<Catch, 'parameter' | 'body'>);
}
type ClosurePayload = {
    parameters?: List<Parameter>;
    sentences?: List<Sentence>;
    code?: string;
    sourceMap?: SourceMap;
    metadata?: List<Annotation>;
};
export declare const Closure: ({ sentences, parameters, code, ...payload }: ClosurePayload) => Singleton;
export declare class Environment extends Node {
    get kind(): 'Environment';
    readonly members: List<Package>;
    readonly nodeCache: ReadonlyMap<Id, Node>;
    readonly typeRegistry: TypeRegistry;
    parent: never;
    constructor(payload: Payload<Environment, 'members'>);
    get sourceFileName(): undefined;
    get ancestors(): List<Node>;
    getNodeById<N extends Node>(id: Id): N;
    getNodeOrUndefinedByFQN<N extends Node>(fullyQualifiedName: Name): N | undefined;
    getNodeByFQN<N extends Node>(fullyQualifiedName: Name): N;
    get objectClass(): Class;
    get numberClass(): Class;
    get stringClass(): Class;
    get booleanClass(): Class;
    newImportFor(importNode: Import): void;
    replNode(): Package;
}
export type CodeContainer = Method | Test;
export type Referenciable = Variable | Field | Parameter;
export {};
