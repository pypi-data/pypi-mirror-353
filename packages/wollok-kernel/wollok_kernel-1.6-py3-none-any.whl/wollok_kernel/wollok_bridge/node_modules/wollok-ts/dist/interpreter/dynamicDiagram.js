"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDynamicDiagramData = exports.DynamicNodeType = void 0;
const uuid_1 = require("uuid");
const constants_1 = require("../constants");
const extensions_1 = require("../extensions");
const model_1 = require("../model");
var DynamicNodeType;
(function (DynamicNodeType) {
    DynamicNodeType["OBJECT"] = "object";
    DynamicNodeType["LITERAL"] = "literal";
    DynamicNodeType["NULL"] = "null";
    DynamicNodeType["REPL"] = "REPL";
})(DynamicNodeType = exports.DynamicNodeType || (exports.DynamicNodeType = {}));
const getDynamicDiagramData = (interpreter, rootPackage) => {
    const environment = interpreter.evaluation.environment;
    const replPackage = rootPackage !== null && rootPackage !== void 0 ? rootPackage : environment.replNode();
    const entitiesImportedFromConsole = replPackage.allScopedEntities();
    const objects = getCurrentObjects(interpreter);
    const dynamicDiagramObjects = Array.from(objects.keys())
        .filter((name) => {
        const object = objects.get(name);
        return constFromRoot(name, replPackage) || object && autoImportedFromConsole(object, entitiesImportedFromConsole);
    })
        .flatMap((name) => fromLocal(name, objects.get(name), interpreter, replPackage));
    return (0, extensions_1.uniqueBy)(dynamicDiagramObjects, 'id');
};
exports.getDynamicDiagramData = getDynamicDiagramData;
const getCurrentObjects = (interpreter) => {
    const currentFrame = interpreter.evaluation.currentFrame;
    return new Map(Array.from(currentFrame.locals.keys()).map((name) => [name, currentFrame.get(name)]));
};
const autoImportedFromConsole = (obj, importedFromConsole) => importedFromConsole.includes(obj.module);
const fromLocal = (name, obj, interpreter, replPackage) => [
    ...isLocalVariable(name, interpreter)
        ? buildReplElement(obj, name.slice(replPackage.fullyQualifiedName.length + 1))
        : [],
    ...elementFromObject(obj, interpreter),
];
const buildNode = (id, label, type, module = '') => ({
    id,
    elementType: 'node',
    label,
    type,
    module,
});
const buildReference = (id, label, constant, sourceId, sourceObject, targetObject) => {
    var _a;
    return ({
        id,
        label,
        elementType: 'reference',
        sourceId,
        targetId: (_a = targetObject === null || targetObject === void 0 ? void 0 : targetObject.id) !== null && _a !== void 0 ? _a : '',
        constant,
        sourceModule: sourceObject === null || sourceObject === void 0 ? void 0 : sourceObject.module.fullyQualifiedName,
        targetModule: targetObject === null || targetObject === void 0 ? void 0 : targetObject.module.fullyQualifiedName,
    });
};
const buildReplElement = (object, name) => {
    const replId = `source_${constants_1.REPL}_${object.id}`;
    return [
        buildNode(replId, constants_1.REPL, DynamicNodeType.REPL),
        buildReference((0, uuid_1.v4)(), name, object.module.environment.replNode().isConstant(name), replId, undefined, object),
    ];
};
function elementFromObject(object, interpreter, alreadyVisited = []) {
    const { id, module } = object;
    if (alreadyVisited.includes(id))
        return [];
    return concatOverlappedReferences([
        buildNode(id, object.getLabel(interpreter), getType(object, module.fullyQualifiedName), module.fullyQualifiedName),
        ...getInstanceVariables(object, interpreter, alreadyVisited),
        ...getCollections(object, interpreter, alreadyVisited),
    ]);
}
const haveSameReference = (element1, element2) => {
    const firstElement = element1;
    const secondElement = element2;
    return element1.elementType === 'reference' && element2.elementType === 'reference' &&
        firstElement.sourceId === secondElement.sourceId && firstElement.targetId === secondElement.targetId;
};
const concatOverlappedReferences = (elementDefinitions) => {
    const cleanDefinitions = [];
    elementDefinitions.forEach(elem => {
        if (elem.elementType === 'reference') {
            const repeated = cleanDefinitions.find(def => haveSameReference(elem, def));
            if (repeated) {
                repeated.id = `${repeated.id}_${elem.id}`;
                repeated.label = `${repeated.label}, ${elem.label}`;
            }
            else {
                cleanDefinitions.push(elem);
            }
        }
        else {
            cleanDefinitions.push(elem);
        }
    });
    return cleanDefinitions;
};
const constFromRoot = (name, replPackage) => name.startsWith(replPackage.fullyQualifiedName);
const isLocalVariable = (name, interpreter) => { var _a; return (_a = interpreter.evaluation.environment.getNodeOrUndefinedByFQN(name)) === null || _a === void 0 ? void 0 : _a.is(model_1.Variable); };
const getType = (obj, moduleName) => {
    if (obj.innerValue === null)
        return DynamicNodeType.NULL;
    return moduleName.startsWith(constants_1.WOLLOK_BASE_PACKAGE) ? DynamicNodeType.LITERAL : DynamicNodeType.OBJECT;
};
const shouldIterateChildren = (object) => !object.shouldShortenRepresentation() && !object.shouldShowShortValue();
const getLocalKeys = (object) => {
    if (object.innerValue === null)
        return [];
    return shouldIterateChildren(object) ? [...object.locals.keys()].filter(key => key !== constants_1.KEYWORDS.SELF) : [];
};
const getCollections = (object, interpreter, alreadyVisited) => {
    const { id } = object;
    return (object.innerCollection || [])
        .flatMap((item, i) => {
        const result = [
            buildReference(`${id}_${item.id}`, object.module.fullyQualifiedName === constants_1.LIST_MODULE ? i.toString() : '', false, id, object, item),
            ...elementFromObject(item, interpreter, [...alreadyVisited, id]),
        ];
        alreadyVisited.push(item.id);
        return result;
    });
};
const getInstanceVariables = (object, interpreter, alreadyVisited) => {
    const { id } = object;
    return getLocalKeys(object).flatMap(name => [
        createReference(object, name),
        ...elementFromObject(object.get(name), interpreter, [...alreadyVisited, id]),
    ]);
};
const createReference = (object, label) => {
    const { id } = object;
    const runtimeValue = object.get(label);
    return buildReference(`${id}_${runtimeValue.id}`, label, object.isConstant(label), id, object, runtimeValue);
};
//# sourceMappingURL=dynamicDiagram.js.map