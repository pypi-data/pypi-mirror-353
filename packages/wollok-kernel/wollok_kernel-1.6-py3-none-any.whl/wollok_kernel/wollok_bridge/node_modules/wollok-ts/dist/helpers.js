"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isError = exports.firstNodeWithProblems = exports.projectToJSON = exports.allMethods = exports.allAvailableMethods = exports.existMethodFor = exports.literalValueToClass = exports.methodIsImplementedInSuperclass = exports.methodsCallingToSuper = exports.loopInAssignment = exports.methodExists = exports.returnsAValue = exports.supposedToReturnValue = exports.usesReservedWords = exports.usesField = exports.unusedVariable = exports.assignsVariable = exports.duplicatesLocalVariable = exports.isAlreadyUsedInImport = exports.entityIsAlreadyUsedInImport = exports.isGetter = exports.callsToSuper = exports.findMethod = exports.sendsMessageToAssert = exports.valueFor = exports.isBooleanOrUnknownType = exports.referencesSingleton = exports.isBooleanMessage = exports.isEqualMessage = exports.isImplemented = exports.hasDuplicatedVariable = exports.allScopedVariables = exports.getContainer = exports.getVariableContainer = exports.finishesFlow = exports.superclassMethod = exports.targetSupertypes = exports.hasNullValue = exports.hasBooleanValue = exports.isUninitialized = exports.initializesReference = exports.initializesInsideInitMethod = exports.getUninitializedAttributesIn = exports.getInheritedUninitializedAttributes = exports.getAllUninitializedAttributes = exports.getUninitializedAttributesForInstantiation = exports.getReferencedModule = exports.inheritsCustomDefinition = exports.allParents = exports.LIBRARY_PACKAGES = void 0;
exports.compileSetter = exports.compileGetter = exports.compilePropertyMethod = exports.possiblyReferenced = exports.getMethodContainer = exports.showParameter = exports.getExpressionFor = exports.assertNotVoid = exports.isVoid = exports.superMethodDefinition = exports.isApplyMethodForClosures = exports.getNodeDefinition = exports.targetName = exports.moduleFinderWithBackup = exports.allMethodDefinitions = exports.sendDefinitions = exports.methodByFQN = exports.isNamedSingleton = exports.allVariables = exports.mayExecute = exports.belongsTo = exports.isNotImportedIn = exports.projectPackages = exports.targettingAt = exports.workspacePackage = exports.fqnRelativeToPackage = exports.implicitImport = exports.parentImport = exports.parentModule = void 0;
const constants_1 = require("./constants");
const decorators_1 = require("./decorators");
const extensions_1 = require("./extensions");
const model_1 = require("./model");
exports.LIBRARY_PACKAGES = ['wollok.lang', 'wollok.lib', 'wollok.game', 'wollok.vm', 'wollok.mirror'];
const allParents = (module) => module.supertypes.map(supertype => supertype.reference.target).flatMap(supertype => { var _a; return (_a = supertype === null || supertype === void 0 ? void 0 : supertype.hierarchy) !== null && _a !== void 0 ? _a : []; });
exports.allParents = allParents;
const inheritsCustomDefinition = (module) => (0, extensions_1.notEmpty)((0, exports.allParents)(module).filter(element => element.fullyQualifiedName == constants_1.OBJECT_MODULE));
exports.inheritsCustomDefinition = inheritsCustomDefinition;
const getReferencedModule = (parent) => (0, extensions_1.match)(parent)((0, extensions_1.when)(model_1.ParameterizedType)(node => node.reference.target), (0, extensions_1.when)(model_1.New)(node => node.instantiated.target), (0, extensions_1.otherwise)(() => undefined));
exports.getReferencedModule = getReferencedModule;
const getUninitializedAttributesForInstantiation = (node) => {
    const target = node.instantiated.target;
    if (!target)
        return [];
    const initializers = node.args.map(_ => _.name);
    return (0, exports.getAllUninitializedAttributes)(target, initializers);
};
exports.getUninitializedAttributesForInstantiation = getUninitializedAttributesForInstantiation;
const getAllUninitializedAttributes = (node, initializers = []) => (0, exports.getUninitializedAttributesIn)(node, [...node.allFields], initializers);
exports.getAllUninitializedAttributes = getAllUninitializedAttributes;
const getInheritedUninitializedAttributes = (node, initializers = []) => (0, exports.getUninitializedAttributesIn)(node, [...node.allFields.filter(field => field.parent !== node)], initializers);
exports.getInheritedUninitializedAttributes = getInheritedUninitializedAttributes;
const getUninitializedAttributesIn = (node, fields, initializers = []) => fields.
    filter(field => {
    const value = node.defaultValueFor(field);
    return (0, exports.isUninitialized)(value) && !initializers.includes(field.name) && !(0, exports.initializesInsideInitMethod)(node, field);
})
    .map(field => field.name);
exports.getUninitializedAttributesIn = getUninitializedAttributesIn;
const initializesInsideInitMethod = (node, field) => {
    const allInitMethods = node.allMethods.filter(method => method.matchesSignature(constants_1.INITIALIZE_METHOD, 0));
    return allInitMethods.some(method => (0, exports.initializesReference)(method, field));
};
exports.initializesInsideInitMethod = initializesInsideInitMethod;
const initializesReference = (method, field) => method.sentences.some(sentence => sentence.is(model_1.Assignment) && sentence.variable.target === field);
exports.initializesReference = initializesReference;
const isUninitialized = (node) => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Expression)(node => node.isSynthetic && (0, exports.hasNullValue)(node)), (0, extensions_1.when)(model_1.Variable)(node => (0, exports.isUninitialized)(node.value)));
exports.isUninitialized = isUninitialized;
const hasBooleanValue = (node, value) => node.is(model_1.Literal) && node.value === value;
exports.hasBooleanValue = hasBooleanValue;
const hasNullValue = (node) => node.is(model_1.Literal) && node.isNull();
exports.hasNullValue = hasNullValue;
const targetSupertypes = (node) => node.supertypes.map(_ => _ === null || _ === void 0 ? void 0 : _.reference.target);
exports.targetSupertypes = targetSupertypes;
const superclassMethod = (node) => node.parent.lookupMethod(node.name, node.parameters.length, { lookupStartFQN: node.parent.fullyQualifiedName, allowAbstractMethods: true });
exports.superclassMethod = superclassMethod;
const finishesFlow = (sentence, node) => {
    var _a;
    const parent = node.parent;
    const lastLineOnMethod = parent.is(model_1.Body) ? (0, extensions_1.last)(parent.sentences) : undefined;
    const returnCondition = (_a = (sentence.is(model_1.Return) && lastLineOnMethod !== node && (lastLineOnMethod === null || lastLineOnMethod === void 0 ? void 0 : lastLineOnMethod.is(model_1.Return)) || (lastLineOnMethod === null || lastLineOnMethod === void 0 ? void 0 : lastLineOnMethod.is(model_1.Throw)))) !== null && _a !== void 0 ? _a : false;
    return sentence.is(model_1.Variable) || sentence.is(model_1.Throw) || sentence.is(model_1.Send) || sentence.is(model_1.Super) || sentence.is(model_1.Assignment) || sentence.is(model_1.If) || returnCondition;
};
exports.finishesFlow = finishesFlow;
const getVariableContainer = (node) => node.ancestors.find(parent => parent.is(model_1.Method) || parent.is(model_1.Test));
exports.getVariableContainer = getVariableContainer;
const getContainer = (node) => node.ancestors.find(parent => parent.is(model_1.Module) || parent.is(model_1.Program) || parent.is(model_1.Test));
exports.getContainer = getContainer;
const allScopedVariables = (node) => {
    var _a;
    const fields = (_a = node.parent.allFields) !== null && _a !== void 0 ? _a : [];
    const params = node.is(model_1.Method) ? node.parameters : [];
    const codeContainerVars = (0, exports.allVariables)(node);
    return [...fields, ...params, ...codeContainerVars];
};
exports.allScopedVariables = allScopedVariables;
const hasDuplicatedVariable = (node, variableName) => node.is(model_1.Module) && !!node.lookupField(variableName);
exports.hasDuplicatedVariable = hasDuplicatedVariable;
const isImplemented = (allMethods, method) => {
    return allMethods.some(someMethod => method.matchesSignature(someMethod.name, someMethod.parameters.length) && !someMethod.isAbstract());
};
exports.isImplemented = isImplemented;
const isEqualMessage = (node) => ['==', '!=', '===', '!==', 'equals'].includes(node.message) && node.args.length === 1;
exports.isEqualMessage = isEqualMessage;
const isBooleanMessage = (node) => ['&&', 'and', '||', 'or'].includes(node.message) && node.args.length === 1 || ['negate', 'not'].includes(node.message) && (0, extensions_1.isEmpty)(node.args);
exports.isBooleanMessage = isBooleanMessage;
const referencesSingleton = (node) => { var _a; return node.is(model_1.Reference) && ((_a = node.target) === null || _a === void 0 ? void 0 : _a.is(model_1.Singleton)); };
exports.referencesSingleton = referencesSingleton;
const isBooleanOrUnknownType = (node) => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Literal)(condition => condition.value === true || condition.value === false), (0, extensions_1.when)(model_1.Send)(_ => true), (0, extensions_1.when)(model_1.Super)(_ => true), (0, extensions_1.when)(model_1.Reference)(condition => { var _a; return !((_a = condition.target) === null || _a === void 0 ? void 0 : _a.is(model_1.Singleton)); }), (0, extensions_1.otherwise)(_ => false));
exports.isBooleanOrUnknownType = isBooleanOrUnknownType;
const valueFor = (node) => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Literal)(node => node.value), (0, extensions_1.when)(model_1.Return)(node => (0, exports.valueFor)(node.value)), (0, extensions_1.otherwise)(_ => undefined));
exports.valueFor = valueFor;
const sendsMessageToAssert = (node) => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Body)(node => node.children.some(child => (0, exports.sendsMessageToAssert)(child))), (0, extensions_1.when)(model_1.Send)(nodeSend => {
    const objectSendsMessageToAssert = (_) => {
        const method = (0, exports.findMethod)(nodeSend);
        return !!method && !!method.body && method.body !== constants_1.KEYWORDS.NATIVE && (0, exports.sendsMessageToAssert)(method.body);
    };
    return (0, extensions_1.match)(nodeSend.receiver)((0, extensions_1.when)(model_1.Reference)(receiver => receiver.name === 'assert'), (0, extensions_1.when)(model_1.Literal)(objectSendsMessageToAssert), (0, extensions_1.when)(model_1.Self)(objectSendsMessageToAssert), (0, extensions_1.when)(model_1.Expression)(_ => false));
}), (0, extensions_1.when)(model_1.Try)(node => (0, exports.sendsMessageToAssert)(node.body) ||
    node.catches.every(_catch => (0, exports.sendsMessageToAssert)(_catch.body)) || (0, exports.sendsMessageToAssert)(node.always)), (0, extensions_1.when)(model_1.If)(node => (0, exports.sendsMessageToAssert)(node.thenBody) && node.elseBody && (0, exports.sendsMessageToAssert)(node.elseBody)), (0, extensions_1.otherwise)(_ => false));
exports.sendsMessageToAssert = sendsMessageToAssert;
const findMethod = (messageSend) => {
    const findModule = (node) => node.receiver.ancestors.find(ancestor => ancestor.is(model_1.Module));
    const module = (0, extensions_1.match)(messageSend.receiver)((0, extensions_1.when)(model_1.Reference)(nodeRef => {
        const target = nodeRef.target;
        return (target === null || target === void 0 ? void 0 : target.is(model_1.Module)) ? target : undefined;
    }), (0, extensions_1.when)(model_1.Literal)(_ => findModule(messageSend)), (0, extensions_1.when)(model_1.Self)(_ => findModule(messageSend)), (0, extensions_1.when)(model_1.Expression)(_ => undefined));
    return module === null || module === void 0 ? void 0 : module.lookupMethod(messageSend.message, messageSend.args.length);
};
exports.findMethod = findMethod;
const callsToSuper = (node) => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Method)(node => node.sentences.some(sentence => (0, exports.callsToSuper)(sentence))), (0, extensions_1.when)(model_1.Return)(node => !!node.value && (0, exports.callsToSuper)(node.value)), (0, extensions_1.when)(model_1.Super)(() => true), (0, extensions_1.when)(model_1.Send)(node => (0, exports.callsToSuper)(node.receiver) || node.args.some(arg => (0, exports.callsToSuper)(arg))), (0, extensions_1.otherwise)(() => false));
exports.callsToSuper = callsToSuper;
const isGetter = (node) => node.parent.allFields.map(_ => _.name).includes(node.name) && (0, extensions_1.isEmpty)(node.parameters);
exports.isGetter = isGetter;
const entityIsAlreadyUsedInImport = (target, entityName) => target && (0, extensions_1.match)(target)((0, extensions_1.when)(model_1.Package)(node => node.members.some(member => member.name == entityName)), (0, extensions_1.when)(model_1.Entity)(node => node.name == entityName));
exports.entityIsAlreadyUsedInImport = entityIsAlreadyUsedInImport;
const isAlreadyUsedInImport = (target, node) => !!target && node && (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Package)(node => node.name == target.name), (0, extensions_1.when)(model_1.Entity)(node => (0, exports.entityIsAlreadyUsedInImport)(target, node.name)));
exports.isAlreadyUsedInImport = isAlreadyUsedInImport;
const duplicatesLocalVariable = (node) => {
    if (node.ancestors.some((0, extensions_1.is)(model_1.Program)) || node.isAtPackageLevel)
        return false;
    const container = (0, exports.getVariableContainer)(node);
    if (!container)
        return false;
    const duplicateReference = (0, extensions_1.count)((0, exports.allVariables)(container), reference => reference.name == node.name) > 1;
    return duplicateReference || (0, exports.hasDuplicatedVariable)(container.parent, node.name) || !container.is(model_1.Test) && container.parameters.some(_ => _.name == node.name);
};
exports.duplicatesLocalVariable = duplicatesLocalVariable;
const assignsVariable = (sentence, variable) => (0, extensions_1.match)(sentence)((0, extensions_1.when)(model_1.Assignment)(node => node.variable.target == variable), (0, extensions_1.when)(model_1.Body)(node => node.sentences.some(sentence => (0, exports.assignsVariable)(sentence, variable))), (0, extensions_1.when)(model_1.Describe)(node => node.members.some(member => (0, exports.assignsVariable)(member, variable))), (0, extensions_1.when)(model_1.If)(node => (0, exports.assignsVariable)(node.condition, variable) || (0, exports.assignsVariable)(node.thenBody, variable) || (0, exports.assignsVariable)(node.elseBody, variable)), (0, extensions_1.when)(model_1.Method)(node => node.sentences.some(sentence => (0, exports.assignsVariable)(sentence, variable))), (0, extensions_1.when)(model_1.Module)(node => node.methods.some(method => (0, exports.assignsVariable)(method, variable))), (0, extensions_1.when)(model_1.Program)(node => (0, exports.assignsVariable)(node.body, variable)), (0, extensions_1.when)(model_1.Return)(node => !!node.value && (0, exports.assignsVariable)(node.value, variable)), (0, extensions_1.when)(model_1.Send)(node => (0, exports.assignsVariable)(node.receiver, variable) || node.args.some(arg => (0, exports.assignsVariable)(arg, variable))), (0, extensions_1.when)(model_1.Singleton)(node => node.methods.some(method => (0, exports.assignsVariable)(method, variable))), (0, extensions_1.when)(model_1.Test)(node => (0, exports.assignsVariable)(node.body, variable)), (0, extensions_1.when)(model_1.Try)(node => (0, exports.assignsVariable)(node.body, variable) || node.catches.some(catchBlock => (0, exports.assignsVariable)(catchBlock.body, variable)) || (0, exports.assignsVariable)(node.always, variable)), (0, extensions_1.when)(model_1.Variable)(node => (0, exports.assignsVariable)(node.value, variable)), (0, extensions_1.otherwise)(_ => false));
exports.assignsVariable = assignsVariable;
const unusedVariable = (node) => {
    const parent = node.parent;
    return !node.isProperty && node.name != constants_1.CLOSURE_TO_STRING_METHOD
        && parent.allMembers.every((member) => !(0, exports.usesField)(member, node));
};
exports.unusedVariable = unusedVariable;
const usesField = (node, field) => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Singleton)(node => {
    if (!node.isClosure())
        return false;
    const applyMethod = node.methods.find(exports.isApplyMethodForClosures);
    return !!applyMethod && (0, exports.usesField)(applyMethod, field);
}), (0, extensions_1.when)(model_1.Variable)(node => (0, exports.usesField)(node.value, field)), (0, extensions_1.when)(model_1.Return)(node => !!node.value && (0, exports.usesField)(node.value, field)), (0, extensions_1.when)(model_1.Assignment)(node => node.variable.target === field || (0, exports.usesField)(node.value, field)), (0, extensions_1.when)(model_1.Reference)(node => node.target === field || !!node.target && node.target.is(model_1.Field) && (0, exports.usesField)(node.target, field)), (0, extensions_1.when)(model_1.Field)(node => node.value && (node.value.is(model_1.Literal) || node.value.is(model_1.Send)) && (0, exports.usesField)(node.value, field)), (0, extensions_1.when)(model_1.Literal)(node => Array.isArray(node.value) && node.value[1].some((expression) => (0, exports.usesField)(expression, field))), (0, extensions_1.when)(model_1.Send)(node => (0, exports.usesField)(node.receiver, field) || node.args.some(arg => (0, exports.usesField)(arg, field))), (0, extensions_1.when)(model_1.If)(node => (0, exports.usesField)(node.condition, field) || (0, exports.usesField)(node.thenBody, field) || node.elseBody && (0, exports.usesField)(node.elseBody, field)), (0, extensions_1.when)(model_1.New)(node => node.args.some(arg => (0, exports.usesField)(arg, field))), (0, extensions_1.when)(model_1.NamedArgument)(node => (0, exports.usesField)(node.value, field)), (0, extensions_1.when)(model_1.Throw)(node => (0, exports.usesField)(node.exception, field)), (0, extensions_1.when)(model_1.Try)(node => (0, exports.usesField)(node.body, field) || node.catches.some(catchBlock => (0, exports.usesField)(catchBlock.body, field)) || !!node.always && (0, exports.usesField)(node.always, field)), (0, extensions_1.when)(model_1.Expression)(() => false), (0, extensions_1.otherwise)((node) => (node.is(model_1.Body) || node.is(model_1.Method) || node.is(model_1.Test)) && node.sentences.some(sentence => (0, exports.usesField)(sentence, field))));
exports.usesField = usesField;
const usesReservedWords = (node) => {
    const parent = node.ancestors.find(ancestor => ancestor.is(model_1.Package));
    const wordsReserved = exports.LIBRARY_PACKAGES.flatMap(libPackage => node.environment.getNodeByFQN(libPackage).members.map(_ => _.name));
    wordsReserved.push('wollok');
    return !!parent && !parent.fullyQualifiedName.includes(constants_1.WOLLOK_BASE_PACKAGE) && wordsReserved.includes(node.name);
};
exports.usesReservedWords = usesReservedWords;
const supposedToReturnValue = (node) => (0, extensions_1.match)(node.parent)((0, extensions_1.when)(model_1.Assignment)(() => true), (0, extensions_1.when)(model_1.If)(() => true), (0, extensions_1.when)(model_1.Literal)(nodeLiteral => Array.isArray(nodeLiteral.value) && nodeLiteral.value[1].includes(node)), (0, extensions_1.when)(model_1.NamedArgument)(nodeArg => nodeArg.value == node), (0, extensions_1.when)(model_1.New)(nodeNew => nodeNew.args.some(namedArgument => namedArgument.value == node)), (0, extensions_1.when)(model_1.Return)(nodeReturn => {
    const parent = nodeReturn.ancestors.find((0, extensions_1.is)(model_1.Singleton));
    return !nodeReturn.isSynthetic || !(parent && parent.isClosure());
}), (0, extensions_1.when)(model_1.Send)(nodeSend => node.is(model_1.Expression) && nodeSend.args.includes(node) || nodeSend.receiver == node), (0, extensions_1.when)(model_1.Super)(nodeSuper => node.is(model_1.Expression) && nodeSuper.args.includes(node)), (0, extensions_1.when)(model_1.Variable)(() => true), (0, extensions_1.otherwise)(() => false));
exports.supposedToReturnValue = supposedToReturnValue;
const returnsAValue = (node) => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Body)(node => node.sentences.some(sentence => (0, exports.returnsAValue)(sentence))), (0, extensions_1.when)(model_1.If)(node => (0, exports.returnsAValue)(node.thenBody) || (0, exports.returnsAValue)(node.elseBody)), (0, extensions_1.when)(model_1.Method)(node => node.sentences.some(sentence => (0, exports.returnsAValue)(sentence))), (0, extensions_1.when)(model_1.Return)(() => true), (0, extensions_1.when)(model_1.Try)(node => (0, exports.returnsAValue)(node.body) || node.catches.some(sentence => (0, exports.returnsAValue)(sentence)) || (0, exports.returnsAValue)(node.always)), (0, extensions_1.otherwise)(() => false));
exports.returnsAValue = returnsAValue;
const methodExists = (node) => (0, extensions_1.match)(node.receiver)((0, extensions_1.when)(model_1.Self)(selfNode => {
    const allAncestors = selfNode.ancestors.filter(ancestor => ancestor.is(model_1.Module));
    return (0, extensions_1.isEmpty)(allAncestors) || allAncestors.some(ancestor => ancestor.lookupMethod(node.message, node.args.length, { allowAbstractMethods: true }));
}), (0, extensions_1.when)(model_1.Reference)(referenceNode => {
    const receiver = referenceNode.target;
    return !(receiver === null || receiver === void 0 ? void 0 : receiver.is(model_1.Module)) || (0, exports.isBooleanMessage)(node) || !!receiver.lookupMethod(node.message, node.args.length, { allowAbstractMethods: true });
}), (0, extensions_1.otherwise)(() => true));
exports.methodExists = methodExists;
const loopInAssignment = (node, variableName) => node.is(model_1.Send) && (0, exports.methodExists)(node) && node.receiver.is(model_1.Self) && node.message === variableName;
exports.loopInAssignment = loopInAssignment;
const methodsCallingToSuper = (node) => node.allMethods.filter(method => (0, exports.callsToSuper)(method));
exports.methodsCallingToSuper = methodsCallingToSuper;
const methodIsImplementedInSuperclass = (node) => (method) => node.lookupMethod(method.name, method.parameters.length, { lookupStartFQN: method.parent.fullyQualifiedName });
exports.methodIsImplementedInSuperclass = methodIsImplementedInSuperclass;
const literalValueToClass = (environment, literal) => {
    const clazz = (() => {
        switch (typeof literal) {
            case 'number':
                return constants_1.NUMBER_MODULE;
            case 'string':
                return constants_1.STRING_MODULE;
            case 'boolean':
                return constants_1.BOOLEAN_MODULE;
            case 'object':
                try {
                    const referenceClasses = literal;
                    return referenceClasses[0].name;
                }
                catch (e) {
                    return constants_1.OBJECT_MODULE;
                }
        }
    })();
    return environment.getNodeByFQN(clazz);
};
exports.literalValueToClass = literalValueToClass;
const existMethodFor = (send) => (0, exports.allAvailableMethods)(send.environment).some(method => method.matchesSignature(send.message, send.numArgs));
exports.existMethodFor = existMethodFor;
const allAvailableMethods = (environment) => environment.descendants.filter((0, extensions_1.is)(model_1.Method));
exports.allAvailableMethods = allAvailableMethods;
const allMethods = (environment, referenceClass) => { var _a; return ((_a = referenceClass.target) !== null && _a !== void 0 ? _a : environment.objectClass).allMethods; };
exports.allMethods = allMethods;
const projectToJSON = (wre) => JSON.stringify(wre, (key, value) => key.startsWith('_') ? undefined : value, 2);
exports.projectToJSON = projectToJSON;
const firstNodeWithProblems = (node) => {
    var _a;
    const { start, end } = (_a = node.problems[0].sourceMap) !== null && _a !== void 0 ? _a : { start: { offset: -1 }, end: { offset: -1 } };
    return node.children.find(child => { var _a, _b; return ((_a = child.sourceMap) === null || _a === void 0 ? void 0 : _a.covers(start.offset)) || ((_b = child.sourceMap) === null || _b === void 0 ? void 0 : _b.covers(end.offset)); });
};
exports.firstNodeWithProblems = firstNodeWithProblems;
const isError = (problem) => problem.level === 'error';
exports.isError = isError;
const parentModule = (node) => { var _a; return (_a = getParentModule(node)) !== null && _a !== void 0 ? _a : node.environment.objectClass; };
exports.parentModule = parentModule;
const parentImport = (node) => node.ancestors.find(ancestor => ancestor.is(model_1.Import));
exports.parentImport = parentImport;
const implicitImport = (node) => { var _a; return ['wollok/lang.wlk', 'wollok/lib.wlk'].includes((_a = node.sourceFileName) !== null && _a !== void 0 ? _a : ''); };
exports.implicitImport = implicitImport;
const fqnRelativeToPackage = (pckg, node) => node.fullyQualifiedName.replace(pckg.fullyQualifiedName, pckg.name);
exports.fqnRelativeToPackage = fqnRelativeToPackage;
const workspacePackage = (environment) => environment.members[1];
exports.workspacePackage = workspacePackage;
const targettingAt = (aNode) => (anotherNode) => anotherNode.is(model_1.Reference) && anotherNode.target === aNode;
exports.targettingAt = targettingAt;
const projectPackages = (environment) => environment.members.slice(1);
exports.projectPackages = projectPackages;
const isNotImportedIn = (importedPackage, importingPackage) => importedPackage !== importingPackage &&
    !importingPackage.imports.some(imported => imported.entity.target && (0, exports.belongsTo)(imported.entity.target, importedPackage)) &&
    !importedPackage.isGlobalPackage;
exports.isNotImportedIn = isNotImportedIn;
const belongsTo = (node, mainPackage) => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Package)((pkg) => pkg === mainPackage), (0, extensions_1.otherwise)((node) => node.parent === mainPackage));
exports.belongsTo = belongsTo;
const mayExecute = (method) => (node) => {
    var _a;
    return node.is(model_1.Send) &&
        node.message === method.name &&
        !(node.receiver.is(model_1.Reference) && ((_a = node.receiver.target) === null || _a === void 0 ? void 0 : _a.is(model_1.Singleton)) && node.receiver.target !== method.parent);
};
exports.mayExecute = mayExecute;
const allVariables = (node) => node.sentences.filter((0, extensions_1.is)(model_1.Variable));
exports.allVariables = allVariables;
const isNamedSingleton = (node) => node.is(model_1.Singleton) && !!node.name;
exports.isNamedSingleton = isNamedSingleton;
const methodByFQN = (environment, fqn) => {
    const parts = fqn.split('.');
    const methodWithArity = (0, extensions_1.last)(parts);
    const [methodName, originalMethodArity] = methodWithArity.split('/');
    const methodArity = originalMethodArity !== null && originalMethodArity !== void 0 ? originalMethodArity : 0;
    const entityFQN = fqn.replace(`.${methodWithArity}`, '');
    const entity = environment.getNodeByFQN(entityFQN);
    if (!entity.is(model_1.Module))
        return undefined;
    return entity.lookupMethod(methodName, Number.parseInt(methodArity, 10));
};
exports.methodByFQN = methodByFQN;
const sendDefinitions = (environment) => (send) => {
    const originalDefinitions = () => {
        try {
            return (0, extensions_1.match)(send.receiver)((0, extensions_1.when)(model_1.Reference)(node => {
                const target = node.target;
                return target && (0, extensions_1.is)(model_1.Singleton)(target) ?
                    (0, extensions_1.valueAsListOrEmpty)(target.lookupMethod(send.message, send.args.length))
                    : (0, exports.allMethodDefinitions)(environment, send);
            }), (0, extensions_1.when)(model_1.New)(node => { var _a; return (0, extensions_1.valueAsListOrEmpty)((_a = node.instantiated.target) === null || _a === void 0 ? void 0 : _a.lookupMethod(send.message, send.args.length)); }), (0, extensions_1.when)(model_1.Self)(_ => (0, exports.moduleFinderWithBackup)(environment, send)((module) => (0, extensions_1.valueAsListOrEmpty)(module.lookupMethod(send.message, send.args.length)))));
        }
        catch (error) {
            return (0, exports.allMethodDefinitions)(environment, send);
        }
    };
    const getDefinitionFromSyntheticMethod = (method) => {
        return method.parent.allFields.find((field) => field.name === method.name && field.isProperty);
    };
    return (0, extensions_1.excludeNullish)(originalDefinitions().map((method) => method.isSynthetic ? getDefinitionFromSyntheticMethod(method) : method));
};
exports.sendDefinitions = sendDefinitions;
const allMethodDefinitions = (environment, send) => {
    const arity = send.args.length;
    const name = send.message;
    return environment.descendants.filter(method => (0, extensions_1.is)(model_1.Method)(method) &&
        method.name === name &&
        method.parameters.length === arity);
};
exports.allMethodDefinitions = allMethodDefinitions;
const moduleFinderWithBackup = (environment, send) => (methodFinder) => {
    const module = send.ancestors.find((0, extensions_1.is)(model_1.Module));
    return module ? methodFinder(module) : (0, exports.allMethodDefinitions)(environment, send);
};
exports.moduleFinderWithBackup = moduleFinderWithBackup;
const targetName = (target, defaultName) => {
    var _a;
    return (target === null || target === void 0 ? void 0 : target.is(model_1.Module)) || (target === null || target === void 0 ? void 0 : target.is(model_1.Variable)) && ((_a = (0, decorators_1.getPotentiallyUninitializedLazy)(target, 'parent')) === null || _a === void 0 ? void 0 : _a.is(model_1.Package))
        ? target.fullyQualifiedName
        : defaultName;
};
exports.targetName = targetName;
const getNodeDefinition = (environment) => (node) => {
    try {
        return (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Reference)(node => (0, extensions_1.valueAsListOrEmpty)(node.target)), (0, extensions_1.when)(model_1.Send)((0, exports.sendDefinitions)(environment)), (0, extensions_1.when)(model_1.Super)(node => (0, extensions_1.valueAsListOrEmpty)((0, exports.superMethodDefinition)(node, getParentModule(node)))), (0, extensions_1.when)(model_1.Self)(node => (0, extensions_1.valueAsListOrEmpty)(getParentModule(node))));
    }
    catch (_a) {
        return [node];
    }
};
exports.getNodeDefinition = getNodeDefinition;
const isApplyMethodForClosures = (method) => method.name === constants_1.CLOSURE_EVALUATE_METHOD && method.parent.fullyQualifiedName.startsWith(`${constants_1.CLOSURE_MODULE}#`);
exports.isApplyMethodForClosures = isApplyMethodForClosures;
const superMethodDefinition = (superNode, methodModule) => {
    function isValidMethod(node) {
        return node.is(model_1.Method) && !(0, exports.isApplyMethodForClosures)(node);
    }
    const currentMethod = superNode.ancestors.find(isValidMethod);
    return methodModule.lookupMethod(currentMethod.name, superNode.args.length, { lookupStartFQN: currentMethod.parent.fullyQualifiedName });
};
exports.superMethodDefinition = superMethodDefinition;
const getParentModule = (node) => node.ancestors.find((0, extensions_1.is)(model_1.Module));
const isVoid = (obj) => { var _a; return ((_a = obj === null || obj === void 0 ? void 0 : obj.module) === null || _a === void 0 ? void 0 : _a.fullyQualifiedName) === constants_1.VOID_WKO; };
exports.isVoid = isVoid;
const assertNotVoid = (value, errorMessage) => {
    if ((0, exports.isVoid)(value)) {
        throw new RangeError(errorMessage);
    }
};
exports.assertNotVoid = assertNotVoid;
const getExpressionFor = (node) => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Send)(nodeSend => `message ${nodeSend.message}/${nodeSend.args.length}`), (0, extensions_1.when)(model_1.If)(_ => 'if expression'), (0, extensions_1.when)(model_1.Reference)(nodeRef => `reference '${nodeRef.name}'`), (0, extensions_1.when)(model_1.Literal)(nodeLiteral => `literal ${nodeLiteral.value}`), (0, extensions_1.when)(model_1.Self)(_ => 'self'), (0, extensions_1.when)(model_1.Expression)(_ => 'expression'));
exports.getExpressionFor = getExpressionFor;
const showParameter = (obj) => `"${obj.getShortRepresentation().trim() || obj.module.fullyQualifiedName}"`;
exports.showParameter = showParameter;
const getMethodContainer = (node) => (0, extensions_1.last)(node.ancestors.filter(parent => parent.is(model_1.Method) || parent.is(model_1.Program) || parent.is(model_1.Test)));
exports.getMethodContainer = getMethodContainer;
const possiblyReferenced = (reference, environment) => environment.scope.resolveAll(reference.name);
exports.possiblyReferenced = possiblyReferenced;
const compilePropertyMethod = (method) => {
    const message = method.name;
    return method.parameters.length == 0
        ? (0, exports.compileGetter)(message)
        : (0, exports.compileSetter)(message);
};
exports.compilePropertyMethod = compilePropertyMethod;
const compileGetter = (message) => function* (self) {
    return self.get(message);
};
exports.compileGetter = compileGetter;
const compileSetter = (message) => function* (self, value) {
    self.set(message, value);
};
exports.compileSetter = compileSetter;
//# sourceMappingURL=helpers.js.map