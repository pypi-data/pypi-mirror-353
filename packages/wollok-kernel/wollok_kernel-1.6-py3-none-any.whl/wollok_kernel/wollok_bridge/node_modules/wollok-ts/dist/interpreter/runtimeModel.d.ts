/// <reference types="node" />
import { List } from '../extensions';
import { Assignment, Body, Environment, Expression, Id, If, Literal, LiteralValue, Method, Module, Name, New, Node, Program, Reference, Return, Self, Send, Singleton, Super, Test, Throw, Try, Variable } from '../model';
import { Interpreter } from './interpreter';
export type Execution<T> = Generator<Node, T>;
export type ExecutionDefinition<T> = (this: Evaluation) => Execution<T>;
export type RuntimeValue = RuntimeObject | undefined;
export interface Natives {
    [name: string]: NativeFunction | Natives;
}
export type NativeFunction = (this: Evaluation, self: RuntimeObject, ...args: RuntimeObject[]) => Execution<RuntimeValue | void>;
export declare class WollokReturn extends Error {
    private static instance;
    static of(instance?: RuntimeObject): WollokReturn;
    private _instance?;
    get instance(): RuntimeObject | undefined;
    private constructor();
}
export declare class WollokException extends Error {
    readonly evaluation: Evaluation;
    readonly instance: RuntimeObject;
    get wollokStack(): string;
    get message(): string;
    constructor(evaluation: Evaluation, instance: RuntimeObject);
}
export declare abstract class Context {
    readonly id: Id;
    readonly parentContext?: Context;
    readonly locals: Map<Name, RuntimeValue | Execution<RuntimeObject>>;
    protected constructor(parentContext?: Context, locals?: Map<Name, RuntimeValue | Execution<RuntimeObject>>);
    get(local: Name): RuntimeValue;
    set(local: Name, value: RuntimeValue | Execution<RuntimeObject>, lookup?: boolean): void;
    contextHierarchy(): List<Context>;
    copy(contextCache: Map<Id, Context>): this;
    protected abstract baseCopy(contextCache: Map<Id, Context>): Context;
    abstract get description(): string;
}
export declare class Frame extends Context {
    readonly node: Node;
    currentNode: Node;
    constructor(node: Node, parentContext?: Context, locals?: Record<Name, RuntimeObject>);
    get description(): string;
    get sourceInfo(): string;
    protected baseCopy(contextCache: Map<Id, Context>): Frame;
    toString(): string;
    isCustom(): boolean;
}
export type InnerValue = null | boolean | string | number | RuntimeObject[] | Error;
export type BasicRuntimeObject<T extends InnerValue | undefined> = RuntimeObject & {
    innerValue: T;
};
export declare class RuntimeObject extends Context {
    readonly module: Module;
    readonly innerValue?: InnerValue;
    constructor(module: Module, parentContext: Context, innerValue?: InnerValue);
    get innerNumber(): this['innerValue'] & (number | undefined);
    get innerString(): this['innerValue'] & (string | undefined);
    get innerBoolean(): this['innerValue'] & (boolean | undefined);
    get innerCollection(): this['innerValue'] & (RuntimeObject[] | undefined);
    get description(): string;
    protected baseCopy(contextCache: Map<Id, Context>): RuntimeObject;
    protected assertIs(moduleFQN: Name, innerValue?: InnerValue): void;
    isConstant(localName: string): boolean;
    getLabel(interpreter: Interpreter): string;
    getShortLabel(): string;
    getShortRepresentation(): string;
    shouldShortenRepresentation(): boolean;
    shouldShowShortValue(): boolean;
    showShortValue(interpreter: Interpreter): string;
}
export declare function assertIsNumber(obj: RuntimeObject, message: string, variableName: string, validateValue?: boolean): asserts obj is BasicRuntimeObject<number>;
export declare function assertIsBoolean(obj: RuntimeObject, message: string, variableName: string): asserts obj is BasicRuntimeObject<boolean>;
export declare function assertIsString(obj: RuntimeObject | undefined, message: string, variableName: string, validateValue?: boolean): asserts obj is BasicRuntimeObject<string>;
export declare function assertIsCollection(obj: RuntimeObject): asserts obj is BasicRuntimeObject<RuntimeObject[]>;
export declare function assertIsException(obj: RuntimeObject): asserts obj is BasicRuntimeObject<Error | undefined>;
export declare function assertIsNotNull(obj: RuntimeObject, message: string, variableName: string): asserts obj is BasicRuntimeObject<Exclude<InnerValue, null>>;
export declare class Evaluation {
    readonly natives: Map<Method, NativeFunction>;
    protected readonly numberCache: Map<number, WeakRef<RuntimeObject>>;
    protected readonly stringCache: Map<string, WeakRef<RuntimeObject>>;
    console: Console;
    frameStack: Frame[];
    get rootFrame(): Frame;
    get currentFrame(): Frame;
    get currentNode(): Node;
    get environment(): Environment;
    static build(environment: Environment, natives: Natives): Evaluation;
    protected constructor(natives: Map<Method, NativeFunction>, frameStack: Frame[], numberCache: Map<number, WeakRef<RuntimeObject>>, stringCache: Map<string, WeakRef<RuntimeObject>>);
    copy(contextCache?: Map<Id, Context>): Evaluation;
    allInstances(): Set<RuntimeObject>;
    object(fullyQualifiedName: Name): RuntimeObject;
    exec(node: Expression, frame?: Frame): Execution<RuntimeObject>;
    exec(node: Node, frame?: Frame): Execution<undefined>;
    protected execTest(node: Test): Execution<void>;
    protected execProgram(node: Program): Execution<void>;
    protected execMethod(node: Method): Execution<RuntimeValue>;
    protected execBody(node: Body): Execution<RuntimeValue>;
    protected execVariable(node: Variable): Execution<void>;
    protected execAssignment(node: Assignment): Execution<void>;
    protected execReturn(node: Return): Execution<RuntimeValue>;
    protected execReference(node: Reference<Node>): Execution<RuntimeValue>;
    protected execSelf(node: Self): Execution<RuntimeValue>;
    protected execLiteral(node: Literal<LiteralValue>): Execution<RuntimeValue>;
    protected execNew(node: New): Execution<RuntimeValue>;
    protected execSend(node: Send): Execution<RuntimeValue>;
    protected execSuper(node: Super): Execution<RuntimeValue>;
    protected execIf(node: If): Execution<RuntimeValue>;
    protected execTry(node: Try): Execution<RuntimeValue>;
    protected execThrow(node: Throw): Execution<RuntimeValue>;
    protected execSingleton(node: Singleton): Execution<RuntimeValue>;
    send(message: Name, receiver: RuntimeObject, ...args: RuntimeObject[]): Execution<RuntimeValue>;
    invoke(method: Method, receiver: RuntimeObject, ...args: RuntimeObject[]): Execution<RuntimeValue>;
    protected localsFor(method: Method, args: RuntimeObject[]): Generator<Node, Record<string, RuntimeObject>>;
    reify(value: boolean | number | string | null): Execution<RuntimeObject>;
    reifyVoid(): Execution<RuntimeObject>;
    list(...value: RuntimeObject[]): Execution<RuntimeObject>;
    set(...value: RuntimeObject[]): Execution<RuntimeObject>;
    error(moduleOrFQN: Module | Name, locals?: Record<Name, RuntimeObject>, error?: Error): Execution<RuntimeObject>;
    instantiate(moduleOrFQN: Module | Name, locals?: Record<Name, RuntimeValue | Execution<RuntimeObject>>): Execution<RuntimeObject>;
    protected init(instance: RuntimeObject, locals?: Record<Name, RuntimeValue | Execution<RuntimeObject>>): Execution<void>;
}
