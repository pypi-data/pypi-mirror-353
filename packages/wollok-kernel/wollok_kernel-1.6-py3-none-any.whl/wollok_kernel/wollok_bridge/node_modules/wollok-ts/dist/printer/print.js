"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const prettier_printer_1 = require("prettier-printer");
const constants_1 = require("../constants");
const extensions_1 = require("../extensions");
const model_1 = require("../model");
const parser_1 = require("../parser");
const exceptions_1 = require("./exceptions");
const utils_1 = require("./utils");
const { entries } = Object;
exports.default = print;
function print(node, { maxWidth, useSpaces, abbreviateAssignments } = { maxWidth: 80, useSpaces: true, abbreviateAssignments: true }) {
    const indentationCharacters = useSpaces ? '  ' : '\t';
    return (0, prettier_printer_1.render)(maxWidth, format({
        indent: (0, prettier_printer_1.indent)(indentationCharacters),
        nest: (0, prettier_printer_1.nest)(indentationCharacters),
        hang: (0, prettier_printer_1.hang)(indentationCharacters),
        abbreviateAssignments,
    })(node));
}
const criticalProblems = [parser_1.MALFORMED_MEMBER, parser_1.MALFORMED_ENTITY, parser_1.MALFORMED_SENTENCE];
const format = context => node => {
    var _a;
    if (node.hasProblems &&
        ((_a = node.problems) === null || _a === void 0 ? void 0 : _a.some(problem => criticalProblems.includes(problem.code)))) {
        throw new exceptions_1.PrintingMalformedNodeError(node);
    }
    const metadata = splitMetadata(context, node.metadata);
    const formattedNode = (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Package)(formatPackage(context)), (0, extensions_1.when)(model_1.Program)(formatProgram(context)), (0, extensions_1.when)(model_1.Assignment)(formatAssignment(context)), (0, extensions_1.when)(model_1.Singleton)(formatSingleton(context)), (0, extensions_1.when)(model_1.Class)(formatClass(context)), (0, extensions_1.when)(model_1.Mixin)(formatMixin(context)), (0, extensions_1.when)(model_1.Method)(formatMethod(context)), (0, extensions_1.when)(model_1.Field)(formatField(context)), (0, extensions_1.when)(model_1.Variable)(formatVariable(context)), (0, extensions_1.when)(model_1.Describe)(formatDescribe(context)), (0, extensions_1.when)(model_1.Test)(formatTest(context)), (0, extensions_1.when)(model_1.Parameter)(formatParameter), (0, extensions_1.when)(model_1.Literal)(formatLiteral(context)), (0, extensions_1.when)(model_1.Body)(formatBody(context)), (0, extensions_1.when)(model_1.Send)(formatSend(context)), (0, extensions_1.when)(model_1.If)(formatIf(context)), (0, extensions_1.when)(model_1.New)(formatNew(context)), (0, extensions_1.when)(model_1.ParameterizedType)(formatParameterizedType(context)), (0, extensions_1.when)(model_1.NamedArgument)(formatNamedArgument(context)), (0, extensions_1.when)(model_1.Return)(formatReturn(context)), (0, extensions_1.when)(model_1.Try)(formatTry(context)), (0, extensions_1.when)(model_1.Catch)(formatCatch(context)), (0, extensions_1.when)(model_1.Throw)(formatThrow(context)), (0, extensions_1.when)(model_1.Reference)(formatReference), (0, extensions_1.when)(model_1.Self)(formatSelf), (0, extensions_1.when)(model_1.Import)(formatImport), (0, extensions_1.when)(model_1.Super)(formatSuper(context)));
    return (0, prettier_printer_1.enclose)(metadata, formattedNode);
};
const formatPackage = context => node => {
    const contents = [(0, extensions_1.notEmpty)(node.imports) ? [(0, prettier_printer_1.intersperse)(prettier_printer_1.lineBreak, node.imports.map(format(context))), prettier_printer_1.lineBreaks] : [], (0, prettier_printer_1.intersperse)(prettier_printer_1.lineBreaks, node.members.map(format(context)))];
    return node.isSynthetic ?
        contents :
        (0, prettier_printer_1.intersperse)(utils_1.WS, [constants_1.KEYWORDS.PACKAGE, node.name, (0, utils_1.body)(context.nest)(contents)]);
};
const formatImport = node => {
    const wildcard = node.isGeneric ? '.*' : '';
    return [constants_1.KEYWORDS.IMPORT, utils_1.WS, node.entity.name, wildcard];
};
const formatProgram = context => node => (0, prettier_printer_1.intersperse)(utils_1.WS, [constants_1.KEYWORDS.PROGRAM, node.name, format(context)(node.body)]);
const formatMethod = context => node => {
    const formatWithContext = format(context);
    const signature = [
        node.isOverride ? [constants_1.KEYWORDS.OVERRIDE, utils_1.WS] : [],
        constants_1.KEYWORDS.METHOD,
        utils_1.WS,
        node.name,
        enclosedListOfNodes(context)(prettier_printer_1.parens, node.parameters),
    ];
    if (node.isNative()) {
        return [signature, utils_1.WS, constants_1.KEYWORDS.NATIVE];
    }
    else if (node.isAbstract()) {
        return signature;
    }
    else if (node.isConcrete()) {
        if (node.body.sentences.length === 1 &&
            node.body.sentences[0].is(model_1.Return) &&
            node.body.sentences[0].value) {
            return (0, prettier_printer_1.intersperse)(utils_1.WS, [signature, '=', formatWithContext(node.body.sentences[0].value)]);
        }
        else {
            return [signature, utils_1.WS, formatWithContext(node.body)];
        }
    }
    else {
        throw Error('Malformed method');
    }
};
const formatBody = context => node => (0, utils_1.body)(context.nest)([
    formatSentences(context)(node.sentences),
    ...node.metadata
        .filter(metadata => isComment(metadata) && metadata.args['position'] === 'inner')
        .map(comment => [prettier_printer_1.lineBreak, comment.args['text']]),
]);
const formatReturn = context => node => node.value ?
    [constants_1.KEYWORDS.RETURN, utils_1.WS, format(context)(node.value)]
    : constants_1.KEYWORDS.RETURN;
const formatReference = (node) => node.name;
const formatField = context => node => {
    let modifiers = [node.isConstant ? constants_1.KEYWORDS.CONST : constants_1.KEYWORDS.VAR];
    if (node.isProperty) {
        modifiers = (0, prettier_printer_1.append)([utils_1.WS, constants_1.KEYWORDS.PROPERTY], modifiers);
    }
    return [
        modifiers,
        utils_1.WS,
        formatAssign(context, true)(node.name, node.value),
    ];
};
const formatVariable = context => node => {
    return [
        node.isConstant ? constants_1.KEYWORDS.CONST : constants_1.KEYWORDS.VAR,
        utils_1.WS,
        formatAssign(context)(node.name, node.value),
    ];
};
const formatParameter = node => node.name;
const formatTest = context => node => {
    return (0, prettier_printer_1.intersperse)(utils_1.WS, [
        ...node.isOnly ? [constants_1.KEYWORDS.ONLY] : [],
        constants_1.KEYWORDS.TEST,
        node.name,
        (0, utils_1.body)(context.nest)(formatSentences(context)(node.body.sentences)),
    ]);
};
const formatDescribe = context => node => (0, prettier_printer_1.intersperse)(utils_1.WS, [constants_1.KEYWORDS.SUITE, node.name, formatModuleMembers(context)(node.members)]);
const formatAssignment = context => node => canBeAbbreviated(node) && context.abbreviateAssignments ?
    formatAssign(context)(node.variable.name, node.value.args[0], assignmentOperationByMessage[node.value.message]) :
    formatAssign(context)(node.variable.name, node.value);
const formatSuper = context => node => [constants_1.KEYWORDS.SUPER, formatArguments(context)(node.args)];
const formatIf = context => node => {
    const condition = [constants_1.KEYWORDS.IF, utils_1.WS, (0, prettier_printer_1.enclose)(prettier_printer_1.parens, format(context)(node.condition))];
    if (canInlineBody(node.thenBody) && (node.elseBody.isSynthetic || canInlineBody(node.elseBody))) {
        return formatInlineIf(condition)(context)(node);
    }
    const thenBody = (0, utils_1.body)(context.nest)(formatSentences(context)(node.thenBody.sentences));
    const elseBody = !((0, extensions_1.isEmpty)(node.elseBody.sentences) || node.elseBody.isSynthetic) ? (0, utils_1.body)(context.nest)(formatSentences(context)(node.elseBody.sentences)) : undefined;
    return [
        condition,
        utils_1.WS,
        thenBody,
        elseBody ? [utils_1.WS, constants_1.KEYWORDS.ELSE, utils_1.WS, elseBody] : [],
    ];
};
const formatInlineIf = condition => context => node => (0, prettier_printer_1.choice)([
    condition,
    utils_1.WS,
    format(context)(node.thenBody.sentences[0]),
    (0, extensions_1.notEmpty)(node.elseBody.sentences) ? [utils_1.WS, constants_1.KEYWORDS.ELSE, utils_1.WS, format(context)(node.elseBody.sentences[0])] : [],
], [
    (0, prettier_printer_1.align)([
        context.hang([
            condition,
            prettier_printer_1.softLine,
            format(context)(node.thenBody.sentences[0]),
        ]),
        (0, extensions_1.notEmpty)(node.elseBody.sentences) ? [
            prettier_printer_1.lineBreak,
            context.hang([constants_1.KEYWORDS.ELSE, prettier_printer_1.softLine, format(context)(node.elseBody.sentences[0])]),
        ] : [],
    ]),
]);
function canInlineBody(aBody) {
    return aBody.sentences.length === 1 && [model_1.Send, model_1.Literal, model_1.Reference].some(kind => aBody.sentences[0].is(kind));
}
const formatNew = context => node => {
    const args = enclosedListOfNodes(context)(prettier_printer_1.parens, node.args);
    return [
        constants_1.KEYWORDS.NEW,
        utils_1.WS,
        node.instantiated.name,
        args,
    ];
};
const formatThrow = context => node => [
    constants_1.KEYWORDS.THROW,
    utils_1.WS,
    format(context)(node.exception),
];
const formatTry = context => node => {
    const formatter = format(context);
    const always = (0, extensions_1.notEmpty)(node.always.sentences) ?
        (0, prettier_printer_1.prepend)(utils_1.WS, (0, prettier_printer_1.intersperse)(utils_1.WS, [constants_1.KEYWORDS.THEN, constants_1.KEYWORDS.ALWAYS, formatter(node.always)]))
        : [];
    return [
        constants_1.KEYWORDS.TRY,
        utils_1.WS,
        formatter(node.body),
        node.catches ? [utils_1.WS, (0, prettier_printer_1.intersperse)(utils_1.WS, node.catches.map(formatter))] : [],
        always,
    ];
};
const formatCatch = context => node => {
    const type = (0, prettier_printer_1.prepend)(utils_1.WS, (0, prettier_printer_1.intersperse)(utils_1.WS, [node.parameter.name, ':', format(context)(node.parameterType)]));
    return [
        constants_1.KEYWORDS.CATCH,
        type,
        utils_1.WS,
        format(context)(node.body),
    ];
};
const formatLiteral = context => node => {
    if (node.isBoolean()) {
        return `${node.value}`;
    }
    else if (node.isNumeric()) {
        return node.value.toString();
    }
    else if (node.isNull()) {
        return constants_1.KEYWORDS.NULL;
    }
    else if (node.isString()) {
        return (0, utils_1.stringify)(`${node.value}`);
    }
    else if (node.isCollection()) {
        const [{ name: moduleFQN }, elements] = node.value;
        switch (moduleFQN) {
            case constants_1.LIST_MODULE:
                return formatCollection(context)(elements, utils_1.listEnclosers);
            case constants_1.SET_MODULE:
                return formatCollection(context)(elements, utils_1.setEnclosers);
            default:
                throw new Error('Unknown collection type');
        }
    }
    else {
        throw new Error('Unknown literal type');
    }
};
const formatSelf = (_) => constants_1.KEYWORDS.SELF;
const formatClass = context => node => {
    let header = [
        constants_1.KEYWORDS.CLASS,
        node.name,
    ];
    if (inherits(node)) {
        header = [...header, formatInheritance(context)(node)];
    }
    return (0, prettier_printer_1.intersperse)(utils_1.WS, [...header, formatModuleMembers(context)(node.members)]);
};
const formatMixin = context => node => {
    const declaration = [
        constants_1.KEYWORDS.MIXIN,
        utils_1.WS,
        node.name,
        (0, extensions_1.notEmpty)(node.supertypes) ? [utils_1.WS, constants_1.KEYWORDS.INHERITS, utils_1.WS, (0, prettier_printer_1.intersperse)([utils_1.WS, constants_1.KEYWORDS.MIXED_AND, utils_1.WS], node.supertypes.map(format(context)))] : [],
    ];
    return [declaration, utils_1.WS, formatModuleMembers(context)(node.members)];
};
const formatParameterizedType = context => node => [
    node.reference.name,
    (0, extensions_1.notEmpty)(node.args) ?
        [utils_1.WS, enclosedListOfNodes(context)(prettier_printer_1.parens, node.args)] :
        [],
];
const formatNamedArgument = context => node => (0, prettier_printer_1.intersperse)(utils_1.WS, [node.name, '=', format(context)(node.value)]);
const formatSingleton = context => (node) => {
    const formatter = node.isClosure() ? formatClosure : formatWKO;
    return formatter(context)(node);
};
const formatClosure = context => node => {
    const applyMethod = node.members[0];
    const hasParameters = (0, extensions_1.notEmpty)(applyMethod.parameters);
    const parameters = hasParameters ?
        [(0, utils_1.listed)(applyMethod.parameters.map(format(context))), utils_1.WS, '=>']
        : [];
    const sentences = applyMethod.body.sentences;
    if (sentences.length === 1) {
        const firstSentence = sentences[0];
        const sentence = format(context)(firstSentence.is(model_1.Return) && firstSentence.value ? firstSentence.value : firstSentence);
        return (0, prettier_printer_1.enclose)([['{', utils_1.WS], [utils_1.WS, '}']], context.nest([hasParameters ? [parameters, prettier_printer_1.softLine] : [], sentence]));
    }
    else {
        return (0, prettier_printer_1.enclose)([['{', utils_1.WS], '}'], [parameters, prettier_printer_1.lineBreak, context.indent(formatSentences(context)(sentences)), prettier_printer_1.lineBreak]);
    }
};
const formatWKO = context => node => {
    let formatted = [constants_1.KEYWORDS.WKO];
    if (node.name) {
        formatted = [...formatted, node.name];
    }
    if (inherits(node)) {
        formatted = [...formatted, formatInheritance(context)(node)];
    }
    if (node.members.length === 0) {
        const formattedComments = formatInnerComments(context)(node.metadata);
        return (0, prettier_printer_1.intersperse)(utils_1.WS, [...formatted, formattedComments]);
    }
    const members = formatModuleMembers(context)(node.members);
    return (0, prettier_printer_1.intersperse)(utils_1.WS, [...formatted, members]);
};
const inherits = (node) => (0, extensions_1.notEmpty)(node.supertypes);
const formatInheritance = (context) => node => {
    return (0, prettier_printer_1.intersperse)(utils_1.WS, [
        constants_1.KEYWORDS.INHERITS,
        (0, utils_1.listed)(node.supertypes.map(format(context))),
    ]);
};
const formatSend = context => node => {
    const formatter = node.isInfixOperator() ? formatInfixSend : node.isPrefixOperator() ? formatPrefixSend : formatDotSend;
    return formatter(context)(node);
};
const formatDotSend = context => node => [
    addParenthesisIfNeeded(context, node.receiver),
    '.',
    node.message,
    formatArguments(context)(node.args),
];
const formatInfixSend = context => node => {
    return (0, prettier_printer_1.intersperse)(utils_1.WS, [
        addParenthesisIfNeeded(context, node.receiver),
        node.message,
        addParenthesisIfNeeded(context, node.args[0]),
    ]);
};
const formatPrefixSend = context => node => {
    return [[node.originalOperator, useSpacingForPrefixOperators[node.originalOperator] ? utils_1.WS : []], addParenthesisIfNeeded(context, node.receiver)];
};
function addParenthesisIfNeeded(context, expression) {
    const formatted = format(context)(expression);
    return expression.is(model_1.Send) && (expression.isInfixOperator() || expression.isPrefixOperator()) ?
        (0, prettier_printer_1.enclose)(prettier_printer_1.parens, formatted) :
        formatted;
}
const formatSentences = (context) => (sentences, simplifyLastReturn = false) => sentences.reduce((formatted, sentence, i, sentences) => {
    const shouldShortenReturn = i === sentences.length - 1 && sentence.is(model_1.Return) && sentence.value && simplifyLastReturn;
    const previousSentence = sentences[i - 1];
    return [formatted, formatSentenceInBody(context)(!shouldShortenReturn ? sentence : sentence.value, previousSentence)];
}, []);
const formatArguments = (context) => (args) => enclosedListOfNodes(context)(prettier_printer_1.parens, args);
const formatSentenceInBody = (context) => (sentence, previousSentence) => {
    const distanceFromLastSentence = sentence.sourceMap && (!previousSentence || previousSentence.sourceMap) ?
        previousSentence ?
            Math.max(sentence.sourceMap.start.line - previousSentence.sourceMap.end.line, 1)
            : 0
        : 1;
    return [Array(distanceFromLastSentence).fill(prettier_printer_1.lineBreak), format(context)(sentence)];
};
const formatAssign = (context, ignoreNull = false) => (name, value, assignmentOperator = '=') => [
    name,
    ignoreNull && value.is(model_1.Literal) && value.isNull() && value.isSynthetic ?
        [] :
        [
            utils_1.WS,
            assignmentOperator,
            [prettier_printer_1.softBreak, (0, prettier_printer_1.choice)(utils_1.WS, context.indent([]))],
            format(context)(value),
        ],
];
const formatCollection = (context) => (values, enclosers) => {
    return enclosedListOfNodes(context)(enclosers, values);
};
const formatModuleMembers = (context) => (members) => {
    const formatter = format(context);
    const concreteMembers = members.filter(member => !member.isSynthetic);
    const fields = concreteMembers.filter(member => member.is(model_1.Field)).map(formatter);
    const others = concreteMembers.filter(member => !member.is(model_1.Field)).map(formatter);
    return (0, utils_1.body)(context.nest)([fields.length > 0 ? [(0, prettier_printer_1.intersperse)(prettier_printer_1.lineBreak, fields), others.length > 0 ? prettier_printer_1.lineBreaks : []] : [], (0, prettier_printer_1.intersperse)(prettier_printer_1.lineBreaks, others)]);
};
const formatComment = (comment) => {
    const comments = splitMultilineComment(comment).map(comm => comm.args['text']);
    return (0, prettier_printer_1.intersperse)(prettier_printer_1.lineBreak, comments);
};
const formatInnerComments = (context) => (comments) => {
    return (0, utils_1.body)(context.nest)((0, prettier_printer_1.intersperse)(prettier_printer_1.lineBreak, comments.filter(isInnerComment).map(formatComment)));
};
const canBeAbbreviated = (node) => node.value.is(model_1.Send) && node.value.receiver.is(model_1.Reference) && node.value.receiver.name === node.variable.name && node.value.message in assignmentOperationByMessage;
const assignmentOperationByMessage = { '||': '||=', '/': '/=', '-': '-=', '+': '+=', '*': '*=', '&&': '&&=', '%': '%=' };
const useSpacingForPrefixOperators = {
    '!': false,
    '-': false,
    '+': false,
    'not': true,
};
const splitMetadata = (context, metadata) => {
    const withSplittedMultilineComments = metadata.flatMap(annotation => splitMultilineComment(annotation));
    const prevMetadata = withSplittedMultilineComments.filter(metadata => !isComment(metadata) || metadata.args['position'] === 'start');
    const afterMetadata = withSplittedMultilineComments.filter(metadata => metadata.args['position'] === 'end');
    const metadataBefore = (0, utils_1.defaultToEmpty)((0, extensions_1.notEmpty)(prevMetadata), [(0, prettier_printer_1.intersperse)(prettier_printer_1.lineBreak, prevMetadata.map(formatAnnotation(context))), prettier_printer_1.lineBreak]);
    const metadataAfter = (0, utils_1.defaultToEmpty)((0, extensions_1.notEmpty)(afterMetadata), [prettier_printer_1.softLine, (0, prettier_printer_1.intersperse)(prettier_printer_1.lineBreak, afterMetadata.map(formatAnnotation(context)))]);
    return [metadataBefore, metadataAfter];
};
const splitMultilineComment = (annotation) => annotation.name === 'comment' && annotation.args['text'].includes('\n') ?
    annotation.args['text'].split('\n').map(commentSection => new model_1.Annotation('comment', { text: commentSection.trimStart(), position: annotation.args['position'] })) :
    [annotation];
const formatAnnotation = (context) => (annotation) => {
    if (annotation.name === 'comment')
        return annotation.args['text'];
    return ['@', annotation.name, (0, utils_1.enclosedList)(context.nest)(prettier_printer_1.parens, [...entries(annotation.args)].map(([name, value]) => (0, prettier_printer_1.intersperse)(utils_1.WS, [name, '=', format(context)(new model_1.Literal({ value }))])))];
};
function isComment(annotation) {
    return annotation.name === 'comment';
}
function isInnerComment(annotation) {
    return isComment(annotation) && annotation.args['position'] === 'inner';
}
const enclosedListOfNodes = (context) => (enclosers, nodes) => (0, utils_1.enclosedList)(context.nest)(enclosers, nodes.map(format(context)), nodes.some(aNode => aNode.metadata.some(entry => entry.name === 'comment')));
//# sourceMappingURL=print.js.map