import { List } from './extensions';
import { NativeFunction, RuntimeObject, RuntimeValue } from './interpreter/runtimeModel';
import { Class, CodeContainer, Entity, Environment, Expression, Field, Import, LiteralValue, Method, Module, Name, New, Node, Package, Parameter, ParameterizedType, Problem, Program, Reference, Referenciable, Send, Sentence, Singleton, Super, Test, Variable } from './model';
export declare const LIBRARY_PACKAGES: string[];
export declare const allParents: (module: Module) => Module[];
export declare const inheritsCustomDefinition: (module: Module) => boolean;
export declare const getReferencedModule: (parent: Node) => Module | undefined;
export declare const getUninitializedAttributesForInstantiation: (node: New) => string[];
export declare const getAllUninitializedAttributes: (node: Module, initializers?: string[]) => string[];
export declare const getInheritedUninitializedAttributes: (node: Module, initializers?: string[]) => string[];
export declare const getUninitializedAttributesIn: (node: Module, fields: Field[], initializers?: string[]) => string[];
export declare const initializesInsideInitMethod: (node: Module, field: Field) => boolean;
export declare const initializesReference: (method: Method, field: Field) => boolean;
export declare const isUninitialized: (node: Expression | Variable) => boolean;
export declare const hasBooleanValue: (node: Expression, value: boolean) => boolean;
export declare const hasNullValue: (node: Expression) => boolean;
export declare const targetSupertypes: (node: Class | Singleton) => (({
    "__#2@#isModule": any;
    readonly name?: string | undefined;
    readonly supertypes: List<ParameterizedType>;
    readonly members: List<Field | Method | Variable | Test>;
    readonly superclass: Class | undefined;
    readonly hierarchy: List<any>;
    readonly mixins: List<import("./model").Mixin>;
    readonly methods: List<Method>;
    readonly fields: List<Field>;
    readonly allMembers: List<Field | Method | Variable | Test>;
    readonly allFields: List<Field>;
    readonly allMethods: List<Method>;
    lookupField(name: string): Field | undefined;
    lookupMethod(name: string, arity: number, options?: {
        lookupStartFQN?: string | undefined;
        allowAbstractMethods?: boolean | undefined;
    } | undefined): Method | undefined;
    readonly isAbstract: boolean;
    readonly abstractMethods: List<Method>;
    defaultValueFor(field: Field): {
        "__#4@#isExpression": any;
        "__#3@#isSentence": any;
        readonly kind: string;
        readonly id: string;
        readonly scope: import("./model").Scope;
        readonly sourceMap?: import("./model").SourceMap | undefined;
        readonly problems?: List<import("./model").BaseProblem> | undefined;
        readonly metadata: List<import("./model").Annotation>;
        environment: Environment;
        parent: Node;
        readonly categories: Function[];
        readonly sourceFileName: string | undefined;
        readonly sourceInfo: string;
        readonly label: string;
        readonly isSynthetic: boolean;
        readonly hasProblems: boolean;
        readonly type: import("./typeSystem/wollokTypes").WollokType;
        readonly parentPackage: Package | undefined;
        toString(verbose?: boolean): string;
        is<Q extends import("./extensions").TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<import("./extensions").ConstructorFor<Q>>;
        copy(delta?: Record<string, unknown>): any;
        readonly children: List<Node>;
        siblings(): List<Node>;
        readonly descendants: List<Node>;
        readonly ancestors: List<Node>;
        transform(tx: (node: Node) => Node): any;
        forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
        reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
    } & Node;
    inherits(other: any): boolean;
    "__#1@#isEntity": any;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: import("./model").Scope;
    readonly sourceMap?: import("./model").SourceMap | undefined;
    readonly problems?: List<import("./model").BaseProblem> | undefined;
    readonly metadata: List<import("./model").Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: import("./typeSystem/wollokTypes").WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q_1 extends import("./extensions").TypeDefinition<Node>>(kindOrCategory: Q_1): this is InstanceType<import("./extensions").ConstructorFor<Q_1>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
} & Node) | Class | undefined)[];
export declare const superclassMethod: (node: Method) => Method | undefined;
export declare const finishesFlow: (sentence: Sentence, node: Node) => boolean;
export declare const getVariableContainer: (node: Node) => CodeContainer | undefined;
export declare const getContainer: (node: Node) => Module | Program | Test | undefined;
export declare const allScopedVariables: (node: CodeContainer) => Referenciable[];
export declare const hasDuplicatedVariable: (node: Module, variableName: string) => boolean;
export declare const isImplemented: (allMethods: List<Method>, method: Method) => boolean;
export declare const isEqualMessage: (node: Send) => boolean;
export declare const isBooleanMessage: (node: Send) => boolean;
export declare const referencesSingleton: (node: Expression) => boolean | undefined;
export declare const isBooleanOrUnknownType: (node: Node) => boolean;
export declare const valueFor: any | undefined;
export declare const sendsMessageToAssert: (node: Node) => boolean;
export declare const findMethod: (messageSend: Send) => Method | undefined;
export declare const callsToSuper: (node: Node) => boolean;
export declare const isGetter: (node: Method) => boolean;
export declare const entityIsAlreadyUsedInImport: (target: Entity | undefined, entityName: string) => boolean | undefined;
export declare const isAlreadyUsedInImport: (target: Entity | undefined, node: Entity | undefined) => boolean | undefined;
export declare const duplicatesLocalVariable: (node: Variable) => boolean;
export declare const assignsVariable: (sentence: Node, variable: Variable | Field) => boolean;
export declare const unusedVariable: (node: Field) => boolean;
export declare const usesField: (node: Node, field: Field) => boolean;
export declare const usesReservedWords: (node: Class | Singleton | Variable | Field | Parameter) => boolean;
export declare const supposedToReturnValue: (node: Node) => boolean;
export declare const returnsAValue: (node: Node) => boolean;
export declare const methodExists: (node: Send) => boolean;
export declare const loopInAssignment: (node: Expression, variableName: string) => boolean;
export declare const methodsCallingToSuper: (node: Class | Singleton) => Method[];
export declare const methodIsImplementedInSuperclass: (node: Class | Singleton) => (method: Method) => Method | undefined;
export declare const literalValueToClass: (environment: Environment, literal: LiteralValue) => Class;
export declare const existMethodFor: (send: Send) => boolean;
export declare const allAvailableMethods: (environment: Environment) => Method[];
export declare const allMethods: (environment: Environment, referenceClass: Reference<Module>) => Method[];
export declare const projectToJSON: (wre: Environment) => string;
export declare const firstNodeWithProblems: (node: Node) => Node | undefined;
export declare const isError: (problem: Problem) => boolean;
export declare const parentModule: (node: Node) => Module;
export declare const parentImport: (node: Node) => Import | undefined;
export declare const implicitImport: (node: Node) => boolean;
export declare const fqnRelativeToPackage: (pckg: Package, node: Entity) => string;
export declare const workspacePackage: (environment: Environment) => Package;
export declare const targettingAt: <T extends Node>(aNode: T) => (anotherNode: Node) => anotherNode is Reference<T>;
export declare const projectPackages: (environment: Environment) => Package[];
export declare const isNotImportedIn: (importedPackage: Package, importingPackage: Package) => boolean;
export declare const belongsTo: (node: Node, mainPackage: Package) => boolean;
export declare const mayExecute: (method: Method) => (node: Node) => boolean;
export declare const allVariables: (node: CodeContainer) => List<Variable>;
export declare const isNamedSingleton: (node: Node) => node is Singleton;
export declare const methodByFQN: (environment: Environment, fqn: string) => Method | undefined;
export declare const sendDefinitions: (environment: Environment) => (send: Send) => (Method | Field)[];
export declare const allMethodDefinitions: (environment: Environment, send: Send) => Method[];
export declare const moduleFinderWithBackup: (environment: Environment, send: Send) => (methodFinder: (module: Module) => Method[]) => Method[];
export declare const targetName: (target: Node | undefined, defaultName: Name) => string;
export declare const getNodeDefinition: (environment: Environment) => (node: Node) => Node[];
export declare const isApplyMethodForClosures: (method: Method) => boolean;
export declare const superMethodDefinition: (superNode: Super, methodModule: Module) => Method | undefined;
export declare const isVoid: (obj: RuntimeValue | RuntimeObject) => boolean;
export declare const assertNotVoid: (value: RuntimeObject, errorMessage: string) => void;
export declare const getExpressionFor: (node: Expression) => string;
export declare const showParameter: (obj: RuntimeObject) => string;
export declare const getMethodContainer: (node: Node) => Method | Program | Test | undefined;
export declare const possiblyReferenced: (reference: Reference<Node>, environment: Environment) => List<Node>;
export declare const compilePropertyMethod: (method: Method) => NativeFunction;
export declare const compileGetter: (message: string) => NativeFunction;
export declare const compileSetter: (message: string) => NativeFunction;
