"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Literal = exports.Send = exports.Catch = exports.Try = exports.Throw = exports.If = exports.New = exports.Super = exports.Self = exports.Expression = exports.Assignment = exports.Return = exports.Variable = exports.Sentence = exports.Method = exports.Field = exports.Describe = exports.Mixin = exports.Singleton = exports.Class = exports.ParameterizedType = exports.Test = exports.Program = exports.Package = exports.Entity = exports.ExpressionBody = exports.Body = exports.NamedArgument = exports.Parameter = exports.Reference = exports.FullyQualifiedReference = exports.packageName = exports.name = exports.Import = exports.File = exports.annotation = exports.sanitizeWhitespaces = exports.ParseError = exports.MALFORMED_MESSAGE_SEND = exports.MALFORMED_SENTENCE = exports.MALFORMED_MEMBER = exports.MALFORMED_ENTITY = void 0;
const console_1 = require("console");
const parsimmon_1 = __importStar(require("parsimmon"));
const unraw_1 = __importDefault(require("unraw"));
const constants_1 = require("./constants");
const extensions_1 = require("./extensions");
const model_1 = require("./model");
const { keys, values, fromEntries } = Object;
const { isArray } = Array;
const ALL_OPERATORS = [
    ...values(constants_1.PREFIX_OPERATORS),
    ...constants_1.INFIX_OPERATORS.flat(),
].sort((a, b) => b.localeCompare(a));
exports.MALFORMED_ENTITY = 'malformedEntity';
exports.MALFORMED_MEMBER = 'malformedMember';
exports.MALFORMED_SENTENCE = 'malformedSentence';
exports.MALFORMED_MESSAGE_SEND = 'malformedMessageSend';
class ParseError {
    constructor(code, sourceMap) {
        this.code = code;
        this.sourceMap = sourceMap;
    }
    get level() { return 'error'; }
    get values() { return []; }
}
exports.ParseError = ParseError;
const buildSourceMap = (start, end) => new model_1.SourceMap({
    start: new model_1.SourceIndex(start),
    end: new model_1.SourceIndex(end),
});
const parserLog = (data) => (0, parsimmon_1.default)((input, i) => {
    (0, console_1.log)({ input: input.substring(0, i), i, data });
    return (0, parsimmon_1.makeSuccess)(i, data);
});
function alt(...parsers) { return (0, parsimmon_1.alt)(...parsers); }
const error = (code) => (...safewords) => {
    const skippable = (...breakpoints) => (0, parsimmon_1.lazy)(() => alt(skippableContext, comment('start'), (0, parsimmon_1.notFollowedBy)(alt(key('}'), parsimmon_1.newline, ...breakpoints)).then(parsimmon_1.any)));
    const skippableContext = skippable().many().wrap(key('{'), key('}'));
    return skippable(...safewords.map(key))
        .atLeast(1)
        .mark()
        .map(({ start, end }) => new ParseError(code, buildSourceMap(start, end)));
};
const recover = (recoverable) => {
    const problems = [];
    const metadata = [];
    const purged = (0, extensions_1.mapObject)((value) => {
        if (isArray(value)) {
            const [newMetadata, otherValues] = (0, extensions_1.discriminate)((member) => member instanceof model_1.Annotation)(value);
            const [newProblems, payload] = (0, extensions_1.discriminate)((member) => member instanceof ParseError)(otherValues);
            problems.push(...newProblems);
            metadata.push(...newMetadata);
            return payload;
        }
        else
            return value;
    }, recoverable);
    return Object.assign(Object.assign({}, purged), { problems, metadata });
};
const check = (parser) => parser.result(true).fallback(false);
const optional = (parser) => parser.fallback(undefined);
const obj = (parsers) => (0, parsimmon_1.seqObj)(...keys(parsers).map(fieldName => [fieldName, parsers[fieldName]]));
const key = (str) => (str.match(/[\w ]+/)
    ? (0, parsimmon_1.string)(str).notFollowedBy((0, parsimmon_1.regex)(/\w/))
    : (0, parsimmon_1.string)(str)).trim(_);
const lastKey = (str) => _.then((0, parsimmon_1.string)(str));
const _ = optional(parsimmon_1.whitespace.atLeast(1));
const __ = optional(key(';').or(parsimmon_1.default.regex(/\s/)));
const spaces = optional((0, parsimmon_1.string)(' ').many());
const comment = (position) => (0, parsimmon_1.lazy)('comment', () => (0, parsimmon_1.regex)(/\/\*(.|[\r\n])*?\*\/|\/\/.*/)).map(text => new model_1.Annotation('comment', { text, position }));
const sameLineComment = spaces.then(comment('end'));
const withSameLineComment = (result) => optional(sameLineComment).map(comment => comment
    ? result.copy({ metadata: result.metadata.concat(comment) })
    : result);
const sanitizeWhitespaces = (originalFrom, originalTo, input) => {
    const EOL = input.includes('\r\n') ? '\r\n' : '\n';
    const hasLineBreaks = (aString) => aString.includes(EOL);
    const nodeInput = input.substring(originalFrom.offset, originalTo.offset);
    const hasWhitespaceAtTheEnd = (0, extensions_1.hasWhitespace)(input[originalTo.offset]);
    const shouldBeSanitized = (0, extensions_1.hasWhitespace)(nodeInput) || hasWhitespaceAtTheEnd || (0, extensions_1.hasWhitespace)(input[originalFrom.offset]);
    if (!shouldBeSanitized)
        return [originalFrom, originalTo];
    const from = Object.assign({}, originalFrom);
    const to = Object.assign({}, originalTo);
    if ((0, extensions_1.hasWhitespace)(input[to.offset]) && to.column == 0) {
        to.offset++;
    }
    if ((0, extensions_1.hasWhitespace)(input[from.offset]) && from.column == 0) {
        from.offset++;
    }
    while ((0, extensions_1.hasWhitespace)(input[from.offset]) && from.offset < originalTo.offset) {
        if (hasLineBreaks(input.substring(from.offset, from.offset + EOL.length))) {
            from.line++;
            from.column = 1;
            from.offset += EOL.length;
        }
        else {
            from.column++;
            from.offset++;
        }
    }
    while ((0, extensions_1.hasWhitespace)(input[to.offset - 1]) && to.offset > originalFrom.offset) {
        if (hasLineBreaks(input.substring(to.offset - EOL.length, to.offset))) {
            to.line--;
            const nodeLines = input.substring(from.offset, to.offset - EOL.length).split(EOL);
            const lastLine = nodeLines.pop();
            to.column = lastLine.length + (nodeLines.length == 0 ?
                from.column
                : 1);
            to.offset -= EOL.length;
        }
        else {
            to.column--;
            to.offset--;
        }
    }
    return [from, to];
};
exports.sanitizeWhitespaces = sanitizeWhitespaces;
exports.annotation = (0, parsimmon_1.lazy)(() => (0, parsimmon_1.string)('@').then(obj({
    name: exports.name,
    args: (0, parsimmon_1.seq)(exports.name, key('=').then(exports.Literal).map(literal => literal.value)).sepBy(key(','))
        .wrap(key('('), key(')'))
        .fallback([]),
})).map(({ name, args }) => new model_1.Annotation(name, fromEntries(args))));
const node = (constructor) => (parser) => (0, parsimmon_1.seq)(alt(exports.annotation, comment('start')).sepBy(_).wrap(_, _), parsimmon_1.index, (0, parsimmon_1.lazy)(parser), parsimmon_1.index, optional(sameLineComment))
    .chain(([_metadata, _start, payload, _end, comment]) => (0, parsimmon_1.default)((input, index) => {
    const [start, end] = (0, exports.sanitizeWhitespaces)(_start, _end, input);
    const metadata = comment ? _metadata.concat(comment) : _metadata;
    return (0, parsimmon_1.makeSuccess)(index, [metadata, start, payload, end]);
}))
    .map(([metadata, start, payload, end]) => new constructor(Object.assign(Object.assign({}, payload), { metadata: metadata.concat(...payload.metadata || []), sourceMap: buildSourceMap(start, end) })));
const File = (fileName) => (0, parsimmon_1.lazy)(() => obj({
    fileName: (0, parsimmon_1.of)(fileName),
    name: (0, parsimmon_1.of)(fileName.split('.')[0].replaceAll('/', '.')),
    imports: exports.Import.sepBy(_).skip(_),
    members: exports.Entity.or(alt(exports.annotation, comment('start'))).or(entityError).sepBy(_),
}).skip(_)
    .map(payload => new model_1.Package(recover(payload))));
exports.File = File;
exports.Import = node(model_1.Import)(() => key(constants_1.KEYWORDS.IMPORT).then(obj({
    entity: exports.FullyQualifiedReference,
    isGeneric: (0, parsimmon_1.string)('.*').result(true).fallback(false),
})).skip(__));
exports.name = (0, parsimmon_1.lazy)('identifier', () => (0, parsimmon_1.regex)(/^[\p{L}_][\p{L}\p{N}_]*/u));
exports.packageName = (0, parsimmon_1.lazy)('package identifier', () => (0, parsimmon_1.regex)(/[^\W\d][\w\p{L}-]*/u));
exports.FullyQualifiedReference = node(model_1.Reference)(() => obj({ name: exports.packageName.or(exports.name).sepBy1(key('.')).tieWith('.') }));
exports.Reference = node(model_1.Reference)(() => obj({ name: exports.name }));
exports.Parameter = node(model_1.Parameter)(() => obj({
    name: exports.name,
    isVarArg: (0, parsimmon_1.string)('...').result(true).fallback(false),
}));
exports.NamedArgument = node(model_1.NamedArgument)(() => obj({
    name: exports.name,
    value: key('=').then(exports.Expression),
}));
exports.Body = node(model_1.Body)(() => obj({
    sentences: alt(exports.Sentence.skip(__), comment('inner').wrap(_, _), sentenceError).many(),
}).wrap(key('{'), lastKey('}')).map(recover));
exports.ExpressionBody = node(model_1.Body)(() => {
    return obj({
        sentences: alt(exports.Expression.map(value => new model_1.Return({ value })), sentenceError).times(1),
    }).wrap(_, __).map(recover);
});
const inlineableBody = exports.Body.or(node(model_1.Body)(() => obj({ sentences: exports.Sentence.times(1) })).map(body => body.copy({
    metadata: [],
    sentences: body.sentences.map(sentence => sentence.copy({ metadata: [...body.metadata, ...sentence.metadata] })),
})));
const parameters = (0, parsimmon_1.lazy)(() => exports.Parameter.sepBy(key(',')).wrap(key('('), lastKey(')')));
const unamedArguments = (0, parsimmon_1.lazy)(() => exports.Expression.sepBy(key(',')).wrap(key('('), lastKey(')')));
const namedArguments = (0, parsimmon_1.lazy)(() => exports.NamedArgument.sepBy(key(',')).wrap(key('('), lastKey(')')));
const operator = (operatorNames) => alt(...operatorNames.map(key));
const entityError = error(exports.MALFORMED_ENTITY)(constants_1.KEYWORDS.PACKAGE, constants_1.KEYWORDS.CLASS, 'singleton', constants_1.KEYWORDS.MIXIN, constants_1.KEYWORDS.PROGRAM, constants_1.KEYWORDS.SUITE, constants_1.KEYWORDS.TEST, constants_1.KEYWORDS.VAR, constants_1.KEYWORDS.CONST);
exports.Entity = (0, parsimmon_1.lazy)(() => alt(exports.Package, exports.Class, exports.Singleton, exports.Mixin, exports.Program, exports.Describe, exports.Test, exports.Variable));
exports.Package = node(model_1.Package)(() => key(constants_1.KEYWORDS.PACKAGE).then(obj({
    name: exports.name.skip(key('{')),
    imports: exports.Import.skip(__).many(),
    members: exports.Entity.or(entityError).sepBy(_).skip(lastKey('}')),
})).map(recover));
exports.Program = node(model_1.Program)(() => key(constants_1.KEYWORDS.PROGRAM).then(obj({
    name: exports.name,
    body: exports.Body,
})));
exports.Test = node(model_1.Test)(() => obj({
    isOnly: check(key(constants_1.KEYWORDS.ONLY)),
    name: key(constants_1.KEYWORDS.TEST).then(stringLiteral.map(name => `"${name}"`)),
    body: exports.Body,
}));
exports.ParameterizedType = node(model_1.ParameterizedType)(() => obj({
    reference: exports.FullyQualifiedReference,
    args: optional(namedArguments),
}));
const supertypes = (0, parsimmon_1.lazy)(() => key(constants_1.KEYWORDS.INHERITS).then(exports.ParameterizedType.sepBy1(key(constants_1.KEYWORDS.MIXED_AND))).fallback([]));
const members = (0, parsimmon_1.lazy)(() => alt(exports.Field, exports.Method, comment('inner'), memberError));
exports.Class = node(model_1.Class)(() => key(constants_1.KEYWORDS.CLASS).then(obj({
    name: exports.name,
    supertypes,
    members: members
        .sepBy(_)
        .wrap(key('{'), key('}')),
})).map(recover));
exports.Singleton = node(model_1.Singleton)(() => key(constants_1.KEYWORDS.WKO).then(obj({
    name: optional((0, parsimmon_1.notFollowedBy)(key(constants_1.KEYWORDS.INHERITS)).then(exports.name)),
    supertypes,
    members: members
        .sepBy(_)
        .wrap(key('{'), key('}')),
})).map(recover));
exports.Mixin = node(model_1.Mixin)(() => key(constants_1.KEYWORDS.MIXIN).then(obj({
    name: exports.name,
    supertypes,
    members: members
        .sepBy(_)
        .wrap(key('{'), key('}')),
})).map(recover));
exports.Describe = node(model_1.Describe)(() => key(constants_1.KEYWORDS.SUITE).then(obj({
    name: stringLiteral.map(name => `"${name}"`),
    members: alt(exports.Test, members)
        .sepBy(_)
        .wrap(key('{'), key('}')),
})).map(recover));
const memberError = error(exports.MALFORMED_MEMBER)(constants_1.KEYWORDS.METHOD, constants_1.KEYWORDS.VAR, constants_1.KEYWORDS.CONST, constants_1.KEYWORDS.TEST, constants_1.KEYWORDS.SUITE);
const valueParser = (0, parsimmon_1.lazy)(() => optional(key('=').then(exports.Expression).skip(__)));
exports.Field = node(model_1.Field)(() => obj({
    isConstant: alt(key(constants_1.KEYWORDS.VAR).result(false), key(constants_1.KEYWORDS.CONST).result(true)),
    isProperty: check(key(constants_1.KEYWORDS.PROPERTY)),
    name: exports.name.skip(__),
    value: valueParser,
}));
exports.Method = node(model_1.Method)(() => obj({
    isOverride: check(key(constants_1.KEYWORDS.OVERRIDE)),
    name: key(constants_1.KEYWORDS.METHOD).then(alt(exports.name, operator(ALL_OPERATORS))),
    parameters: parameters.or(memberError.many()),
    body: alt(key('=').then(exports.ExpressionBody), key(constants_1.KEYWORDS.NATIVE), exports.Body).fallback(undefined),
}).map(recover));
const sentenceError = error(exports.MALFORMED_SENTENCE)();
exports.Sentence = (0, parsimmon_1.lazy)('sentence', () => alt(exports.Variable, exports.Return, exports.Assignment, exports.Expression));
exports.Variable = node(model_1.Variable)(() => obj({
    isConstant: alt(key(constants_1.KEYWORDS.VAR).result(false), key(constants_1.KEYWORDS.CONST).result(true)),
    name: exports.name,
    value: valueParser,
}));
exports.Return = node(model_1.Return)(() => key(constants_1.KEYWORDS.RETURN).then(obj({ value: optional(exports.Expression) })));
exports.Assignment = node(model_1.Assignment)(() => (0, parsimmon_1.seq)(exports.Reference, operator(constants_1.ASSIGNATION_OPERATORS), exports.Expression).map(([variable, assignation, value]) => ({
    variable,
    value: assignation === '='
        ? value
        : new model_1.Send({
            receiver: variable,
            message: assignation.slice(0, -1),
            args: [value],
        }),
})));
exports.Expression = (0, parsimmon_1.lazy)('expression', () => infixMessageChain(0));
const infixMessageChain = (precedenceLevel = 0) => {
    const argument = precedenceLevel < constants_1.INFIX_OPERATORS.length - 1
        ? infixMessageChain(precedenceLevel + 1)
        : prefixMessageChain;
    return messageChain(argument, operator(constants_1.INFIX_OPERATORS[precedenceLevel]), argument.times(1));
};
const prefixMessageChain = (0, parsimmon_1.lazy)(() => alt(node(model_1.Send)(() => obj({
    message: operator(keys(constants_1.PREFIX_OPERATORS)),
    receiver: prefixMessageChain,
}).map((send) => (Object.assign(Object.assign({}, send), { message: constants_1.PREFIX_OPERATORS[send.message], originalOperator: send.message })))), postfixMessageChain));
const postfixMessageChain = (0, parsimmon_1.lazy)(() => messageChain(postfixMessageChainInitialReceiver, key('.').then(exports.name), alt(unamedArguments, Closure.times(1))));
const postfixMessageChainInitialReceiver = (0, parsimmon_1.lazy)(() => alt(primaryExpression, obj({
    markedMessage: exports.name.mark(),
    args: alt(unamedArguments, Closure.times(1)),
}).mark().chain(({ start, end, value: { markedMessage: { value: message, start: errorStart, end: errorEnd }, args, }, }) => (0, parsimmon_1.default)((input, i) => (0, parsimmon_1.makeSuccess)(i, new model_1.Send({
    receiver: new model_1.Literal({ value: null }),
    message,
    args,
    problems: [new ParseError(exports.MALFORMED_MESSAGE_SEND, buildSourceMap(errorStart, errorEnd))],
    sourceMap: buildSourceMap(...(0, exports.sanitizeWhitespaces)(start, end, input)),
}))))).chain(withSameLineComment));
const messageChain = (receiver, message, args) => (0, parsimmon_1.lazy)(() => (0, parsimmon_1.seq)(parsimmon_1.index, receiver, (0, parsimmon_1.seq)(message, args, parsimmon_1.index).many(), optional(sameLineComment)).chain(([start, initialReceiver, calls, comment]) => (0, parsimmon_1.default)((input, i) => {
    const result = calls.reduce((receiver, [message, args, end]) => new model_1.Send({ receiver, message, args, sourceMap: buildSourceMap(...(0, exports.sanitizeWhitespaces)(start, end, input)) }), initialReceiver);
    return (0, parsimmon_1.makeSuccess)(i, comment
        ? result.copy({ metadata: result.metadata.concat(comment) })
        : result);
})));
const primaryExpression = (0, parsimmon_1.lazy)(() => {
    const NonAppliedFullyQualifiedReference = node(model_1.Reference)(() => obj({ name: exports.name.notFollowedBy(alt(key('('), key('{'))).sepBy1(key('.')).tieWith('.') }));
    return alt(exports.Self, exports.Super, exports.If, exports.New, exports.Throw, exports.Try, exports.Singleton, Closure, exports.Literal, NonAppliedFullyQualifiedReference, (0, parsimmon_1.seq)(exports.annotation.sepBy(_).wrap(_, _), exports.Expression.wrap(key('('), lastKey(')'))).map(([metadata, expression]) => expression.copy({ metadata: [...expression.metadata, ...metadata] })));
});
exports.Self = node(model_1.Self)(() => key(constants_1.KEYWORDS.SELF).result({}));
exports.Super = node(model_1.Super)(() => key(constants_1.KEYWORDS.SUPER).then(obj({ args: unamedArguments })));
exports.New = node(model_1.New)(() => key(constants_1.KEYWORDS.NEW).then(obj({
    instantiated: exports.FullyQualifiedReference,
    args: namedArguments,
})));
exports.If = node(model_1.If)(() => key('if').then(obj({
    condition: exports.Expression.wrap(key('('), lastKey(')')),
    thenBody: inlineableBody,
    elseBody: optional(key(constants_1.KEYWORDS.ELSE).then(inlineableBody)),
})));
exports.Throw = node(model_1.Throw)(() => key(constants_1.KEYWORDS.THROW).then(obj({ exception: exports.Expression })));
exports.Try = node(model_1.Try)(() => key(constants_1.KEYWORDS.TRY).then(obj({
    body: inlineableBody,
    catches: exports.Catch.many(),
    always: optional(key(`${constants_1.KEYWORDS.THEN} ${constants_1.KEYWORDS.ALWAYS}`).then(inlineableBody)),
})));
exports.Catch = node(model_1.Catch)(() => key(constants_1.KEYWORDS.CATCH).then(obj({
    parameter: exports.Parameter,
    parameterType: optional(key(':').then(exports.FullyQualifiedReference)),
    body: inlineableBody,
})));
exports.Send = postfixMessageChain.assert((0, extensions_1.is)(model_1.Send), 'Send');
exports.Literal = (0, parsimmon_1.lazy)('literal', () => alt(node(model_1.Literal)(() => obj({
    value: alt(key(constants_1.KEYWORDS.NULL).result(null), key('true').result(true), key('false').result(false), (0, parsimmon_1.lazy)('number literal', () => (0, parsimmon_1.regex)(/-?\d+(\.\d+)?/).map(Number)), exports.Expression.sepBy(key(',')).wrap(key('['), lastKey(']')).map(args => [new model_1.Reference({ name: constants_1.LIST_MODULE }), args]), exports.Expression.sepBy(key(',')).wrap(key('#{'), lastKey('}')).map(args => [new model_1.Reference({ name: constants_1.SET_MODULE }), args]), stringLiteral),
}))));
const stringLiteral = (0, parsimmon_1.lazy)('string literal', () => alt((0, parsimmon_1.regex)(/"((?:[^\\"]|\\[bfnrtv"\\/]|\\u[0-9a-fA-F]{4})*)"/, 1), (0, parsimmon_1.regex)(/'((?:[^\\']|\\[bfnrtv'\\/]|\\u[0-9a-fA-F]{4})*)'/, 1)).map(unraw_1.default));
const Closure = (0, parsimmon_1.lazy)(() => {
    return (0, parsimmon_1.seq)(exports.annotation.sepBy(_).wrap(_, _), (0, parsimmon_1.seq)(exports.Parameter.sepBy(key(',')).skip(key('=>')).fallback([]), exports.Sentence.skip(__).many()).wrap(key('{'), lastKey('}')).mark()).chain(([metadata, { start, end, value: [parameters, sentences] }]) => (0, parsimmon_1.default)((input, i) => (0, parsimmon_1.makeSuccess)(i, (0, model_1.Closure)({
        metadata,
        parameters,
        sentences,
        code: input.slice(start.offset, end.offset),
        sourceMap: buildSourceMap(start, end),
    }))));
});
//# sourceMappingURL=parser.js.map