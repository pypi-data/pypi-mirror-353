import { List, TypeDefinition } from '../extensions';
import { Assignment, Body, Catch, Class, Code, Describe, Field, If, Import, Method, Mixin, NamedArgument, New, Node, Package, Parameter, Problem, Program, Reference, Self, Send, Singleton, SourceMap, Super, Test, Try, Variable } from '../model';
export type Validation<N extends Node> = (node: N, code: Code) => Problem | null;
export declare const shouldNotBeEmpty: (node: Body, code: Code) => Problem | null;
export declare const isNotWithin: <N extends Node>(kind: TypeDefinition<N>) => (node: N, code: Code) => Problem | null;
export declare const nameMatches: (regex: RegExp) => (node: Node & {
    name: string;
}, code: Code) => Problem | null;
export declare const nameShouldBeginWithUppercase: (node: Node & {
    name: string;
}, code: Code) => Problem | null;
export declare const nameShouldBeginWithLowercase: (node: Node & {
    name: string;
}, code: Code) => Problem | null;
export declare const nameShouldNotBeKeyword: (node: Field | Parameter | Method | Variable, code: Code) => Problem | null;
export declare const inlineSingletonShouldBeAnonymous: (node: Singleton, code: Code) => Problem | null;
export declare const topLevelSingletonShouldHaveAName: (node: Singleton, code: Code) => Problem | null;
export declare const onlyLastParameterCanBeVarArg: (node: Method, code: Code) => Problem | null;
export declare const shouldHaveCatchOrAlways: (node: Try, code: Code) => Problem | null;
export declare const methodShouldHaveDifferentSignature: (node: Method, code: Code) => Problem | null;
export declare const shouldNotOnlyCallToSuper: (node: Method, code: Code) => Problem | null;
export declare const shouldNotInstantiateAbstractClass: (node: New, code: Code) => Problem | null;
export declare const shouldNotAssignToItself: (node: Assignment, code: Code) => Problem | null;
export declare const shouldNotReassignConst: (node: Assignment, code: Code) => Problem | null;
export declare const missingReference: (node: Reference<Node>, code: Code) => Problem | null;
export declare const shouldNotHaveLoopInHierarchy: (node: Class | Mixin, code: Code) => Problem | null;
export declare const shouldNotAssignToItselfInDeclaration: (node: Field | Variable, code: Code) => Problem | null;
export declare const shouldNotCompareAgainstBooleanLiterals: (node: Send, code: Code) => Problem | null;
export declare const shouldUseSelfAndNotSingletonReference: (node: Reference<Node>, code: Code) => Problem | null;
export declare const shouldReferenceToObjects: (node: Reference<Node>, code: Code) => Problem | null;
export declare const shouldOnlyInheritFromMixin: (node: Mixin, code: Code) => Problem | null;
export declare const shouldUseOverrideKeyword: (node: Method, code: Code) => Problem | null;
export declare const possiblyReturningBlock: (node: Method, code: Code) => Problem | null;
export declare const shouldNotUseOverride: (node: Method, code: Code) => Problem | null;
export declare const namedArgumentShouldExist: (node: NamedArgument, code: Code) => Problem | null;
export declare const namedArgumentShouldNotAppearMoreThanOnce: (node: NamedArgument, code: Code) => Problem | null;
export declare const linearizationShouldNotRepeatNamedArguments: (node: Class | Singleton, code: Code) => Problem | null;
export declare const shouldPassValuesToAllAttributes: (node: New, code: Code) => Problem | null;
export declare const shouldInitializeInheritedAttributes: (node: Singleton, code: Code) => Problem | null;
export declare const shouldInitializeSingletonAttribute: (node: Field, code: Code) => Problem | null;
export declare const shouldNotUseSelf: (node: Self, code: Code) => Problem | null;
export declare const shouldNotDefineMoreThanOneSuperclass: (node: Class | Singleton, code: Code) => Problem | null;
export declare const superclassShouldBeLastInLinearization: (node: Class | Singleton, code: Code) => Problem | null;
export declare const shouldMatchSuperclassReturnValue: (node: Method, code: Code) => Problem | null;
export declare const shouldReturnAValueOnAllFlows: (node: If, code: Code) => Problem | null;
export declare const shouldNotDuplicateFields: (node: Field, code: Code) => Problem | null;
export declare const parameterShouldNotDuplicateExistingVariable: (node: Parameter, code: Code) => Problem | null;
export declare const shouldNotDuplicateLocalVariables: (node: Variable, code: Code) => Problem | null;
export declare const shouldNotDuplicateGlobalDefinitions: (node: ({
    "__#2@#isModule": any;
    readonly name?: string | undefined;
    readonly supertypes: List<import("../model").ParameterizedType>;
    readonly members: List<Field | Method | Variable | Test>;
    readonly superclass: Class | undefined;
    readonly hierarchy: List<any>;
    readonly mixins: List<Mixin>;
    readonly methods: List<Method>;
    readonly fields: List<Field>;
    readonly allMembers: List<Field | Method | Variable | Test>;
    readonly allFields: List<Field>;
    readonly allMethods: List<Method>;
    lookupField(name: string): Field | undefined;
    lookupMethod(name: string, arity: number, options?: {
        lookupStartFQN?: string | undefined;
        allowAbstractMethods?: boolean | undefined;
    } | undefined): Method | undefined;
    readonly isAbstract: boolean;
    readonly abstractMethods: List<Method>;
    defaultValueFor(field: Field): {
        "__#4@#isExpression": any;
        "__#3@#isSentence": any;
        readonly kind: string;
        readonly id: string;
        readonly scope: import("../model").Scope;
        readonly sourceMap?: SourceMap | undefined;
        readonly problems?: List<import("../model").BaseProblem> | undefined;
        readonly metadata: List<import("../model").Annotation>;
        environment: import("../model").Environment;
        parent: Node;
        readonly categories: Function[];
        readonly sourceFileName: string | undefined;
        readonly sourceInfo: string;
        readonly label: string;
        readonly isSynthetic: boolean;
        readonly hasProblems: boolean;
        readonly type: import("../typeSystem/wollokTypes").WollokType;
        readonly parentPackage: Package | undefined;
        toString(verbose?: boolean): string;
        is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<import("../extensions").ConstructorFor<Q>>;
        copy(delta?: Record<string, unknown>): any;
        readonly children: List<Node>;
        siblings(): List<Node>;
        readonly descendants: List<Node>;
        readonly ancestors: List<Node>;
        transform(tx: (node: Node) => Node): any;
        forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
        reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
    } & Node;
    inherits(other: any): boolean;
    "__#1@#isEntity": any;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: import("../model").Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<import("../model").BaseProblem> | undefined;
    readonly metadata: List<import("../model").Annotation>;
    environment: import("../model").Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: import("../typeSystem/wollokTypes").WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q_1 extends TypeDefinition<Node>>(kindOrCategory: Q_1): this is InstanceType<import("../extensions").ConstructorFor<Q_1>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
} & Node) | Variable, code: Code) => Problem | null;
export declare const shouldNotDuplicateVariablesInLinearization: (node: {
    "__#2@#isModule": any;
    readonly name?: string | undefined;
    readonly supertypes: List<import("../model").ParameterizedType>;
    readonly members: List<Field | Method | Variable | Test>;
    readonly superclass: Class | undefined;
    readonly hierarchy: List<any>;
    readonly mixins: List<Mixin>;
    readonly methods: List<Method>;
    readonly fields: List<Field>;
    readonly allMembers: List<Field | Method | Variable | Test>;
    readonly allFields: List<Field>;
    readonly allMethods: List<Method>;
    lookupField(name: string): Field | undefined;
    lookupMethod(name: string, arity: number, options?: {
        lookupStartFQN?: string | undefined;
        allowAbstractMethods?: boolean | undefined;
    } | undefined): Method | undefined;
    readonly isAbstract: boolean;
    readonly abstractMethods: List<Method>;
    defaultValueFor(field: Field): {
        "__#4@#isExpression": any;
        "__#3@#isSentence": any;
        readonly kind: string;
        readonly id: string;
        readonly scope: import("../model").Scope;
        readonly sourceMap?: SourceMap | undefined;
        readonly problems?: List<import("../model").BaseProblem> | undefined;
        readonly metadata: List<import("../model").Annotation>;
        environment: import("../model").Environment;
        parent: Node;
        readonly categories: Function[];
        readonly sourceFileName: string | undefined;
        readonly sourceInfo: string;
        readonly label: string;
        readonly isSynthetic: boolean;
        readonly hasProblems: boolean;
        readonly type: import("../typeSystem/wollokTypes").WollokType;
        readonly parentPackage: Package | undefined;
        toString(verbose?: boolean): string;
        is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<import("../extensions").ConstructorFor<Q>>;
        copy(delta?: Record<string, unknown>): any;
        readonly children: List<Node>;
        siblings(): List<Node>;
        readonly descendants: List<Node>;
        readonly ancestors: List<Node>;
        transform(tx: (node: Node) => Node): any;
        forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
        reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
    } & Node;
    inherits(other: any): boolean;
    "__#1@#isEntity": any;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: import("../model").Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<import("../model").BaseProblem> | undefined;
    readonly metadata: List<import("../model").Annotation>;
    environment: import("../model").Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: import("../typeSystem/wollokTypes").WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q_1 extends TypeDefinition<Node>>(kindOrCategory: Q_1): this is InstanceType<import("../extensions").ConstructorFor<Q_1>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
} & Node, code: Code) => Problem | null;
export declare const shouldImplementInheritedAbstractMethods: (node: Singleton, code: Code) => Problem | null;
export declare const shouldHaveBody: (node: Method, code: Code) => Problem | null;
export declare const shouldNotDefineGlobalMutableVariables: (node: Variable, code: Code) => Problem | null;
export declare const shouldNotCompareEqualityOfSingleton: (node: Send, code: Code) => Problem | null;
export declare const shouldUseBooleanValueInIfCondition: (node: If, code: Code) => Problem | null;
export declare const shouldUseBooleanValueInLogicOperation: (node: Send, code: Code) => Problem | null;
export declare const shouldNotDefineUnnecesaryIf: (node: If, code: Code) => Problem | null;
export declare const shouldNotDefineEmptyDescribe: (node: Describe, code: Code) => Problem | null;
export declare const shouldHaveNonEmptyName: (node: Test | Describe, code: Code) => Problem | null;
export declare const shouldNotMarkMoreThanOneOnlyTest: (node: Test, code: Code) => Problem | null;
export declare const shouldNotDefineNativeMethodsOnUnnamedSingleton: (node: Method, code: Code) => Problem | null;
export declare const codeShouldBeReachable: (node: If | Send, code: Code) => Problem | null;
export declare const methodShouldExist: (node: Send, code: Code) => Problem | null;
export declare const shouldUseSuperOnlyOnOverridingMethod: (node: Super, code: Code) => Problem | null;
export declare const shouldNotDefineUnnecessaryCondition: (node: If | Send, code: Code) => Problem | null;
export declare const overridingMethodShouldHaveABody: (node: Method, code: Code) => Problem | null;
export declare const shouldUseConditionalExpression: (node: If, code: Code) => Problem | null;
export declare const shouldHaveAssertInTest: (node: Test, code: Code) => Problem | null;
export declare const shouldMatchFileExtension: (node: Test | Program, code: Code) => Problem | null;
export declare const shouldImplementAllMethodsInHierarchy: (node: Class | Singleton, code: Code) => Problem | null;
export declare const getterMethodShouldReturnAValue: (node: Method, code: Code) => Problem | null;
export declare const shouldNotUseReservedWords: (node: Field | Parameter | Variable | Class | Singleton, code: Code) => Problem | null;
export declare const shouldInitializeGlobalReference: (node: Variable, code: Code) => Problem | null;
export declare const shouldNotDefineUnusedVariables: (node: Field, code: Code) => Problem | null;
export declare const shouldInitializeConst: (node: Variable, code: Code) => Problem | null;
export declare const shouldNotDuplicatePackageName: (node: Package, code: Code) => Problem | null;
export declare const shouldNotUseSpecialCharactersInName: (node: Package, code: Code) => Problem | null;
export declare const shouldCatchUsingExceptionHierarchy: (node: Catch, code: Code) => Problem | null;
export declare const catchShouldBeReachable: (node: Catch, code: Code) => Problem | null;
export declare const shouldNotDuplicateEntities: (node: ({
    "__#1@#isEntity": any;
    readonly name?: string | undefined;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: import("../model").Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<import("../model").BaseProblem> | undefined;
    readonly metadata: List<import("../model").Annotation>;
    environment: import("../model").Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: import("../typeSystem/wollokTypes").WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<import("../extensions").ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
} & Node) | Variable, code: Code) => Problem | null;
export declare const shouldNotImportSameFile: (node: Import, code: Code) => Problem | null;
export declare const shouldNotUseVoidSingleton: (node: Reference<Node>, code: Code) => Problem | null;
export declare const shouldNotImportMoreThanOnce: (node: Import, code: Code) => Problem | null;
export declare const shouldDefineConstInsteadOfVar: (node: Field | Variable, code: Code) => Problem | null;
export declare const shouldNotUseVoidMethodAsValue: (node: Send, code: Code) => Problem | null;
export declare const shouldNotAssignValueInLoop: (node: Field, code: Code) => Problem | null;
export declare const shouldHaveDifferentName: (node: Test, code: Code) => Problem | null;
export declare const shouldNotRedefineIdentity: (node: Method, code: Code) => Problem | null;
declare const _default: (target: Node) => List<Problem>;
export default _default;
