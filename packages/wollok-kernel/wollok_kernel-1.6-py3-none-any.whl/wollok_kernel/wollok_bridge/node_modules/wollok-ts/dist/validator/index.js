"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldHaveNonEmptyName = exports.shouldNotDefineEmptyDescribe = exports.shouldNotDefineUnnecesaryIf = exports.shouldUseBooleanValueInLogicOperation = exports.shouldUseBooleanValueInIfCondition = exports.shouldNotCompareEqualityOfSingleton = exports.shouldNotDefineGlobalMutableVariables = exports.shouldHaveBody = exports.shouldImplementInheritedAbstractMethods = exports.shouldNotDuplicateVariablesInLinearization = exports.shouldNotDuplicateGlobalDefinitions = exports.shouldNotDuplicateLocalVariables = exports.parameterShouldNotDuplicateExistingVariable = exports.shouldNotDuplicateFields = exports.shouldReturnAValueOnAllFlows = exports.shouldMatchSuperclassReturnValue = exports.superclassShouldBeLastInLinearization = exports.shouldNotDefineMoreThanOneSuperclass = exports.shouldNotUseSelf = exports.shouldInitializeSingletonAttribute = exports.shouldInitializeInheritedAttributes = exports.shouldPassValuesToAllAttributes = exports.linearizationShouldNotRepeatNamedArguments = exports.namedArgumentShouldNotAppearMoreThanOnce = exports.namedArgumentShouldExist = exports.shouldNotUseOverride = exports.possiblyReturningBlock = exports.shouldUseOverrideKeyword = exports.shouldOnlyInheritFromMixin = exports.shouldReferenceToObjects = exports.shouldUseSelfAndNotSingletonReference = exports.shouldNotCompareAgainstBooleanLiterals = exports.shouldNotAssignToItselfInDeclaration = exports.shouldNotHaveLoopInHierarchy = exports.missingReference = exports.shouldNotReassignConst = exports.shouldNotAssignToItself = exports.shouldNotInstantiateAbstractClass = exports.shouldNotOnlyCallToSuper = exports.methodShouldHaveDifferentSignature = exports.shouldHaveCatchOrAlways = exports.onlyLastParameterCanBeVarArg = exports.topLevelSingletonShouldHaveAName = exports.inlineSingletonShouldBeAnonymous = exports.nameShouldNotBeKeyword = exports.nameShouldBeginWithLowercase = exports.nameShouldBeginWithUppercase = exports.nameMatches = exports.isNotWithin = exports.shouldNotBeEmpty = void 0;
exports.shouldNotRedefineIdentity = exports.shouldHaveDifferentName = exports.shouldNotAssignValueInLoop = exports.shouldNotUseVoidMethodAsValue = exports.shouldDefineConstInsteadOfVar = exports.shouldNotImportMoreThanOnce = exports.shouldNotUseVoidSingleton = exports.shouldNotImportSameFile = exports.shouldNotDuplicateEntities = exports.catchShouldBeReachable = exports.shouldCatchUsingExceptionHierarchy = exports.shouldNotUseSpecialCharactersInName = exports.shouldNotDuplicatePackageName = exports.shouldInitializeConst = exports.shouldNotDefineUnusedVariables = exports.shouldInitializeGlobalReference = exports.shouldNotUseReservedWords = exports.getterMethodShouldReturnAValue = exports.shouldImplementAllMethodsInHierarchy = exports.shouldMatchFileExtension = exports.shouldHaveAssertInTest = exports.shouldUseConditionalExpression = exports.overridingMethodShouldHaveABody = exports.shouldNotDefineUnnecessaryCondition = exports.shouldUseSuperOnlyOnOverridingMethod = exports.methodShouldExist = exports.codeShouldBeReachable = exports.shouldNotDefineNativeMethodsOnUnnamedSingleton = exports.shouldNotMarkMoreThanOneOnlyTest = void 0;
const constants_1 = require("../constants");
const extensions_1 = require("../extensions");
const model_1 = require("../model");
const helpers_1 = require("../helpers");
const sourceMaps_1 = require("./sourceMaps");
const values_1 = require("./values");
const { entries } = Object;
const RESERVED_WORDS = ['null', 'false', 'true']
    .concat(Object.values(constants_1.KEYWORDS))
    .filter(word => word !== 'and');
const problem = (level) => (expectation, values = () => [], source = (node) => node.sourceMap) => (node, code) => !expectation(node)
    ? {
        level,
        code,
        node,
        values: values(node),
        sourceMap: source(node),
    }
    : null;
const warning = problem('warning');
const error = problem('error');
exports.shouldNotBeEmpty = warning(node => node.isEmpty());
const isNotWithin = (kind) => error((node) => !node.ancestors.some((0, extensions_1.is)(kind)) || node.isSynthetic);
exports.isNotWithin = isNotWithin;
const nameMatches = (regex) => warning(node => !node.name || regex.test(node.name), values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.nameMatches = nameMatches;
exports.nameShouldBeginWithUppercase = (0, exports.nameMatches)(/^[A-ZÑÁÉÍÓÚ]/);
exports.nameShouldBeginWithLowercase = (0, exports.nameMatches)(/^[a-z_<ñáéíóú]/);
exports.nameShouldNotBeKeyword = error(node => !RESERVED_WORDS.includes(node.name || ''), values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.inlineSingletonShouldBeAnonymous = error(singleton => singleton.parent.is(model_1.Package) || !singleton.name, values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.topLevelSingletonShouldHaveAName = error(singleton => !singleton.parent.is(model_1.Package) || !!singleton.name);
exports.onlyLastParameterCanBeVarArg = error(node => {
    const varArgIndex = node.parameters.findIndex(parameter => parameter.isVarArg);
    return varArgIndex < 0 || varArgIndex === node.parameters.length - 1;
});
exports.shouldHaveCatchOrAlways = error(node => (0, extensions_1.notEmpty)(node.catches) || (0, extensions_1.notEmpty)(node.always.sentences));
exports.methodShouldHaveDifferentSignature = error(node => node.parent.methods.every(parentMethod => node === parentMethod || !parentMethod.matchesSignature(node.name, node.parameters.length)));
exports.shouldNotOnlyCallToSuper = warning(node => {
    const callsSuperWithSameArgs = (sentence) => (sentence === null || sentence === void 0 ? void 0 : sentence.is(model_1.Super)) && sentence.args.every((arg, index) => arg.is(model_1.Reference) && arg.target === node.parameters[index]);
    return (0, extensions_1.isEmpty)(node.sentences) || !node.sentences.every(sentence => callsSuperWithSameArgs(sentence) && node.sentences.length == 1 || sentence.is(model_1.Return) && callsSuperWithSameArgs(sentence.value));
}, undefined, sourceMaps_1.sourceMapForBody);
exports.shouldNotInstantiateAbstractClass = error(node => { var _a; return !((_a = node.instantiated.target) === null || _a === void 0 ? void 0 : _a.isAbstract); });
exports.shouldNotAssignToItself = error(node => {
    const assigned = node.variable.target;
    return !(node.value.is(model_1.Reference) && assigned && assigned === node.value.target);
});
exports.shouldNotReassignConst = error(node => {
    var _a;
    const target = (_a = node === null || node === void 0 ? void 0 : node.variable) === null || _a === void 0 ? void 0 : _a.target;
    const referenceIsNotConstant = !target || (target.is(model_1.Variable) || (target === null || target === void 0 ? void 0 : target.is(model_1.Field))) && !target.isConstant;
    return referenceIsNotConstant && !(target === null || target === void 0 ? void 0 : target.is(model_1.Parameter));
});
exports.missingReference = error(node => !!node.target);
exports.shouldNotHaveLoopInHierarchy = error(node => !(0, helpers_1.allParents)(node).includes(node));
exports.shouldNotAssignToItselfInDeclaration = error(node => !node.value.is(model_1.Reference) || node.value.target !== node);
exports.shouldNotCompareAgainstBooleanLiterals = warning(node => {
    const arg = node.args[0];
    return !(0, helpers_1.isEqualMessage)(node) || !arg || !((0, helpers_1.hasBooleanValue)(arg, true) || (0, helpers_1.hasBooleanValue)(arg, false) || (0, helpers_1.hasBooleanValue)(node.receiver, true) || (0, helpers_1.hasBooleanValue)(node.receiver, false));
});
exports.shouldUseSelfAndNotSingletonReference = warning(node => {
    const target = node.target;
    return !target || !target.is(model_1.Singleton) || !node.ancestors.includes(target);
});
exports.shouldReferenceToObjects = error(node => {
    const target = node.target;
    return !target || !target.is(model_1.Package) || node.parent.is(model_1.Import);
});
exports.shouldOnlyInheritFromMixin = error(node => node.supertypes.every(parent => {
    const target = parent.reference.target;
    return !target || target.is(model_1.Mixin);
}));
exports.shouldUseOverrideKeyword = warning(node => node.isOverride || node.isSynthetic || !(0, helpers_1.superclassMethod)(node) || node.name == constants_1.INITIALIZE_METHOD);
exports.possiblyReturningBlock = warning(node => {
    var _a;
    if (node.sentences.length !== 1)
        return true;
    const singleSentence = node.sentences[0];
    return !(singleSentence.isSynthetic && singleSentence.is(model_1.Return) && ((_a = singleSentence.value) === null || _a === void 0 ? void 0 : _a.is(model_1.Singleton)) && singleSentence.value.isClosure(0));
});
exports.shouldNotUseOverride = error(node => node.parent.is(model_1.Mixin) || !node.isOverride || !!(0, helpers_1.superclassMethod)(node), values_1.valuesForNodeName, sourceMaps_1.sourceMapForOverrideMethod);
exports.namedArgumentShouldExist = error(node => {
    const parent = (0, helpers_1.getReferencedModule)(node.parent);
    return !parent || !!parent.lookupField(node.name);
}, values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.namedArgumentShouldNotAppearMoreThanOnce = warning(node => {
    const nodeParent = node.parent;
    let siblingArguments;
    if (nodeParent.is(model_1.New))
        siblingArguments = nodeParent.args;
    return !siblingArguments || (0, extensions_1.count)(siblingArguments, _ => _.name === node.name) === 1;
}, values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.linearizationShouldNotRepeatNamedArguments = warning(node => {
    const allNamedArguments = node.supertypes.flatMap(parent => parent.args.map(_ => _.name));
    return (0, extensions_1.isEmpty)((0, extensions_1.duplicates)(allNamedArguments));
});
exports.shouldPassValuesToAllAttributes = error(node => (0, extensions_1.isEmpty)((0, helpers_1.getUninitializedAttributesForInstantiation)(node)), node => { var _a; return [(_a = node.instantiated) === null || _a === void 0 ? void 0 : _a.name, (0, helpers_1.getUninitializedAttributesForInstantiation)(node).join(', ')]; });
exports.shouldInitializeInheritedAttributes = error(node => (0, extensions_1.isEmpty)((0, helpers_1.getInheritedUninitializedAttributes)(node)), node => [(0, helpers_1.getInheritedUninitializedAttributes)(node).join(', ')]);
exports.shouldInitializeSingletonAttribute = error(node => {
    return !node.parent.is(model_1.Singleton) || !(0, helpers_1.isUninitialized)(node.value);
}, values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldNotUseSelf = error(node => {
    const ancestors = node.ancestors;
    return node.isSynthetic || !ancestors.some((0, extensions_1.is)(model_1.Program)) || ancestors.some((0, extensions_1.is)(model_1.Singleton));
});
exports.shouldNotDefineMoreThanOneSuperclass = error(node => (0, extensions_1.count)((0, helpers_1.targetSupertypes)(node), _ => !!_ && _.is(model_1.Class)) <= 1);
exports.superclassShouldBeLastInLinearization = error(node => {
    const parents = (0, helpers_1.targetSupertypes)(node);
    const hasSuperclass = (0, extensions_1.notEmpty)(parents.filter(_ => !!_ && _.is(model_1.Class)));
    const lastParentInHierarchy = (0, extensions_1.last)(parents);
    return !hasSuperclass || !!lastParentInHierarchy && lastParentInHierarchy.is(model_1.Class);
});
exports.shouldMatchSuperclassReturnValue = error(node => {
    if (!node.isOverride)
        return true;
    const overridenMethod = (0, helpers_1.superclassMethod)(node);
    if (!overridenMethod || overridenMethod.isAbstract() || overridenMethod.isNative())
        return true;
    const lastSentence = (0, extensions_1.last)(node.sentences);
    const superclassSentence = (0, extensions_1.last)(overridenMethod.sentences);
    return !lastSentence || !superclassSentence || lastSentence.is(model_1.Return) === superclassSentence.is(model_1.Return) || lastSentence.is(model_1.Throw) || superclassSentence.is(model_1.Throw);
}, values_1.valuesForNodeName, sourceMaps_1.sourceMapForBody);
exports.shouldReturnAValueOnAllFlows = error(node => {
    var _a, _b;
    const lastThenSentence = (0, extensions_1.last)(node.thenBody.sentences);
    const lastElseSentence = (0, extensions_1.last)(node.elseBody.sentences);
    const noFlow = !lastThenSentence && !lastElseSentence;
    const thenSingleFlow = !lastElseSentence && lastThenSentence && (0, helpers_1.finishesFlow)(lastThenSentence, node);
    const elseSingleFlow = !lastThenSentence && lastElseSentence && (0, helpers_1.finishesFlow)(lastElseSentence, node);
    const singleFlow = thenSingleFlow || elseSingleFlow;
    const rightCombinations = {
        'Assignment': ['Assignment', 'Send', 'Throw', 'Variable'],
        'Literal': ['Literal', 'New', 'Self', 'Send', 'Reference', 'Super', 'Throw'],
        'New': ['Literal', 'New', 'Self', 'Send', 'Reference', 'Super', 'Throw'],
        'Reference': ['Literal', 'New', 'Self', 'Send', 'Reference', 'Super', 'Throw'],
        'Return': ['Return', 'Throw'],
        'Self': ['Literal', 'New', 'Self', 'Send', 'Reference', 'Super', 'Throw'],
        'Send': ['Literal', 'New', 'Return', 'Self', 'Send', 'Reference', 'Super', 'Throw'],
        'Throw': ['Literal', 'New', 'Return', 'Self', 'Send', 'Reference', 'Super', 'Throw'],
        'Variable': ['Assignment', 'Send', 'Throw', 'Variable'],
    };
    const twoFlows = !!lastThenSentence && !!lastElseSentence && (((_a = rightCombinations[lastThenSentence.kind]) === null || _a === void 0 ? void 0 : _a.includes(lastElseSentence.kind)) || ((_b = rightCombinations[lastElseSentence.kind]) === null || _b === void 0 ? void 0 : _b.includes(lastThenSentence.kind)));
    const ifFlows = !!lastThenSentence && !!lastElseSentence && (lastThenSentence.is(model_1.If) || lastElseSentence.is(model_1.If));
    return noFlow || singleFlow || twoFlows || ifFlows;
});
exports.shouldNotDuplicateFields = error(node => (0, extensions_1.count)(node.parent.allFields, _ => _.name == node.name) === 1, values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.parameterShouldNotDuplicateExistingVariable = error(node => {
    const nodeMethod = (0, helpers_1.getVariableContainer)(node);
    if (!nodeMethod)
        return true;
    const parameterNotDuplicated = (0, extensions_1.count)(nodeMethod.parameters || [], parameter => parameter.name == node.name) <= 1;
    return parameterNotDuplicated && !(0, helpers_1.hasDuplicatedVariable)(nodeMethod.parent, node.name);
});
exports.shouldNotDuplicateLocalVariables = error(node => !(0, helpers_1.duplicatesLocalVariable)(node), values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldNotDuplicateGlobalDefinitions = error(node => !node.name || !node.parent.is(model_1.Package) || (0, extensions_1.isEmpty)(node.siblings().filter(child => child.name == node.name)), values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldNotDuplicateVariablesInLinearization = error(node => {
    const allFields = node.allFields.filter(field => !node.fields.includes(field)).map(_ => _.name);
    return allFields.length === new Set(allFields).size;
});
exports.shouldImplementInheritedAbstractMethods = error(node => !(0, helpers_1.inheritsCustomDefinition)(node) || !node.allMethods.some(method => !(0, helpers_1.isImplemented)(node.allMethods, method) && method.isAbstract()));
exports.shouldHaveBody = error(node => {
    const parentModule = node.parent;
    return !parentModule.is(model_1.Singleton) || node.isNative() || !node.isAbstract();
});
exports.shouldNotDefineGlobalMutableVariables = error(variable => {
    return variable.isConstant || !variable.isAtPackageLevel;
}, values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldNotCompareEqualityOfSingleton = warning(node => {
    const referencesUnwantedSingleton = (element) => (0, helpers_1.referencesSingleton)(element);
    const arg = node.args[0];
    return !(0, helpers_1.isEqualMessage)(node) || !arg || !(referencesUnwantedSingleton(arg) || referencesUnwantedSingleton(node.receiver));
});
exports.shouldUseBooleanValueInIfCondition = error(node => (0, helpers_1.isBooleanOrUnknownType)(node.condition), undefined, sourceMaps_1.sourceMapForConditionInIf);
exports.shouldUseBooleanValueInLogicOperation = error(node => {
    if (!(0, helpers_1.isBooleanMessage)(node))
        return true;
    const unaryOperation = (0, helpers_1.isBooleanOrUnknownType)(node.receiver) && (0, extensions_1.isEmpty)(node.args);
    const binaryOperation = node.args.length === 1 && (0, helpers_1.isBooleanOrUnknownType)(node.args[0]) && (0, helpers_1.isBooleanOrUnknownType)(node.receiver);
    return unaryOperation || binaryOperation;
});
exports.shouldNotDefineUnnecesaryIf = error(node => (0, extensions_1.notEmpty)(node.elseBody.sentences) || !node.condition.is(model_1.Literal) || node.condition.value !== true, undefined, sourceMaps_1.sourceMapForConditionInIf);
exports.shouldNotDefineEmptyDescribe = warning(node => (0, extensions_1.notEmpty)(node.tests));
exports.shouldHaveNonEmptyName = warning(node => { var _a; return ((_a = node.name) !== null && _a !== void 0 ? _a : '').replaceAll('"', '').trim() !== ''; }, values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldNotMarkMoreThanOneOnlyTest = warning(node => !node.isOnly || (0, extensions_1.count)(node.siblings(), element => element.is(model_1.Test) && element.isOnly) <= 1, values_1.valuesForNodeName, sourceMaps_1.sourceMapForOnlyTest);
exports.shouldNotDefineNativeMethodsOnUnnamedSingleton = error(node => {
    const parent = node.parent;
    return !node.isNative() || !parent.is(model_1.Singleton) || !!parent.name;
}, values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.codeShouldBeReachable = error(node => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.If)(node => {
    const condition = node.condition;
    if (!condition.is(model_1.Literal) || condition.value !== true && condition.value !== false)
        return true;
    return (0, helpers_1.hasBooleanValue)(condition, true) && (0, extensions_1.isEmpty)(node.elseBody.sentences) || (0, helpers_1.hasBooleanValue)(condition, false) && (0, extensions_1.isEmpty)(node.thenBody.sentences);
}), (0, extensions_1.when)(model_1.Send)(node => {
    const receiver = node.receiver;
    const message = node.message;
    return !((0, helpers_1.hasBooleanValue)(receiver, true) && ['or', '||'].includes(message)) && !((0, helpers_1.hasBooleanValue)(receiver, false) && ['and', '&&'].includes(message));
})), undefined, sourceMaps_1.sourceMapForUnreachableCode);
exports.methodShouldExist = error(node => (0, helpers_1.methodExists)(node));
exports.shouldUseSuperOnlyOnOverridingMethod = error(node => {
    var _a;
    const method = node.ancestors.find((0, extensions_1.is)(model_1.Method));
    if ((_a = (0, helpers_1.parentModule)(node)) === null || _a === void 0 ? void 0 : _a.is(model_1.Mixin))
        return true;
    if (!method)
        return false;
    return !!(0, helpers_1.superclassMethod)(method) && method.matchesSignature(method.name, node.args.length);
});
exports.shouldNotDefineUnnecessaryCondition = warning(node => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.If)(node => {
    var _a;
    if (node.thenBody.sentences.length !== 1 || ((_a = node.elseBody) === null || _a === void 0 ? void 0 : _a.sentences.length) !== 1)
        return true;
    const thenValue = (0, helpers_1.valueFor)((0, extensions_1.last)(node.thenBody.sentences));
    const elseValue = (0, helpers_1.valueFor)((0, extensions_1.last)(node.elseBody.sentences));
    return thenValue === undefined || elseValue === undefined || thenValue !== elseValue;
}), (0, extensions_1.when)(model_1.Send)(node => {
    const receiver = node.receiver;
    const argument = node.args[0];
    const andOperation = ['and', '&&'].includes(node.message);
    const orOperation = ['or', '||'].includes(node.message);
    if (andOperation)
        return !(0, helpers_1.hasBooleanValue)(receiver, true) && !(0, helpers_1.hasBooleanValue)(argument, true);
    if (orOperation)
        return !(0, helpers_1.hasBooleanValue)(receiver, false) && !(0, helpers_1.hasBooleanValue)(argument, false);
    return true;
})));
exports.overridingMethodShouldHaveABody = error(node => !node.isOverride || node.isNative() || node.isConcrete(), values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldUseConditionalExpression = warning(node => {
    const thenValue = (0, extensions_1.isEmpty)(node.thenBody.sentences) ? undefined : (0, helpers_1.valueFor)((0, extensions_1.last)(node.thenBody.sentences));
    const elseValue = (0, extensions_1.isEmpty)(node.elseBody.sentences) ? undefined : (0, helpers_1.valueFor)((0, extensions_1.last)(node.elseBody.sentences));
    const nextSentence = node.parent.children[node.parent.children.indexOf(node) + 1];
    return (thenValue === undefined ||
        elseValue === undefined ||
        ![true, false].includes(thenValue) ||
        thenValue === elseValue) && (!nextSentence ||
        ![true, false].includes((0, helpers_1.valueFor)(nextSentence)));
});
exports.shouldHaveAssertInTest = warning(node => !node.body.isEmpty() || (0, helpers_1.sendsMessageToAssert)(node.body), undefined, sourceMaps_1.sourceMapForBody);
exports.shouldMatchFileExtension = error(node => {
    const filename = node.sourceFileName;
    if (!filename)
        return true;
    return (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Test)(_ => filename.endsWith(constants_1.TEST_FILE_EXTENSION)), (0, extensions_1.when)(model_1.Program)(_ => filename.endsWith(constants_1.PROGRAM_FILE_EXTENSION)));
});
exports.shouldImplementAllMethodsInHierarchy = error(node => (0, helpers_1.methodsCallingToSuper)(node).every((0, helpers_1.methodIsImplementedInSuperclass)(node)), node => [
    (0, helpers_1.methodsCallingToSuper)(node)
        .filter(method => !(0, helpers_1.methodIsImplementedInSuperclass)(node)(method))
        .map(method => method.name)
        .join(', '),
], sourceMaps_1.sourceMapForNodeNameOrFullNode);
exports.getterMethodShouldReturnAValue = warning(node => !(0, helpers_1.isGetter)(node) || node.isSynthetic || node.isNative() || node.isAbstract() || node.sentences.some(helpers_1.returnsAValue), undefined, sourceMaps_1.sourceMapForBody);
exports.shouldNotUseReservedWords = warning(node => !(0, helpers_1.usesReservedWords)(node), values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldInitializeGlobalReference = error(node => !(node.isAtPackageLevel && (0, helpers_1.isUninitialized)(node)), values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldNotDefineUnusedVariables = warning(node => !(0, helpers_1.unusedVariable)(node), values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldInitializeConst = error(node => {
    var _a;
    return !(((_a = (0, helpers_1.getContainer)(node)) === null || _a === void 0 ? void 0 : _a.is(model_1.Program)) &&
        node.isConstant &&
        (0, helpers_1.isUninitialized)(node));
}, values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldNotDuplicatePackageName = error(node => !node.siblings().some(sibling => sibling.is(model_1.Package) && sibling.name == node.name && sibling.sourceFileName == node.sourceFileName), values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldNotUseSpecialCharactersInName = error(node => !node.fileName ||
    node.fileName.match(/([A-Za-z.\-_/\d])/g).length === node.fileName.length
        && node.fileName.match(/\./g).length === 1, values_1.valuesForFileName, sourceMaps_1.sourceMapForNodeName);
exports.shouldCatchUsingExceptionHierarchy = error(node => {
    const EXCEPTION_CLASS = node.environment.getNodeByFQN(constants_1.EXCEPTION_MODULE);
    const exceptionType = node.parameterType.target;
    return !exceptionType || (exceptionType === null || exceptionType === void 0 ? void 0 : exceptionType.inherits(EXCEPTION_CLASS));
});
exports.catchShouldBeReachable = error(node => {
    const previousSiblings = node.parent.children.slice(0, node.parent.children.indexOf(node));
    const exceptionType = node.parameterType.target;
    return !exceptionType || (0, extensions_1.isEmpty)(previousSiblings) || !previousSiblings.some(sibling => {
        if (!sibling.is(model_1.Catch))
            return false;
        const siblingType = sibling.parameterType.target;
        return !siblingType || exceptionType === siblingType || exceptionType.inherits(siblingType);
    });
});
exports.shouldNotDuplicateEntities = error(node => !node.name || !node.parent.is(model_1.Package) || node.parent.imports.every(importFile => !(0, helpers_1.entityIsAlreadyUsedInImport)(importFile.entity.target, node.name)), values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldNotImportSameFile = error(node => [constants_1.TEST_FILE_EXTENSION, constants_1.PROGRAM_FILE_EXTENSION].some(allowedExtension => { var _a; return (_a = node.parent.fileName) === null || _a === void 0 ? void 0 : _a.endsWith(allowedExtension); }) || node.entity.target !== node.parent);
exports.shouldNotUseVoidSingleton = error(node => {
    const isVoid = (value) => !!value && value.is(model_1.Reference) && value.name === 'void';
    return !isVoid(node);
}, values_1.valuesForNodeName, (node) => node.is(model_1.Method) ? (0, sourceMaps_1.sourceMapForReturnValue)(node) : (0, sourceMaps_1.sourceMapForValue)(node));
exports.shouldNotImportMoreThanOnce = warning(node => !node.parent.is(model_1.Package) || node.parent.imports.filter(importFile => importFile !== node).every(importFile => !(0, helpers_1.isAlreadyUsedInImport)(importFile.entity.target, node.entity.target)));
exports.shouldDefineConstInsteadOfVar = warning(node => {
    if (node.isConstant || (0, helpers_1.usesReservedWords)(node) || RESERVED_WORDS.includes(node.name || '') || node.is(model_1.Field) && (0, helpers_1.unusedVariable)(node) || node.is(model_1.Variable) && (0, helpers_1.duplicatesLocalVariable)(node))
        return true;
    const container = (0, helpers_1.getContainer)(node);
    return !container || (0, helpers_1.assignsVariable)(container, node);
}, values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldNotUseVoidMethodAsValue = error(node => {
    if (!(0, helpers_1.methodExists)(node) || !(0, helpers_1.supposedToReturnValue)(node))
        return true;
    const method = (0, helpers_1.findMethod)(node);
    return !method || method.isNative() || method.isAbstract() || (0, helpers_1.returnsAValue)(method);
});
exports.shouldNotAssignValueInLoop = error(node => !(0, helpers_1.loopInAssignment)(node.value, node.name));
exports.shouldHaveDifferentName = error(node => {
    const tests = (0, extensions_1.match)(node.parent)((0, extensions_1.when)(model_1.Describe)(describe => describe.tests), (0, extensions_1.when)(model_1.Package)(module => module.members.filter(member => member.is(model_1.Test))), (0, extensions_1.otherwise)(_ => []));
    return !tests || tests.every(other => node === other || other.name !== node.name);
}, values_1.valuesForNodeName, sourceMaps_1.sourceMapForNodeName);
exports.shouldNotRedefineIdentity = error(node => {
    return !(node.name === '===' && node.parameters.length === 1 && node.isOverride && !node.isNative());
}, undefined, sourceMaps_1.sourceMapForNodeName);
const validationsByKind = (node) => (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Parameter)(() => ({ nameShouldBeginWithLowercase: exports.nameShouldBeginWithLowercase, nameShouldNotBeKeyword: exports.nameShouldNotBeKeyword, parameterShouldNotDuplicateExistingVariable: exports.parameterShouldNotDuplicateExistingVariable, shouldNotUseReservedWords: exports.shouldNotUseReservedWords })), (0, extensions_1.when)(model_1.NamedArgument)(() => ({ namedArgumentShouldExist: exports.namedArgumentShouldExist, namedArgumentShouldNotAppearMoreThanOnce: exports.namedArgumentShouldNotAppearMoreThanOnce })), (0, extensions_1.when)(model_1.Import)(() => ({ shouldNotImportSameFile: exports.shouldNotImportSameFile, shouldNotImportMoreThanOnce: exports.shouldNotImportMoreThanOnce })), (0, extensions_1.when)(model_1.Body)(() => ({ shouldNotBeEmpty: exports.shouldNotBeEmpty })), (0, extensions_1.when)(model_1.Catch)(() => ({ shouldCatchUsingExceptionHierarchy: exports.shouldCatchUsingExceptionHierarchy, catchShouldBeReachable: exports.catchShouldBeReachable })), (0, extensions_1.when)(model_1.Package)(() => ({ shouldNotDuplicatePackageName: exports.shouldNotDuplicatePackageName, shouldNotUseSpecialCharactersInName: exports.shouldNotUseSpecialCharactersInName })), (0, extensions_1.when)(model_1.Program)(() => ({ nameShouldNotBeKeyword: exports.nameShouldNotBeKeyword, shouldNotUseReservedWords: exports.shouldNotUseReservedWords, shouldMatchFileExtension: exports.shouldMatchFileExtension, shouldNotDuplicateEntities: exports.shouldNotDuplicateEntities })), (0, extensions_1.when)(model_1.Test)(() => ({ shouldHaveNonEmptyName: exports.shouldHaveNonEmptyName, shouldNotMarkMoreThanOneOnlyTest: exports.shouldNotMarkMoreThanOneOnlyTest, shouldHaveAssertInTest: exports.shouldHaveAssertInTest, shouldMatchFileExtension: exports.shouldMatchFileExtension, shouldHaveDifferentName: exports.shouldHaveDifferentName })), (0, extensions_1.when)(model_1.Class)(() => ({ nameShouldBeginWithUppercase: exports.nameShouldBeginWithUppercase, nameShouldNotBeKeyword: exports.nameShouldNotBeKeyword, shouldNotHaveLoopInHierarchy: exports.shouldNotHaveLoopInHierarchy, linearizationShouldNotRepeatNamedArguments: exports.linearizationShouldNotRepeatNamedArguments, shouldNotDefineMoreThanOneSuperclass: exports.shouldNotDefineMoreThanOneSuperclass, superclassShouldBeLastInLinearization: exports.superclassShouldBeLastInLinearization, shouldNotDuplicateGlobalDefinitions: exports.shouldNotDuplicateGlobalDefinitions, shouldNotDuplicateVariablesInLinearization: exports.shouldNotDuplicateVariablesInLinearization, shouldImplementAllMethodsInHierarchy: exports.shouldImplementAllMethodsInHierarchy, shouldNotUseReservedWords: exports.shouldNotUseReservedWords, shouldNotDuplicateEntities: exports.shouldNotDuplicateEntities })), (0, extensions_1.when)(model_1.Singleton)(() => ({ nameShouldBeginWithLowercase: exports.nameShouldBeginWithLowercase, inlineSingletonShouldBeAnonymous: exports.inlineSingletonShouldBeAnonymous, topLevelSingletonShouldHaveAName: exports.topLevelSingletonShouldHaveAName, nameShouldNotBeKeyword: exports.nameShouldNotBeKeyword, shouldInitializeInheritedAttributes: exports.shouldInitializeInheritedAttributes, linearizationShouldNotRepeatNamedArguments: exports.linearizationShouldNotRepeatNamedArguments, shouldNotDefineMoreThanOneSuperclass: exports.shouldNotDefineMoreThanOneSuperclass, superclassShouldBeLastInLinearization: exports.superclassShouldBeLastInLinearization, shouldNotDuplicateGlobalDefinitions: exports.shouldNotDuplicateGlobalDefinitions, shouldNotDuplicateVariablesInLinearization: exports.shouldNotDuplicateVariablesInLinearization, shouldImplementInheritedAbstractMethods: exports.shouldImplementInheritedAbstractMethods, shouldImplementAllMethodsInHierarchy: exports.shouldImplementAllMethodsInHierarchy, shouldNotUseReservedWords: exports.shouldNotUseReservedWords, shouldNotDuplicateEntities: exports.shouldNotDuplicateEntities })), (0, extensions_1.when)(model_1.Mixin)(() => ({ nameShouldBeginWithUppercase: exports.nameShouldBeginWithUppercase, shouldNotHaveLoopInHierarchy: exports.shouldNotHaveLoopInHierarchy, shouldOnlyInheritFromMixin: exports.shouldOnlyInheritFromMixin, shouldNotDuplicateGlobalDefinitions: exports.shouldNotDuplicateGlobalDefinitions, shouldNotDuplicateVariablesInLinearization: exports.shouldNotDuplicateVariablesInLinearization, shouldNotDuplicateEntities: exports.shouldNotDuplicateEntities })), (0, extensions_1.when)(model_1.Field)(() => ({ nameShouldBeginWithLowercase: exports.nameShouldBeginWithLowercase, shouldNotAssignToItselfInDeclaration: exports.shouldNotAssignToItselfInDeclaration, nameShouldNotBeKeyword: exports.nameShouldNotBeKeyword, shouldNotDuplicateFields: exports.shouldNotDuplicateFields, shouldNotUseReservedWords: exports.shouldNotUseReservedWords, shouldNotDefineUnusedVariables: exports.shouldNotDefineUnusedVariables, shouldDefineConstInsteadOfVar: exports.shouldDefineConstInsteadOfVar, shouldInitializeSingletonAttribute: exports.shouldInitializeSingletonAttribute, shouldNotAssignValueInLoop: exports.shouldNotAssignValueInLoop })), (0, extensions_1.when)(model_1.Method)(() => ({ onlyLastParameterCanBeVarArg: exports.onlyLastParameterCanBeVarArg, nameShouldNotBeKeyword: exports.nameShouldNotBeKeyword, methodShouldHaveDifferentSignature: exports.methodShouldHaveDifferentSignature, shouldNotOnlyCallToSuper: exports.shouldNotOnlyCallToSuper, shouldUseOverrideKeyword: exports.shouldUseOverrideKeyword, possiblyReturningBlock: exports.possiblyReturningBlock, shouldNotUseOverride: exports.shouldNotUseOverride, shouldMatchSuperclassReturnValue: exports.shouldMatchSuperclassReturnValue, shouldNotDefineNativeMethodsOnUnnamedSingleton: exports.shouldNotDefineNativeMethodsOnUnnamedSingleton, overridingMethodShouldHaveABody: exports.overridingMethodShouldHaveABody, getterMethodShouldReturnAValue: exports.getterMethodShouldReturnAValue, shouldHaveBody: exports.shouldHaveBody, shouldNotRedefineIdentity: exports.shouldNotRedefineIdentity })), (0, extensions_1.when)(model_1.Variable)(() => ({ nameShouldBeginWithLowercase: exports.nameShouldBeginWithLowercase, nameShouldNotBeKeyword: exports.nameShouldNotBeKeyword, shouldNotAssignToItselfInDeclaration: exports.shouldNotAssignToItselfInDeclaration, shouldNotDuplicateLocalVariables: exports.shouldNotDuplicateLocalVariables, shouldNotDuplicateGlobalDefinitions: exports.shouldNotDuplicateGlobalDefinitions, shouldNotDefineGlobalMutableVariables: exports.shouldNotDefineGlobalMutableVariables, shouldNotUseReservedWords: exports.shouldNotUseReservedWords, shouldInitializeGlobalReference: exports.shouldInitializeGlobalReference, shouldDefineConstInsteadOfVar: exports.shouldDefineConstInsteadOfVar, shouldNotDuplicateEntities: exports.shouldNotDuplicateEntities, shouldInitializeConst: exports.shouldInitializeConst })), (0, extensions_1.when)(model_1.Assignment)(() => ({ shouldNotAssignToItself: exports.shouldNotAssignToItself, shouldNotReassignConst: exports.shouldNotReassignConst })), (0, extensions_1.when)(model_1.Reference)(() => ({ missingReference: exports.missingReference, shouldUseSelfAndNotSingletonReference: exports.shouldUseSelfAndNotSingletonReference, shouldReferenceToObjects: exports.shouldReferenceToObjects, shouldNotUseVoidSingleton: exports.shouldNotUseVoidSingleton })), (0, extensions_1.when)(model_1.Self)(() => ({ shouldNotUseSelf: exports.shouldNotUseSelf })), (0, extensions_1.when)(model_1.New)(() => ({ shouldNotInstantiateAbstractClass: exports.shouldNotInstantiateAbstractClass, shouldPassValuesToAllAttributes: exports.shouldPassValuesToAllAttributes })), (0, extensions_1.when)(model_1.Send)(() => ({ shouldNotCompareAgainstBooleanLiterals: exports.shouldNotCompareAgainstBooleanLiterals, shouldNotCompareEqualityOfSingleton: exports.shouldNotCompareEqualityOfSingleton, shouldUseBooleanValueInLogicOperation: exports.shouldUseBooleanValueInLogicOperation, methodShouldExist: exports.methodShouldExist, codeShouldBeReachable: exports.codeShouldBeReachable, shouldNotDefineUnnecessaryCondition: exports.shouldNotDefineUnnecessaryCondition, shouldNotUseVoidMethodAsValue: exports.shouldNotUseVoidMethodAsValue })), (0, extensions_1.when)(model_1.Super)(() => ({ shouldUseSuperOnlyOnOverridingMethod: exports.shouldUseSuperOnlyOnOverridingMethod })), (0, extensions_1.when)(model_1.If)(() => ({ shouldReturnAValueOnAllFlows: exports.shouldReturnAValueOnAllFlows, shouldUseBooleanValueInIfCondition: exports.shouldUseBooleanValueInIfCondition, shouldNotDefineUnnecesaryIf: exports.shouldNotDefineUnnecesaryIf, codeShouldBeReachable: exports.codeShouldBeReachable, shouldNotDefineUnnecessaryCondition: exports.shouldNotDefineUnnecessaryCondition, shouldUseConditionalExpression: exports.shouldUseConditionalExpression })), (0, extensions_1.when)(model_1.Try)(() => ({ shouldHaveCatchOrAlways: exports.shouldHaveCatchOrAlways })), (0, extensions_1.when)(model_1.Describe)(() => ({ shouldNotDuplicateGlobalDefinitions: exports.shouldNotDuplicateGlobalDefinitions, shouldNotDefineEmptyDescribe: exports.shouldNotDefineEmptyDescribe, shouldHaveNonEmptyName: exports.shouldHaveNonEmptyName })), (0, extensions_1.otherwise)(() => ({})));
exports.default = (target) => target.reduce((found, node) => {
    var _a, _b;
    return [
        ...found,
        ...(_b = (_a = node.problems) === null || _a === void 0 ? void 0 : _a.map(({ code, sourceMap, level, values }) => ({ code, level, node, values, sourceMap: sourceMap !== null && sourceMap !== void 0 ? sourceMap : node.sourceMap }))) !== null && _b !== void 0 ? _b : [],
        ...entries(validationsByKind(node))
            .map(([code, validation]) => validation(node, code))
            .filter(result => result !== null),
    ];
}, []);
//# sourceMappingURL=index.js.map