import { Environment, Method, Module, Name, Node, Sentence } from '../model';
import { Evaluation, Execution, ExecutionDefinition, Frame, Natives, RuntimeObject, RuntimeValue, WollokException } from './runtimeModel';
export declare const interpret: (environment: Environment, natives: Natives) => Interpreter;
type InterpreterResult<This, T> = This extends Interpreter ? T : ExecutionDirector<T>;
declare abstract class AbstractInterpreter {
    readonly evaluation: Evaluation;
    constructor(evaluation: Evaluation);
    abstract fork(): this;
    abstract do<T>(executionDefinition: ExecutionDefinition<T>): any;
    object(fullyQualifiedName: Name): RuntimeObject;
    exec(node: Sentence): InterpreterResult<this, RuntimeValue>;
    exec(node: Node): InterpreterResult<this, void>;
    run(programOrTestFQN: Name): InterpreterResult<this, void>;
    send(message: Name, receiver: RuntimeObject, ...args: RuntimeObject[]): InterpreterResult<this, RuntimeValue>;
    invoke(method: Method, receiver: RuntimeObject, ...args: RuntimeObject[]): InterpreterResult<this, RuntimeValue>;
    reify(value: boolean | number | string | null): InterpreterResult<this, RuntimeObject>;
    list(...value: RuntimeObject[]): InterpreterResult<this, RuntimeObject>;
    set(...value: RuntimeObject[]): InterpreterResult<this, RuntimeObject>;
    error(moduleOrFQN: Module | Name, locals?: Record<Name, RuntimeObject>, error?: Error): InterpreterResult<this, RuntimeObject>;
    instantiate(moduleOrFQN: Module | Name, locals?: Record<Name, RuntimeObject>): InterpreterResult<this, RuntimeObject>;
}
export type ExecutionResult = {
    result: string;
    error?: Error;
    errored: boolean;
};
export declare const getStackTraceSanitized: (e?: Error) => string[];
export declare class Interpreter extends AbstractInterpreter {
    constructor(evaluation: Evaluation);
    fork(): this;
    do<T>(executionDefinition: ExecutionDefinition<T>): T;
}
export declare function interprete(interpreter: AbstractInterpreter, line: string, frame?: Frame): ExecutionResult;
export declare class DirectedInterpreter extends AbstractInterpreter {
    constructor(evaluation: Evaluation);
    fork(): this;
    do<T>(executionDefinition: ExecutionDefinition<T>): ExecutionDirector<T>;
}
export declare const executionFor: (environment: Environment, natives?: Natives) => DirectedInterpreter;
export declare class ExecutionDirector<T> {
    protected readonly evaluation: Evaluation;
    protected readonly execution: Execution<T>;
    readonly breakpoints: Node[];
    constructor(evaluation: Evaluation, execution: ExecutionDefinition<T>);
    addBreakpoint(breakpoint: Node): void;
    removeBreakpoint(breakpoint: Node): void;
    finish(): ExecutionState<T> & {
        done: true;
    };
    resume(shouldHalt?: (next: Node, evaluation: Evaluation) => boolean): ExecutionState<T>;
    stepIn(): ExecutionState<T>;
    stepOut(): ExecutionState<T>;
    stepOver(): ExecutionState<T>;
    stepThrough(): ExecutionState<T>;
}
export type ExecutionState<T> = Readonly<{
    done: false;
    next: Node;
    error?: undefined;
} | {
    done: true;
    error: WollokException;
} | {
    done: true;
    result: T;
    error?: undefined;
}>;
export {};
