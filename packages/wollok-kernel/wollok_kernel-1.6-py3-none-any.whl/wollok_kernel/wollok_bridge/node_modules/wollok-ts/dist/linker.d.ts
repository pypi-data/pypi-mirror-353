import { List } from './extensions';
import { BaseProblem, Environment, Field, Level, Name, Node, Package, Parameter, Scope, Sentence, SourceMap } from './model';
export declare const GLOBAL_PACKAGES: string[];
export declare class LinkError implements BaseProblem {
    code: Name;
    constructor(code: Name);
    get level(): Level;
    get values(): List<string>;
    get sourceMap(): SourceMap | undefined;
}
export declare class LocalScope implements Scope {
    containerScope?: Scope | undefined;
    protected contributions: Map<string, Node>;
    protected includedScopes: Scope[];
    constructor(containerScope?: Scope | undefined, ...contributions: [Name, Node][]);
    resolve<N extends Node>(qualifiedName: Name, allowLookup?: boolean): N | undefined;
    resolveAll<N extends Node>(qualifiedName: Name): List<N>;
    register(...contributions: [Name, Node][]): void;
    include(...others: Scope[]): void;
    localContributions(): [Name, Node][];
    localEntities(): Node[];
}
export declare const scopeContribution: (contributor: Node) => List<[Name, Node]>;
export declare const assignScopes: (root: Node) => void;
export declare const canBeReferenced: (node: Node) => node is ({
    "__#1@#isEntity": any;
    readonly name?: string | undefined;
    readonly label: string;
    readonly fullyQualifiedName: string;
    readonly isBaseWollokCode: boolean;
    readonly kind: string;
    readonly id: string;
    readonly scope: Scope;
    readonly sourceMap?: SourceMap | undefined;
    readonly problems?: List<BaseProblem> | undefined;
    readonly metadata: List<import("./model").Annotation>;
    environment: Environment;
    parent: Node;
    readonly categories: Function[];
    readonly sourceFileName: string | undefined;
    readonly sourceInfo: string;
    readonly isSynthetic: boolean;
    readonly hasProblems: boolean;
    readonly type: import("./typeSystem/wollokTypes").WollokType;
    readonly parentPackage: Package | undefined;
    toString(verbose?: boolean): string;
    is<Q extends import("./extensions").TypeDefinition<Node>>(kindOrCategory: Q): this is InstanceType<import("./extensions").ConstructorFor<Q>>;
    copy(delta?: Record<string, unknown>): any;
    readonly children: List<Node>;
    siblings(): List<Node>;
    readonly descendants: List<Node>;
    readonly ancestors: List<Node>;
    transform(tx: (node: Node) => Node): any;
    forEach(tx: (node: Node, parent?: Node | undefined) => void): void;
    reduce<T>(tx: (acum: T, node: Node, parent?: Node | undefined) => T, initial: T): T;
} & Node) | Field | Parameter;
declare const _default: (newPackages: List<Package>, baseEnvironment?: Environment) => Environment;
export default _default;
export declare function linkSentenceInNode<S extends Sentence>(newSentence: S, context: Node): void;
