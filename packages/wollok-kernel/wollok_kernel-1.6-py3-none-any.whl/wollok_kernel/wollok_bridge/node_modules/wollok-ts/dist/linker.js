"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.linkSentenceInNode = exports.canBeReferenced = exports.assignScopes = exports.scopeContribution = exports.LocalScope = exports.LinkError = exports.GLOBAL_PACKAGES = void 0;
const uuid_1 = require("uuid");
const extensions_1 = require("./extensions");
const model_1 = require("./model");
const constants_1 = require("./constants");
const { assign } = Object;
exports.GLOBAL_PACKAGES = ['wollok.lang', 'wollok.lib', 'wollok.game'];
class LinkError {
    constructor(code) {
        this.code = code;
    }
    get level() { return 'error'; }
    get values() { return []; }
    get sourceMap() { return undefined; }
}
exports.LinkError = LinkError;
const mergePackage = (members, isolated) => {
    if (!isolated.is(model_1.Package))
        return [...members.filter(({ name }) => name !== isolated.name), isolated];
    const existent = members.find((member) => member.is(model_1.Package) && member.name === isolated.name && member.sourceFileName === isolated.sourceFileName);
    return existent
        ? [
            ...members.filter(member => member !== existent),
            existent.copy({
                members: [
                    ...isolated.members
                        .filter((0, extensions_1.is)(model_1.Package))
                        .reduce(mergePackage, existent.members.filter((0, extensions_1.is)(model_1.Package))),
                    ...isolated.members.filter(m => !m.is(model_1.Package)),
                ],
                problems: isolated.problems,
                imports: isolated.imports,
            }),
        ]
        : [...members, isolated];
};
class LocalScope {
    constructor(containerScope, ...contributions) {
        this.containerScope = containerScope;
        this.contributions = new Map();
        this.includedScopes = [];
        this.register(...contributions);
    }
    resolve(qualifiedName, allowLookup = true) {
        var _a, _b, _c;
        const [start, rest] = (0, extensions_1.divideOn)('.')(qualifiedName);
        const step = !allowLookup
            ? this.contributions.get(start)
            : (_a = this.includedScopes.reduce((found, included) => found !== null && found !== void 0 ? found : included.resolve(start, false), this.contributions.get(start))) !== null && _a !== void 0 ? _a : (_b = this.containerScope) === null || _b === void 0 ? void 0 : _b.resolve(start, allowLookup);
        return rest.length ? (_c = step === null || step === void 0 ? void 0 : step.scope) === null || _c === void 0 ? void 0 : _c.resolve(rest, false) : step;
    }
    resolveAll(qualifiedName) {
        const step = this.resolve(qualifiedName, false);
        const rest = Array.from(this.contributions.values())
            .filter((0, extensions_1.is)(model_1.Package))
            .flatMap(pkg => pkg.scope.resolveAll(qualifiedName))
            .filter(node => step !== node);
        return rest.concat(step ? [step] : []);
    }
    register(...contributions) {
        const shouldBeOverrided = (older, newer) => older.is(model_1.Package) && newer.is(model_1.Package) && !newer.isTestFile;
        for (const [name, node] of contributions) {
            const alreadyRegistered = this.contributions.get(name);
            if (!alreadyRegistered || shouldBeOverrided(alreadyRegistered, node)) {
                this.contributions.set(name, node);
            }
        }
    }
    include(...others) { this.includedScopes.push(...others); }
    localContributions() { return [...this.contributions.entries()]; }
    localEntities() { return [...this.contributions.values()]; }
}
exports.LocalScope = LocalScope;
const scopeContribution = (contributor) => (0, exports.canBeReferenced)(contributor) && contributor.name ? [[contributor.name, contributor]] : [];
exports.scopeContribution = scopeContribution;
const assignScopes = (root) => {
    root.forEach((node, parent) => {
        var _a;
        const containerScope = node.is(model_1.Import) || node.is(model_1.Reference) && parent.is(model_1.ParameterizedType)
            ? parent === null || parent === void 0 ? void 0 : parent.parent.scope
            : parent === null || parent === void 0 ? void 0 : parent.scope;
        assign(node, { scope: new LocalScope(containerScope) });
        (_a = parent === null || parent === void 0 ? void 0 : parent.scope) === null || _a === void 0 ? void 0 : _a.register(...(0, exports.scopeContribution)(node));
    });
    root.forEach((node, _parent) => {
        if (node.is(model_1.Environment)) {
            for (const globalName of exports.GLOBAL_PACKAGES) {
                const globalPackage = root.scope.resolve(globalName);
                if (globalPackage)
                    node.scope.register(...globalPackage.members.flatMap(exports.scopeContribution));
            }
        }
        if (node.is(model_1.Package)) {
            for (const importNode of node.imports) {
                const entity = importNode.scope.resolve(importNode.entity.name);
                if (!entity)
                    break;
                const contributions = importNode.isGeneric
                    ? entity.is(model_1.Package) && entity.isImportable ? entity.scope.localContributions() : []
                    : [[entity.name, entity]];
                node.scope.include(new LocalScope(undefined, ...contributions));
            }
        }
    });
    root.forEach((node, _parent) => {
        if (node.is(model_1.Module)) {
            node.scope.include(...node.hierarchy.slice(1).map(supertype => supertype.scope));
        }
    });
};
exports.assignScopes = assignScopes;
const canBeReferenced = (node) => node.is(model_1.Entity) || node.is(model_1.Field) || node.is(model_1.Parameter) || node.is(model_1.Variable);
exports.canBeReferenced = canBeReferenced;
exports.default = (newPackages, baseEnvironment) => {
    var _a;
    const environment = new model_1.Environment({
        id: (0, uuid_1.v4)(),
        scope: undefined,
        members: newPackages.reduce(mergePackage, (_a = baseEnvironment === null || baseEnvironment === void 0 ? void 0 : baseEnvironment.members) !== null && _a !== void 0 ? _a : [new model_1.Package({ name: constants_1.REPL })]),
    }).transform(node => node.copy({ id: (0, uuid_1.v4)() }));
    const nodeCache = new Map();
    environment.forEach((node, parent) => {
        nodeCache.set(node.id, node);
        node.environment = environment;
        if (parent)
            node.parent = parent;
    });
    assign(environment, { nodeCache });
    (0, exports.assignScopes)(environment);
    return environment;
};
function linkSentenceInNode(newSentence, context) {
    const { environment } = context;
    const _nodeCache = environment.nodeCache;
    newSentence.forEach((node, parent) => {
        const id = (0, uuid_1.v4)();
        assign(node, { id });
        _nodeCache.set(id, node);
        node.environment = environment;
        node.parent = parent !== null && parent !== void 0 ? parent : context;
    });
    (0, exports.assignScopes)(newSentence);
}
exports.linkSentenceInNode = linkSentenceInNode;
//# sourceMappingURL=linker.js.map