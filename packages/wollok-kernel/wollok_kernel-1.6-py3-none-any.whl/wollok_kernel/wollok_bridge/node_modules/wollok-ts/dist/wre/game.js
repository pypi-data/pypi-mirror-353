"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const runtimeModel_1 = require("../interpreter/runtimeModel");
const { round } = Math;
const getter = (message) => function* (obj) {
    const method = obj.module.lookupMethod(message, 0);
    return method.isSynthetic ? obj.get(message) : yield* this.invoke(method, obj);
};
const getPosition = getter('position');
const getX = getter('x');
const getY = getter('y');
const getObjectsIn = function* (position, ...visuals) {
    var _a, _b, _c, _d;
    const result = [];
    const x = (_a = (yield* getX.call(this, position))) === null || _a === void 0 ? void 0 : _a.innerNumber;
    const y = (_b = (yield* getY.call(this, position))) === null || _b === void 0 ? void 0 : _b.innerNumber;
    if (x == undefined || y == undefined)
        throw new RangeError('Position without coordinates');
    const roundedX = round(x);
    const roundedY = round(y);
    for (const visual of visuals) {
        const otherPosition = (yield* getPosition.call(this, visual));
        const otherX = (_c = (yield* getX.call(this, otherPosition))) === null || _c === void 0 ? void 0 : _c.innerNumber;
        const otherY = (_d = (yield* getY.call(this, otherPosition))) === null || _d === void 0 ? void 0 : _d.innerNumber;
        if (otherX == undefined || otherY == undefined)
            continue;
        if (roundedX == round(otherX) && roundedY == round(otherY))
            result.push(visual);
    }
    return yield* this.list(...result);
};
const game = {
    game: {
        *addVisual(self, positionable) {
            (0, runtimeModel_1.assertIsNotNull)(positionable, 'addVisual', 'positionable');
            if (!positionable.module.lookupMethod('position', 0))
                throw new TypeError('Message addVisual: positionable lacks a position message');
            const visuals = self.get('visuals').innerCollection;
            if (visuals.includes(positionable))
                throw new RangeError('Visual is already in the game! You cannot add duplicate elements');
            visuals.push(positionable);
        },
        *removeVisual(self, visual) {
            const visuals = self.get('visuals');
            yield* this.send('remove', visuals, visual);
        },
        *allVisuals(self) {
            var _a;
            const visuals = self.get('visuals');
            return yield* this.list(...(_a = visuals.innerCollection) !== null && _a !== void 0 ? _a : []);
        },
        *hasVisual(self, visual) {
            const visuals = self.get('visuals');
            return yield* this.send('contains', visuals, visual);
        },
        *getObjectsIn(self, position) {
            const visuals = self.get('visuals');
            return yield* getObjectsIn.call(this, position, ...visuals.innerCollection);
        },
        *say(self, visual, message) {
            const currentTime = (yield* this.send('currentTime', self)).innerNumber;
            const MESSAGE_SAY_TIME = 2000;
            const messageTime = yield* this.reify(currentTime + MESSAGE_SAY_TIME);
            visual.set('message', message);
            visual.set('messageTime', messageTime);
        },
        *colliders(self, visual) {
            (0, runtimeModel_1.assertIsNotNull)(visual, 'colliders', 'visual');
            const visuals = self.get('visuals');
            const otherVisuals = visuals.innerCollection.filter(obj => obj != visual);
            const position = (yield* getPosition.call(this, visual));
            return yield* getObjectsIn.call(this, position, ...otherVisuals);
        },
        *title(self, title) {
            if (!title)
                return self.get('title');
            self.set('title', title);
        },
        *width(self, width) {
            if (!width)
                return self.get('width');
            self.set('width', width);
        },
        *height(self, height) {
            if (!height)
                return self.get('height');
            self.set('height', height);
        },
        *ground(self, image) {
            self.set('ground', image);
        },
        *boardGround(self, boardGround) {
            self.set('boardGround', boardGround);
        },
        *doCellSize(self, size) {
            self.set('cellSize', size);
        },
        *showAttributes(_self, visual) {
            visual.set('showAttributes', yield* this.reify(true));
        },
        *hideAttributes(_self, visual) {
            visual.set('showAttributes', yield* this.reify(false));
        },
    },
    Sound: {
        *play(self) {
            var _a;
            const game = this.object(constants_1.GAME_MODULE);
            const sounds = (_a = game.get('sounds')) === null || _a === void 0 ? void 0 : _a.innerCollection;
            if (!sounds)
                game.set('sounds', yield* this.list(self));
            else {
                if (sounds.includes(self))
                    throw new RangeError('Sound is already in the game! You cannot add duplicate elements');
                else
                    sounds.push(self);
            }
            self.set('status', this.reify('played'));
        },
        *stop(self) {
            var _a;
            if (((_a = self.get('status')) === null || _a === void 0 ? void 0 : _a.innerString) !== 'played')
                throw new Error('You cannot stop a sound that is not played');
            const game = this.object(constants_1.GAME_MODULE);
            const sounds = game.get('sounds');
            if (sounds)
                yield* this.send('remove', sounds, self);
            self.set('status', yield* this.reify('stopped'));
        },
        *pause(self) {
            var _a;
            if (((_a = self.get('status')) === null || _a === void 0 ? void 0 : _a.innerString) !== 'played')
                throw new Error('You cannot pause a sound that is not played');
            self.set('status', this.reify('paused'));
        },
        *resume(self) {
            var _a;
            if (((_a = self.get('status')) === null || _a === void 0 ? void 0 : _a.innerString) !== 'paused')
                throw new Error('You cannot resume a sound that is not paused');
            self.set('status', this.reify('played'));
        },
        *played(self) {
            var _a;
            return yield* this.reify(((_a = self.get('status')) === null || _a === void 0 ? void 0 : _a.innerString) === 'played');
        },
        *paused(self) {
            var _a;
            return yield* this.reify(((_a = self.get('status')) === null || _a === void 0 ? void 0 : _a.innerString) === 'paused');
        },
        *volume(self, newVolume) {
            if (!newVolume)
                return self.get('volume');
            const volume = newVolume;
            (0, runtimeModel_1.assertIsNumber)(volume, 'volume', 'newVolume', false);
            if (volume.innerNumber < 0 || volume.innerNumber > 1)
                throw new RangeError('volumen: newVolume should be between 0 and 1');
            self.set('volume', volume);
        },
        *shouldLoop(self, looping) {
            if (!looping)
                return self.get('loop');
            self.set('loop', looping);
        },
    },
};
exports.default = game;
//# sourceMappingURL=game.js.map