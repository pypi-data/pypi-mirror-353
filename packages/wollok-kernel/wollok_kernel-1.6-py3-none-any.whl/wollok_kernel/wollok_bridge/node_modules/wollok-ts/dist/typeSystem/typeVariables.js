"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeForModule = exports.TypeVariable = exports.typeVariableFor = exports.newSyntheticTVar = exports.newTypeVariables = void 0;
const constants_1 = require("../constants");
const extensions_1 = require("../extensions");
const model_1 = require("../model");
const wollokTypes_1 = require("./wollokTypes");
const { assign } = Object;
const tVars = new Map();
function newTypeVariables(env) {
    tVars.clear();
    inferTypeVariables(env);
    return tVars;
}
exports.newTypeVariables = newTypeVariables;
function newSyntheticTVar(node) {
    var _a;
    return doNewTVarFor((_a = node === null || node === void 0 ? void 0 : node.copy()) !== null && _a !== void 0 ? _a : (0, model_1.Closure)({ code: 'Param type' }))
        .beSynthetic();
}
exports.newSyntheticTVar = newSyntheticTVar;
function typeVariableFor(node) {
    var _a;
    return (_a = tVars.get(node)) !== null && _a !== void 0 ? _a : newTVarFor(node);
}
exports.typeVariableFor = typeVariableFor;
function newTVarFor(node) {
    const newTVar = doNewTVarFor(node);
    let annotatedVar = newTVar;
    if (node.is(model_1.Method)) {
        const parameters = node.parameters.map(p => inferTypeVariables(p));
        annotatedVar = newSyntheticTVar(node);
        newTVar.setType(new wollokTypes_1.WollokMethodType(annotatedVar, parameters, annotatedVariableMap(node)), false);
    }
    if (node.is(model_1.Singleton) && node.isClosure()) {
        const methodApply = node.methods.find(_ => _.name === constants_1.CLOSURE_EVALUATE_METHOD);
        const parameters = methodApply.parameters.map(typeVariableFor);
        const returnType = typeVariableFor(methodApply).atParam(wollokTypes_1.RETURN);
        newTVar.setType(new wollokTypes_1.WollokClosureType(returnType, parameters, node), false);
    }
    const annotatedType = annotatedTypeName(node);
    if (annotatedType)
        annotatedVar.setType(annotatedWollokType(annotatedType, node), false);
    return newTVar;
}
function doNewTVarFor(node) {
    const newTVar = new TypeVariable(node);
    tVars.set(node, newTVar);
    return newTVar;
}
function inferTypeVariables(node) {
    return (0, extensions_1.match)(node)((0, extensions_1.when)(model_1.Environment)(inferEnvironment), (0, extensions_1.when)(model_1.Package)(inferPackage), (0, extensions_1.when)(model_1.Import)(skip), (0, extensions_1.when)(model_1.Program)(inferProgram), (0, extensions_1.when)(model_1.Body)(inferBody), (0, extensions_1.when)(model_1.Module)(inferModule), (0, extensions_1.when)(model_1.Describe)(inferModule), (0, extensions_1.when)(model_1.Send)(inferSend), (0, extensions_1.when)(model_1.Method)(inferMethod), (0, extensions_1.when)(model_1.Test)(inferTest), (0, extensions_1.when)(model_1.Parameter)(inferParameter), (0, extensions_1.when)(model_1.Return)(inferReturn), (0, extensions_1.when)(model_1.If)(inferIf), (0, extensions_1.when)(model_1.Assignment)(inferAssignment), (0, extensions_1.when)(model_1.Throw)(typeVariableFor), (0, extensions_1.when)(model_1.Try)(typeVariableFor), (0, extensions_1.when)(model_1.New)(inferNew), (0, extensions_1.when)(model_1.NamedArgument)(inferNamedArgument), (0, extensions_1.when)(model_1.Variable)(inferVariable), (0, extensions_1.when)(model_1.Field)(inferVariable), (0, extensions_1.when)(model_1.Reference)(inferReference), (0, extensions_1.when)(model_1.Literal)(inferLiteral), (0, extensions_1.when)(model_1.Self)(inferSelf), (0, extensions_1.when)(model_1.Super)(inferSelf), (0, extensions_1.otherwise)(skip));
}
const inferEnvironment = (env) => {
    env.children.forEach(inferTypeVariables);
};
const inferPackage = (p) => {
    p.children.forEach(inferTypeVariables);
};
const inferProgram = (p) => {
    inferTypeVariables(p.body);
};
const inferTest = (t) => {
    inferTypeVariables(t.body);
};
const inferBody = (body) => {
    body.sentences.forEach(inferTypeVariables);
};
const inferModule = (m) => {
    const tVar = typeVariableFor(m);
    m.members.forEach(inferTypeVariables);
    if (!(m.is(model_1.Singleton) && m.isClosure()))
        tVar.setType(typeForModule(m));
    return tVar;
};
const inferNew = (n) => {
    const clazz = n.instantiated.target;
    const tVar = typeVariableFor(n).setType(typeForModule(clazz));
    n.args.map(inferTypeVariables);
    return tVar;
};
const inferNamedArgument = (n) => {
    const valueTVar = inferTypeVariables(n.value);
    if (n.parent instanceof model_1.New) {
        const clazz = n.parent.instantiated.target;
        const field = clazz.lookupField(n.name);
        if (field) {
            const fieldTVar = typeVariableFor(field);
            const instanceTVar = typeVariableFor(n.parent);
            fieldTVar.instanceFor(instanceTVar).beSupertypeOf(valueTVar);
        }
    }
    return valueTVar;
};
const inferMethod = (m) => {
    var _a;
    const method = typeVariableFor(m);
    if ((_a = m.parentPackage) === null || _a === void 0 ? void 0 : _a.isBaseWollokCode)
        return;
    if (!m.isConcrete())
        return;
    m.sentences.forEach(inferTypeVariables);
    if (m.sentences.length) {
        const lastSentence = (0, extensions_1.last)(m.sentences);
        if (!lastSentence.is(model_1.Return) && !lastSentence.is(model_1.If)) {
            method.atParam(wollokTypes_1.RETURN).beSupertypeOf(typeVariableFor(lastSentence));
        }
    }
    else {
        method.atParam(wollokTypes_1.RETURN).setType(new wollokTypes_1.WollokAtomicType(wollokTypes_1.VOID));
    }
    return method;
};
const inferSend = (send) => {
    const tVar = typeVariableFor(send);
    const receiver = inferTypeVariables(send.receiver);
    send.args.map(inferTypeVariables);
    receiver.addSend(send);
    return tVar;
};
const inferAssignment = (a) => {
    const reference = inferTypeVariables(a.variable);
    const value = inferTypeVariables(a.value);
    reference.beSupertypeOf(value);
    if (a.variable.target) {
        const variable = typeVariableFor(a.variable.target);
        reference.beSubtypeOf(variable);
    }
    return typeVariableFor(a).setType(new wollokTypes_1.WollokAtomicType(wollokTypes_1.VOID));
};
const inferVariable = (v) => {
    const valueTVar = inferTypeVariables(v.value);
    const varTVar = typeVariableFor(v);
    if (valueTVar && !varTVar.closed)
        varTVar.beSupertypeOf(valueTVar);
    return varTVar;
};
const inferParameter = (p) => {
    return typeVariableFor(p);
};
const inferReturn = (r) => {
    const method = r.ancestors.find((0, extensions_1.is)(model_1.Method));
    if (!method)
        throw new Error('Method for Return not found');
    if (r.value)
        typeVariableFor(method).atParam(wollokTypes_1.RETURN).beSupertypeOf(inferTypeVariables(r.value));
    else
        typeVariableFor(method).atParam(wollokTypes_1.RETURN).setType(new wollokTypes_1.WollokAtomicType(wollokTypes_1.VOID));
    return typeVariableFor(r).setType(new wollokTypes_1.WollokAtomicType(wollokTypes_1.VOID));
};
const inferIf = (_if) => {
    inferTypeVariables(_if.condition).setType(new wollokTypes_1.WollokModuleType(_if.environment.booleanClass));
    inferTypeVariables(_if.thenBody);
    inferTypeVariables(_if.elseBody);
    if (_if.elseBody.sentences.length) {
        typeVariableFor(_if)
            .beSupertypeOf(typeVariableFor((0, extensions_1.last)(_if.elseBody.sentences)));
    }
    if (_if.thenBody.sentences.length) {
        return typeVariableFor(_if)
            .beSupertypeOf(typeVariableFor((0, extensions_1.last)(_if.thenBody.sentences)));
    }
};
const inferReference = (r) => {
    const referenceTVar = typeVariableFor(r);
    if (r.target) {
        const varTVar = typeVariableFor(r.target);
        referenceTVar.beSupertypeOf(varTVar);
    }
    return referenceTVar;
};
const inferSelf = (self) => {
    const module = self.ancestors.find((node) => node.is(model_1.Module) && !node.fullyQualifiedName.startsWith(constants_1.CLOSURE_MODULE));
    if (!module)
        throw new Error('Module for Self not found');
    return typeVariableFor(self).setType(new wollokTypes_1.WollokModuleType(module));
};
const inferLiteral = (l) => {
    const tVar = typeVariableFor(l);
    const { numberClass, stringClass, booleanClass } = l.environment;
    switch (typeof l.value) {
        case 'number': return tVar.setType(new wollokTypes_1.WollokModuleType(numberClass));
        case 'string': return tVar.setType(new wollokTypes_1.WollokModuleType(stringClass));
        case 'boolean': return tVar.setType(new wollokTypes_1.WollokModuleType(booleanClass));
        case 'object':
            if (Array.isArray(l.value))
                return tVar.setType(arrayLiteralType(l.value));
            if (l.isNull())
                return tVar;
    }
    throw new Error('Literal type not found');
};
const arrayLiteralType = (value) => {
    const arrayTVar = typeForModule(value[0].target);
    const elementTVar = arrayTVar.atParam(wollokTypes_1.ELEMENT);
    value[1].map(inferTypeVariables).forEach(inner => elementTVar.beSupertypeOf(inner));
    return arrayTVar;
};
const skip = (_) => { };
class TypeVariable {
    constructor(node) {
        this.typeInfo = new TypeInfo();
        this.subtypes = [];
        this.supertypes = [];
        this.messages = [];
        this.cachedParams = new Map();
        this.synthetic = false;
        this.hasProblems = false;
        this.node = node;
    }
    type() { return this.typeInfo.type(); }
    atParam(name) { return this.type().atParam(name); }
    newInstance(name) {
        var _a;
        return (_a = this.cachedParams.get(name)) !== null && _a !== void 0 ? _a : this.cachedParams.set(name, newSyntheticTVar(this.node)).get(name);
    }
    instanceFor(instance, send, name) { return this.type().instanceFor(instance, send, name) || this; }
    hasMinType(type) { return this.allMinTypes().some(_type => _type.contains(type)); }
    hasMaxType(type) { return this.allMaxTypes().some(_type => _type.contains(type)); }
    hasType(type) { return this.allPossibleTypes().some(_type => _type.contains(type)); }
    setType(type, closed) {
        this.typeInfo.setType(type, closed);
        return this;
    }
    addMinType(type) {
        this.typeInfo.addMinType(type);
    }
    addMaxType(type) {
        this.typeInfo.addMaxType(type);
    }
    beSubtypeOf(tVar) {
        this.addSupertype(tVar);
        tVar.addSubtype(this);
        return this;
    }
    beSupertypeOf(tVar) {
        this.addSubtype(tVar);
        tVar.addSupertype(this);
        return this;
    }
    unify(tVar) {
        this.beSupertypeOf(tVar);
        this.beSubtypeOf(tVar);
    }
    hasSubtype(tVar) {
        return this.subtypes.includes(tVar);
    }
    hasSupertype(tVar) {
        return this.supertypes.includes(tVar);
    }
    addSend(send) {
        this.messages.push(send);
    }
    hasSend(send) {
        return this.messages.includes(send);
    }
    allMinTypes() {
        return this.typeInfo.minTypes;
    }
    allMaxTypes() {
        return this.typeInfo.maxTypes;
    }
    allPossibleTypes() {
        return [...this.allMinTypes(), ...this.allMaxTypes()];
    }
    hasTypeInfered() {
        return this.allPossibleTypes().some(t => t.isComplete);
    }
    validSubtypes() {
        return this.subtypes.filter(tVar => !tVar.hasProblems);
    }
    validSupertypes() {
        return this.supertypes.filter(tVar => !tVar.hasProblems);
    }
    addSubtype(tVar) {
        this.subtypes.push(tVar);
    }
    addSupertype(tVar) {
        this.supertypes.push(tVar);
    }
    addProblem(problem) {
        var _a;
        assign(this.node, { problems: [...(_a = this.node.problems) !== null && _a !== void 0 ? _a : [], problem] });
        this.hasProblems = true;
    }
    beSynthetic() {
        this.synthetic = true;
        return this;
    }
    get closed() { return this.typeInfo.closed; }
    toString() { var _a; return `TVar(${this.synthetic ? 'SYNTEC' + ((_a = this.node) === null || _a === void 0 ? void 0 : _a.sourceInfo) : this.node})${this.typeInfo.closed ? ' [CLOSED]' : ''}`; }
}
exports.TypeVariable = TypeVariable;
class TypeInfo {
    constructor() {
        this.minTypes = [];
        this.maxTypes = [];
        this.closed = false;
    }
    type() {
        if (this.maxTypes.length + this.minTypes.length == 0)
            return new wollokTypes_1.WollokAtomicType(wollokTypes_1.ANY);
        if (this.maxTypes.length == 1)
            return this.maxTypes[0];
        if (this.minTypes.length == 1)
            return this.minTypes[0];
        if (this.minTypes.length > 1)
            return new wollokTypes_1.WollokUnionType(this.minTypes);
        if (this.maxTypes.length > 1)
            return new wollokTypes_1.WollokUnionType(this.maxTypes);
        throw new Error('Unracheable');
    }
    setType(type, closed = true) {
        this.minTypes = [type];
        this.maxTypes = [type];
        this.closed = closed;
    }
    addMinType(type) {
        if (this.minTypes.some(minType => minType.contains(type)))
            return;
        if (this.closed)
            throw new Error('Variable inference finalized');
        if (type instanceof wollokTypes_1.WollokParametricType && type.params.size) {
            const myType = this.minTypes.find((t) => t.kind == type.kind);
            if (myType)
                return myType.addMinType(type);
        }
        this.minTypes.push(type);
    }
    addMaxType(type) {
        if (this.maxTypes.some(maxType => maxType.contains(type)))
            return;
        if (this.minTypes.some(minType => minType.contains(type)))
            return;
        if (this.closed)
            throw new Error('Variable inference finalized');
        if (type instanceof wollokTypes_1.WollokParametricType && type.params.size) {
            const myType = this.maxTypes.find((t) => t.kind == type.kind);
            if (myType)
                return myType.addMaxType(type);
        }
        this.maxTypes.push(type);
    }
}
function typeAnnotation(node) {
    return node === null || node === void 0 ? void 0 : node.metadata.find(_ => _.name === 'Type');
}
function annotatedTypeName(node) {
    var _a;
    return (_a = typeAnnotation(node)) === null || _a === void 0 ? void 0 : _a.args['name'];
}
function annotatedVariableName(node) {
    var _a;
    return (_a = typeAnnotation(node)) === null || _a === void 0 ? void 0 : _a.args['variable'];
}
function annotatedWollokType(annotatedType, node) {
    if ([wollokTypes_1.VOID, wollokTypes_1.ANY].includes(annotatedType))
        return new wollokTypes_1.WollokAtomicType(annotatedType);
    if (annotatedType.startsWith('{') && annotatedType.endsWith('}')) {
        return parseAnnotatedClosure(annotatedType, node);
    }
    if (isParameterName(annotatedType, node)) {
        return new wollokTypes_1.WollokParameterType(annotatedType);
    }
    if (annotatedType.includes('<') && annotatedType.includes('>')) {
        return parseAnnotatedGeneric(annotatedType, node);
    }
    let module = node.environment.getNodeOrUndefinedByFQN(annotatedType);
    if (!module) {
        const p = node.ancestors.find((0, extensions_1.is)(model_1.Package));
        module = p.getNodeByQN(annotatedType);
    }
    return typeForModule(module);
}
function parseAnnotatedClosure(annotatedType, node) {
    const [params, returnTypeName] = annotatedType.slice(1, -1).split('=>');
    const parameters = params.trim().slice(1, -1).split(',').map(_ => _.trim()).filter(_ => _);
    const parametersTVar = parameters.map(_ => newSyntheticTVar(node).setType(annotatedWollokType(_, node)));
    const returnTypeTVar = newSyntheticTVar(node).setType(annotatedWollokType(returnTypeName.trim(), node));
    return new wollokTypes_1.WollokClosureType(returnTypeTVar, parametersTVar, (0, model_1.Closure)({ code: annotatedType }));
}
function parseAnnotatedGeneric(annotatedType, node) {
    const [baseTypeName] = annotatedType.split('<');
    const paramTypeNames = annotatedType.slice(baseTypeName.length + 1, -1).split(',').map(_ => _.trim());
    const baseType = annotatedWollokType(baseTypeName, node);
    const paramTypes = paramTypeNames.map(t => annotatedWollokType(t, node));
    [...baseType.params.values()].forEach((param, i) => param.setType(paramTypes[i]));
    return baseType;
}
function isParameterName(name, node) {
    return [node, ...node.ancestors].find(n => annotatedVariableName(n) === name);
}
function annotatedVariableMap(n) {
    const varName = annotatedVariableName(n);
    if (varName)
        return { [varName]: newSyntheticTVar(n) };
    return {};
}
function typeForModule(m) {
    const map = annotatedVariableMap(m);
    return new wollokTypes_1.WollokParametricType(m, map);
}
exports.typeForModule = typeForModule;
//# sourceMappingURL=typeVariables.js.map