"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Evaluation = exports.assertIsNotNull = exports.assertIsException = exports.assertIsCollection = exports.assertIsString = exports.assertIsBoolean = exports.assertIsNumber = exports.RuntimeObject = exports.Frame = exports.Context = exports.WollokException = exports.WollokReturn = void 0;
const uuid_1 = require("uuid");
const constants_1 = require("../constants");
const extensions_1 = require("../extensions");
const helpers_1 = require("../helpers");
const model_1 = require("../model");
const interpreter_1 = require("./interpreter");
const { isArray } = Array;
const { keys, entries } = Object;
const { isInteger } = Number;
const DECIMAL_PRECISION = 5;
class WollokReturn extends Error {
    static of(instance) {
        WollokReturn.instance._instance = instance;
        WollokReturn.instance.name = this.name;
        WollokReturn.instance.message = 'Unhandled return on empty stack';
        return WollokReturn.instance;
    }
    get instance() { return this._instance; }
    constructor() { super(); }
}
exports.WollokReturn = WollokReturn;
WollokReturn.instance = new WollokReturn();
class WollokException extends Error {
    get wollokStack() {
        try {
            const fullTrace = new interpreter_1.Interpreter(this.evaluation).send('getStackTraceAsString', this.instance).innerString;
            return fullTrace.slice(fullTrace.indexOf('\n') + 1).trimEnd();
        }
        catch (error) {
            return `Could not retrieve Wollok stack due to error: ${error instanceof Error ? error.stack : error}`;
        }
    }
    get message() {
        var _a, _b;
        const error = this.instance;
        assertIsException(error);
        const errorMessage = error.innerValue ? error.innerValue.message : (_b = (_a = error.get('message')) === null || _a === void 0 ? void 0 : _a.innerString) !== null && _b !== void 0 ? _b : '';
        return `${errorMessage}\n${this.wollokStack}\n     ${constants_1.WOLLOK_EXTRA_STACK_TRACE_HEADER}`;
    }
    constructor(evaluation, instance) {
        super();
        this.evaluation = evaluation;
        this.instance = instance;
        assertIsException(instance);
        this.name = instance.innerValue
            ? `${instance.module.fullyQualifiedName}: ${instance.innerValue.name}`
            : instance.module.fullyQualifiedName;
    }
}
exports.WollokException = WollokException;
class Context {
    constructor(parentContext, locals = new Map()) {
        this.id = (0, uuid_1.v4)();
        this.parentContext = parentContext;
        this.locals = locals;
    }
    get(local) {
        var _a, _b;
        const found = (_a = this.locals.get(local)) !== null && _a !== void 0 ? _a : (_b = this.parentContext) === null || _b === void 0 ? void 0 : _b.get(local);
        if (!found || found instanceof RuntimeObject)
            return found;
        let lazy = found.next();
        while (!lazy.done)
            lazy = found.next();
        this.set(local, lazy.value);
        return lazy.value;
    }
    set(local, value, lookup = false) {
        var _a;
        if (!lookup || this.locals.has(local))
            this.locals.set(local, value);
        else
            (_a = this.parentContext) === null || _a === void 0 ? void 0 : _a.set(local, value, lookup);
    }
    contextHierarchy() {
        var _a, _b;
        return [this, ...(_b = (_a = this.parentContext) === null || _a === void 0 ? void 0 : _a.contextHierarchy()) !== null && _b !== void 0 ? _b : []];
    }
    copy(contextCache) {
        if (contextCache.has(this.id))
            return contextCache.get(this.id);
        const copy = this.baseCopy(contextCache);
        contextCache.set(this.id, copy);
        for (const [name, value] of this.locals.entries())
            copy.set(name, value instanceof RuntimeObject ?
                value.copy(contextCache) :
                value ?
                    this.get(name) :
                    value);
        return copy;
    }
}
exports.Context = Context;
class Frame extends Context {
    constructor(node, parentContext, locals = {}) {
        super(parentContext, new Map(entries(locals)));
        this.node = node;
        this.currentNode = node;
    }
    get description() {
        return (0, extensions_1.match)(this.node)([model_1.Entity, (node) => `${node.fullyQualifiedName}`], (0, extensions_1.when)(model_1.Method)(node => `${node.parent.fullyQualifiedName}.${node.name}(${node.parameters.map(parameter => parameter.name).join(', ')})`), (0, extensions_1.when)(model_1.Send)(node => `${node.message}/${node.args.length}`), (0, extensions_1.when)(model_1.Catch)(node => `catch(${node.parameter.name}: ${node.parameterType.name})`), (0, extensions_1.when)(model_1.Environment)(() => 'root'), (0, extensions_1.otherwise)((node) => `${node.kind}`));
    }
    get sourceInfo() {
        const target = this.node.is(model_1.Method) && this.node.name === constants_1.CLOSURE_EVALUATE_METHOD
            ? this.currentNode.parent
            : this.currentNode;
        return target.sourceInfo;
    }
    baseCopy(contextCache) {
        var _a;
        return new Frame(this.node, (_a = this.parentContext) === null || _a === void 0 ? void 0 : _a.copy(contextCache));
    }
    toString() {
        return `${this.description}(${this.sourceInfo})`;
    }
    isCustom() {
        var _a;
        const module = this.node.ancestors.find(ancestor => ancestor.is(model_1.Module));
        return !((_a = module === null || module === void 0 ? void 0 : module.fullyQualifiedName) === null || _a === void 0 ? void 0 : _a.startsWith(constants_1.WOLLOK_BASE_PACKAGE)) && !this.node.is(model_1.Environment);
    }
}
exports.Frame = Frame;
class RuntimeObject extends Context {
    constructor(module, parentContext, innerValue) {
        super(parentContext);
        this.module = module;
        this.innerValue = innerValue;
        this.set('self', this);
    }
    get innerNumber() {
        if (typeof this.innerValue !== 'number')
            return undefined;
        return this.innerValue;
    }
    get innerString() {
        if (typeof this.innerValue !== 'string')
            return undefined;
        return this.innerValue;
    }
    get innerBoolean() {
        if (typeof this.innerValue !== 'boolean')
            return undefined;
        return this.innerValue;
    }
    get innerCollection() {
        if (!isArray(this.innerValue))
            return undefined;
        return this.innerValue;
    }
    get description() {
        return this.module.label;
    }
    baseCopy(contextCache) {
        return new RuntimeObject(this.module, this.parentContext.copy(contextCache), isArray(this.innerValue) ? this.innerValue.map(elem => elem.copy(contextCache)) : this.innerValue);
    }
    assertIs(moduleFQN, innerValue) {
        if (this.module.fullyQualifiedName !== moduleFQN)
            throw new TypeError(`Expected a ${moduleFQN} but got a ${this.module.fullyQualifiedName} instead`);
        if (innerValue === undefined)
            throw new TypeError(`Malformed Runtime Object: invalid inner value ${this.innerValue} for ${moduleFQN} instance`);
    }
    isConstant(localName) {
        var _a, _b;
        return (_b = (_a = this.module.lookupField(localName)) === null || _a === void 0 ? void 0 : _a.isConstant) !== null && _b !== void 0 ? _b : false;
    }
    getLabel(interpreter) {
        var _a, _b, _c;
        if (this.innerValue === null)
            return 'null';
        if (this.shouldShortenRepresentation()) {
            return (_b = (_a = interpreter.send(constants_1.TO_STRING_METHOD, this)) === null || _a === void 0 ? void 0 : _a.getShortRepresentation()) !== null && _b !== void 0 ? _b : '';
        }
        if (this.shouldShowShortValue())
            return this.showShortValue(interpreter);
        return (_c = this.module.name) !== null && _c !== void 0 ? _c : 'Object';
    }
    getShortLabel() {
        if (!this.innerValue)
            return `a ${this.module.fullyQualifiedName}`;
        return this.innerString !== undefined ? `"${this.getShortRepresentation()}"` : this.getShortRepresentation();
    }
    getShortRepresentation() {
        var _a, _b;
        return (_b = (_a = this.innerValue) === null || _a === void 0 ? void 0 : _a.toString().trim()) !== null && _b !== void 0 ? _b : '';
    }
    shouldShortenRepresentation() {
        const moduleName = this.module.fullyQualifiedName;
        return [constants_1.DATE_MODULE, constants_1.PAIR_MODULE, constants_1.RANGE_MODULE, constants_1.DICTIONARY_MODULE].includes(moduleName) || moduleName.startsWith(constants_1.CLOSURE_MODULE);
    }
    shouldShowShortValue() {
        const moduleName = this.module.fullyQualifiedName;
        return [constants_1.STRING_MODULE, constants_1.NUMBER_MODULE, constants_1.BOOLEAN_MODULE].includes(moduleName);
    }
    showShortValue(interpreter) {
        if (this.innerValue === null)
            return 'null';
        return typeof this.innerValue === 'string'
            ? `"${this.innerValue}"`
            : interpreter.send(constants_1.TO_STRING_METHOD, this).innerString;
    }
}
exports.RuntimeObject = RuntimeObject;
function assertIsNumber(obj, message, variableName, validateValue = true) {
    if (validateValue)
        assertIsNotNull(obj, message, variableName);
    if (obj.innerNumber === undefined)
        throw new TypeError(`Message ${message}: parameter ${(0, helpers_1.showParameter)(obj)} should be a number`);
}
exports.assertIsNumber = assertIsNumber;
function assertIsBoolean(obj, message, variableName) {
    if (!obj)
        throw new TypeError(`Message ${message}: ${variableName} should be a boolean`);
    if (obj.innerBoolean === undefined)
        throw new TypeError(`Message ${message}: parameter ${(0, helpers_1.showParameter)(obj)} should be a boolean`);
}
exports.assertIsBoolean = assertIsBoolean;
function assertIsString(obj, message, variableName, validateValue = true) {
    if (!obj)
        throw new TypeError(`Message ${message}: ${variableName} should be a string`);
    if (validateValue)
        assertIsNotNull(obj, message, variableName);
    if (obj.innerString === undefined)
        throw new TypeError(`Message ${message}: parameter ${(0, helpers_1.showParameter)(obj)} should be a string`);
}
exports.assertIsString = assertIsString;
function assertIsCollection(obj) {
    if (!obj.innerCollection)
        throw new TypeError(`Expected a List of values but was ${obj.innerValue}`);
}
exports.assertIsCollection = assertIsCollection;
function assertIsException(obj) {
    if (!obj.module.inherits(obj.module.environment.getNodeByFQN(constants_1.EXCEPTION_MODULE)))
        throw new TypeError(`Expected an exception but got a ${obj.module.fullyQualifiedName} instead`);
    if (obj.innerValue && !(obj.innerValue instanceof Error)) {
        throw obj.innerValue;
    }
}
exports.assertIsException = assertIsException;
function assertIsNotNull(obj, message, variableName) {
    if (!obj || obj.innerValue === null)
        throw new RangeError(`Message ${message} does not support parameter '${variableName}' to be null`);
}
exports.assertIsNotNull = assertIsNotNull;
class Evaluation {
    get rootFrame() { return this.frameStack[0]; }
    get currentFrame() { return (0, extensions_1.last)(this.frameStack); }
    get currentNode() { return this.currentFrame.node; }
    get environment() { return this.rootFrame.node; }
    static build(environment, natives) {
        var _a;
        const evaluation = new Evaluation(new Map(), [new Frame(environment)], new Map(), new Map());
        environment.forEach(node => {
            if (node.is(model_1.Method))
                if (node.isNative())
                    evaluation.natives.set(node, (0, extensions_1.get)(natives, `${node.parent.fullyQualifiedName}.${node.name}`));
                else if (node.fromProperty) {
                    evaluation.natives.set(node, (0, helpers_1.compilePropertyMethod)(node));
                    node.compiled = true;
                }
        });
        const globalSingletons = environment.descendants.filter((node) => (0, helpers_1.isNamedSingleton)(node));
        for (const module of globalSingletons)
            evaluation.rootFrame.set(module.fullyQualifiedName, evaluation.instantiate(module));
        const globalConstants = environment.descendants.filter((node) => node.is(model_1.Variable) && node.isAtPackageLevel);
        for (const constant of globalConstants)
            evaluation.rootFrame.set(constant.fullyQualifiedName, evaluation.exec(constant.value));
        for (const module of globalSingletons) {
            const instance = evaluation.object(module.fullyQualifiedName);
            for (const field of module.allFields) {
                const value = instance.get(field.name);
                if ((value === null || value === void 0 ? void 0 : value.innerValue) === null && ((_a = field.value) === null || _a === void 0 ? void 0 : _a.isSynthetic)) {
                    (0, extensions_1.raise)(new Error(`Error in ${module.name}: '${field.name}' attribute uninitialized`));
                }
            }
        }
        for (const constant of globalConstants) {
            const instance = evaluation.object(constant.fullyQualifiedName);
            for (const local of instance.locals)
                instance.get(local[0]);
        }
        return evaluation;
    }
    constructor(natives, frameStack, numberCache, stringCache) {
        this.console = console;
        this.natives = natives;
        this.frameStack = frameStack;
        this.numberCache = numberCache;
        this.stringCache = stringCache;
    }
    copy(contextCache = new Map()) {
        return new Evaluation(this.natives, this.frameStack.map(frame => frame.copy(contextCache)), new Map([...this.numberCache.entries()].flatMap(([key, value]) => {
            var _a;
            const instanceCopy = (_a = value.deref()) === null || _a === void 0 ? void 0 : _a.copy(contextCache);
            return instanceCopy ? [[key, new WeakRef(instanceCopy)]] : [];
        })), new Map([...this.stringCache.entries()].flatMap(([key, value]) => {
            var _a;
            const instanceCopy = (_a = value.deref()) === null || _a === void 0 ? void 0 : _a.copy(contextCache);
            return instanceCopy ? [[key, new WeakRef(instanceCopy)]] : [];
        })));
    }
    allInstances() {
        const visitedContexts = [];
        function contextInstances(context) {
            var _a, _b;
            if (!context || visitedContexts.includes(context.id))
                return [];
            visitedContexts.push(context.id);
            const localInstances = [...context.locals.values()].filter((value) => value instanceof RuntimeObject);
            return [
                ...contextInstances(context.parentContext),
                ...context instanceof RuntimeObject ? [context, ...(_b = (_a = context.innerCollection) === null || _a === void 0 ? void 0 : _a.flatMap(contextInstances)) !== null && _b !== void 0 ? _b : []] : [],
                ...localInstances.flatMap(contextInstances),
            ];
        }
        return new Set(this.frameStack.flatMap(frame => contextInstances(frame)));
    }
    object(fullyQualifiedName) {
        const instance = this.rootFrame.get(fullyQualifiedName);
        if (!instance)
            throw new Error(`WKO not found: ${fullyQualifiedName}`);
        return instance;
    }
    *exec(node, frame) {
        if (frame)
            this.frameStack.push(frame);
        this.currentFrame.currentNode = node;
        try {
            switch (node.kind) {
                case 'Test':
                    yield* this.execTest(node);
                    return;
                case 'Program':
                    yield* this.execProgram(node);
                    return;
                case 'Method': return yield* this.execMethod(node);
                case 'Body': return yield* this.execBody(node);
                case 'Variable':
                    yield* this.execVariable(node);
                    return;
                case 'Assignment':
                    yield* this.execAssignment(node);
                    return;
                case 'Return': return yield* this.execReturn(node);
                case 'Reference': return yield* this.execReference(node);
                case 'Self': return yield* this.execSelf(node);
                case 'Literal': return yield* this.execLiteral(node);
                case 'New': return yield* this.execNew(node);
                case 'Send': return yield* this.execSend(node);
                case 'Super': return yield* this.execSuper(node);
                case 'If': return yield* this.execIf(node);
                case 'Try': return yield* this.execTry(node);
                case 'Throw': return yield* this.execThrow(node);
                case 'Singleton': return yield* this.execSingleton(node);
                default: throw new Error(`Can't execute ${node.kind} node`);
            }
        }
        catch (error) {
            if (error instanceof WollokException || error instanceof WollokReturn)
                throw error;
            const moduleFQN = error instanceof RangeError && error.message === 'Maximum call stack size exceeded'
                ? 'wollok.lang.StackOverflowException'
                : 'wollok.lang.EvaluationError';
            const exceptionInstance = new WollokException(this, yield* this.error(moduleFQN, {}, error));
            throw exceptionInstance;
        }
        finally {
            if (frame)
                this.frameStack.pop();
        }
    }
    *execTest(node) {
        yield node;
        yield* this.exec(node.body, new Frame(node, node.parent.is(model_1.Describe)
            ? yield* this.instantiate(node.parent)
            : this.currentFrame));
    }
    *execProgram(node) {
        yield node;
        yield* this.exec(node.body, new Frame(node, this.currentFrame));
    }
    *execMethod(node) {
        var _a;
        yield node;
        if (node.hasNativeImplementation) {
            const native = this.natives.get(node);
            if (!native)
                throw new Error(`Missing native for ${node.parent.fullyQualifiedName}.${node.name}`);
            const args = node.parameters.map(parameter => this.currentFrame.get(parameter.name));
            return (_a = (yield* native.call(this, this.currentFrame.get(constants_1.KEYWORDS.SELF), ...args))) !== null && _a !== void 0 ? _a : (yield* this.reifyVoid());
        }
        else if (node.isConcrete()) {
            try {
                yield* this.exec(node.body);
                return;
            }
            catch (error) {
                if (error instanceof WollokReturn)
                    return error.instance;
                else
                    throw error;
            }
        }
        else
            throw new Error(`Can't invoke abstract method ${node.parent.fullyQualifiedName}.${node.name}/${node.parameters.length}`);
    }
    *execBody(node) {
        yield node;
        let result;
        for (const sentence of node.sentences)
            result = yield* this.exec(sentence);
        return (0, helpers_1.isVoid)(result) ? yield* this.reifyVoid() : result;
    }
    *execVariable(node) {
        const variableFullName = (0, helpers_1.targetName)(node, node.name);
        if (this.currentFrame.locals.get(variableFullName)) {
            throw new Error('Can\'t redefine a variable');
        }
        const value = yield* this.exec(node.value);
        (0, helpers_1.assertNotVoid)(value, `Cannot assign to variable '${node.name}': ${(0, helpers_1.getExpressionFor)(node.value)} produces no value, cannot assign it to a variable`);
        yield node;
        this.currentFrame.set(variableFullName, value);
    }
    *execAssignment(node) {
        var _a, _b;
        const variableName = (_a = node.variable.target) === null || _a === void 0 ? void 0 : _a.name;
        const value = yield* this.exec(node.value);
        (0, helpers_1.assertNotVoid)(value, `${value.getShortLabel()} produces no value, cannot assign it to reference ${variableName}`);
        yield node;
        if ((_b = node.variable.target) === null || _b === void 0 ? void 0 : _b.isConstant)
            throw new Error(`Can't assign the constant ${variableName}`);
        const target = node.variable.target;
        this.currentFrame.set((0, helpers_1.targetName)(target, node.variable.name), value, true);
    }
    *execReturn(node) {
        const value = node.value && (yield* this.exec(node.value));
        yield node;
        throw WollokReturn.of(value);
    }
    *execReference(node) {
        var _a, _b;
        yield node;
        if (!node.scope)
            return (_a = this.currentFrame.get(node.name)) !== null && _a !== void 0 ? _a : (0, extensions_1.raise)(new Error(`Could not resolve unlinked reference to ${node.name}`));
        const target = node.target;
        if ((target === null || target === void 0 ? void 0 : target.is(model_1.Field)) && (0, helpers_1.loopInAssignment)(target.value, target.name)) {
            (0, extensions_1.raise)(new Error(`Error initializing field ${target.name}: stack overflow`));
        }
        return (_b = this.currentFrame.get((0, helpers_1.targetName)(target, node.name))) !== null && _b !== void 0 ? _b : (0, extensions_1.raise)(new Error(`Could not resolve reference to ${node.name}`));
    }
    *execSelf(node) {
        yield node;
        return this.currentFrame.get(constants_1.KEYWORDS.SELF);
    }
    *execLiteral(node) {
        if (isArray(node.value)) {
            const [reference, args] = node.value;
            const module = reference.target;
            const values = [];
            for (const arg of args)
                values.push(yield* this.exec(arg));
            yield node;
            return yield* module.name === 'List' ? this.list(...values) : this.set(...values);
        }
        yield node;
        return yield* this.reify(node.value);
    }
    *execNew(node) {
        var _a, _b;
        const args = {};
        const isGlobal = Boolean(node.ancestors.find((node) => node.is(model_1.Variable) && node.isAtPackageLevel));
        for (const arg of node.args) {
            const valueExecution = this.exec(arg.value, new Frame(arg.value, this.currentFrame));
            const value = isGlobal ? valueExecution : yield* valueExecution;
            if (value instanceof RuntimeObject && (0, helpers_1.isVoid)(value)) {
                (0, helpers_1.assertNotVoid)(value, `new ${(_a = node.instantiated.target) === null || _a === void 0 ? void 0 : _a.fullyQualifiedName}: value of parameter '${arg.name}' produces no value, cannot use it`);
            }
            args[arg.name] = value;
        }
        yield node;
        const target = (_b = node.instantiated.target) !== null && _b !== void 0 ? _b : (0, extensions_1.raise)(new Error(`Could not resolve reference to instantiated module ${node.instantiated.name}`));
        const name = node.instantiated.name;
        if (!target.is(model_1.Class))
            (0, extensions_1.raise)(new Error(`${name} is not a class, you cannot generate instances of it`));
        if (target.isAbstract)
            (0, extensions_1.raise)(new Error(`${name} is an abstract class, you cannot generate instances`));
        const uninitializedAttributes = (0, helpers_1.getUninitializedAttributesForInstantiation)(node);
        if (uninitializedAttributes.length) {
            (0, extensions_1.raise)(new Error(`${name} cannot be instantiated, you must pass values to the following attributes: ${uninitializedAttributes.join(', ')}`));
        }
        if (target.fullyQualifiedName === constants_1.LIST_MODULE)
            return yield* this.list();
        if (target.fullyQualifiedName === constants_1.SET_MODULE)
            return yield* this.set();
        return yield* this.instantiate(target, args);
    }
    *execSend(node) {
        const receiver = yield* this.exec(node.receiver);
        if ((node.message === '&&' || node.message === 'and') && receiver.innerBoolean === false)
            return receiver;
        if ((node.message === '||' || node.message === 'or') && receiver.innerBoolean === true)
            return receiver;
        (0, helpers_1.assertNotVoid)(receiver, `Cannot send message ${node.message}, receiver is an expression that produces no value.`);
        const values = [];
        for (const [i, arg] of node.args.entries()) {
            const value = yield* this.exec(arg);
            const methodContainer = (0, helpers_1.getMethodContainer)(node);
            (0, helpers_1.assertNotVoid)(value, `${methodContainer ? methodContainer.name + ' - while sending message' : 'Message'} ${receiver.module.name ? receiver.module.name + '.' : ''}${node.message}/${node.args.length}: parameter #${i + 1} produces no value, cannot use it`);
            values.push(value);
        }
        yield node;
        const result = yield* this.send(node.message, receiver, ...values);
        return result === undefined ? yield* this.reifyVoid() : result;
    }
    *execSuper(node) {
        const currentMethod = node.ancestors.find((0, extensions_1.is)(model_1.Method));
        const args = [];
        for (const [i, arg] of node.args.entries()) {
            const value = yield* this.exec(arg);
            (0, helpers_1.assertNotVoid)(value, `super call for message ${currentMethod.name}/${currentMethod.parameters.length}: parameter #${i + 1} produces no value, cannot use it`);
            args.push(value);
        }
        yield node;
        const receiver = this.currentFrame.get(constants_1.KEYWORDS.SELF);
        const method = (0, helpers_1.superMethodDefinition)(node, receiver.module);
        if (!method)
            return yield* this.send('messageNotUnderstood', receiver, yield* this.reify(currentMethod.name), yield* this.list(...args));
        return yield* this.invoke(method, receiver, ...args);
    }
    *execIf(node) {
        const condition = yield* this.exec(node.condition);
        const methodContainer = (0, helpers_1.getMethodContainer)(node);
        (0, helpers_1.assertNotVoid)(condition, `${methodContainer ? 'Message ' + methodContainer.name + ' - ' : ''}if condition produces no value, cannot use it`);
        assertIsBoolean(condition, 'if', 'condition');
        yield node;
        return yield* this.exec(condition.innerBoolean ? node.thenBody : node.elseBody, new Frame(node, this.currentFrame));
    }
    *execTry(node) {
        yield node;
        let result;
        try {
            result = yield* this.exec(node.body, new Frame(node, this.currentFrame));
        }
        catch (error) {
            if (!(error instanceof WollokException))
                throw error;
            const errorType = error.instance.module;
            const handler = node.catches.find(catcher => {
                const handledType = catcher.parameterType.target;
                return handledType && errorType.inherits(handledType);
            });
            if (handler) {
                result = yield* this.exec(handler.body, new Frame(handler, this.currentFrame, { [handler.parameter.name]: error.instance }));
            }
            else
                throw error;
        }
        finally {
            yield* this.exec(node.always, new Frame(node, this.currentFrame));
        }
        return result;
    }
    *execThrow(node) {
        const exception = yield* this.exec(node.exception);
        yield node;
        throw new WollokException(this, exception);
    }
    *execSingleton(node) {
        yield node;
        return yield* this.instantiate(node, {});
    }
    *send(message, receiver, ...args) {
        if (!receiver)
            throw new RangeError(`Message: ${message}: receiver produces no value. Cannot send message ${message}`);
        const method = receiver.module.lookupMethod(message, args.length);
        if (!method)
            return yield* this.send('messageNotUnderstood', receiver, yield* this.reify(message), yield* this.list(...args));
        return yield* this.invoke(method, receiver, ...args);
    }
    *invoke(method, receiver, ...args) {
        const locals = yield* this.localsFor(method, args);
        return yield* this.exec(method, new Frame(method, receiver, locals));
    }
    *localsFor(method, args) {
        const locals = {};
        for (let index = 0; index < method.parameters.length; index++) {
            const { name, isVarArg } = method.parameters[index];
            locals[name] = isVarArg ? yield* this.list(...args.slice(index)) : args[index];
        }
        return locals;
    }
    *reify(value) {
        var _a, _b;
        if (typeof value === 'boolean') {
            const existing = this.rootFrame.get(`${value}`);
            if (existing)
                return existing;
            const instance = new RuntimeObject(this.environment.getNodeByFQN(constants_1.BOOLEAN_MODULE), this.rootFrame, value);
            this.rootFrame.set(`${value}`, instance);
            return instance;
        }
        if (typeof value === 'number') {
            const isRound = isInteger(value);
            const preciseValue = isRound ? value : Number(value.toFixed(DECIMAL_PRECISION));
            const existing = (_a = this.numberCache.get(preciseValue)) === null || _a === void 0 ? void 0 : _a.deref();
            if (existing)
                return existing;
            const instance = new RuntimeObject(this.environment.getNodeByFQN(constants_1.NUMBER_MODULE), this.rootFrame, preciseValue);
            this.numberCache.set(preciseValue, new WeakRef(instance));
            return instance;
        }
        if (typeof value === 'string') {
            const existing = (_b = this.stringCache.get(value)) === null || _b === void 0 ? void 0 : _b.deref();
            if (existing)
                return existing;
            const instance = new RuntimeObject(this.environment.getNodeByFQN(constants_1.STRING_MODULE), this.rootFrame, value);
            this.stringCache.set(value, new WeakRef(instance));
            return instance;
        }
        const existing = this.rootFrame.get(constants_1.KEYWORDS.NULL);
        if (existing)
            return existing;
        const instance = new RuntimeObject(this.environment.getNodeByFQN(constants_1.OBJECT_MODULE), this.rootFrame, value);
        this.rootFrame.set(constants_1.KEYWORDS.NULL, instance);
        return instance;
    }
    *reifyVoid() {
        const existing = this.rootFrame.get(constants_1.VOID_WKO);
        if (existing)
            return existing;
        const instance = new RuntimeObject(this.environment.getNodeByFQN(constants_1.VOID_WKO), this.rootFrame, undefined);
        this.rootFrame.set(constants_1.VOID_WKO, instance);
        return instance;
    }
    *list(...value) {
        return new RuntimeObject(this.environment.getNodeByFQN(constants_1.LIST_MODULE), this.rootFrame, value);
    }
    *set(...value) {
        const result = new RuntimeObject(this.environment.getNodeByFQN(constants_1.SET_MODULE), this.rootFrame, []);
        for (const elem of value)
            yield* this.send('add', result, elem);
        return result;
    }
    *error(moduleOrFQN, locals, error) {
        const module = typeof moduleOrFQN === 'string' ? this.environment.getNodeByFQN(moduleOrFQN) : moduleOrFQN;
        const instance = new RuntimeObject(module, this.currentFrame, error);
        yield* this.init(instance, locals);
        return instance;
    }
    *instantiate(moduleOrFQN, locals) {
        const module = typeof moduleOrFQN === 'string' ? this.environment.getNodeByFQN(moduleOrFQN) : moduleOrFQN;
        const instance = new RuntimeObject(module, module.is(model_1.Singleton) && !module.name ? this.currentFrame : this.rootFrame);
        yield* this.init(instance, locals);
        return instance;
    }
    *init(instance, locals = {}) {
        const allFieldNames = instance.module.allFields.map(({ name }) => name);
        for (const local of keys(locals))
            if (!allFieldNames.includes(local))
                throw new Error(`Can't initialize ${instance.module.fullyQualifiedName} with value for unexistent field ${local}`);
        for (const field of instance.module.allFields) {
            const defaultValue = instance.module.defaultValueFor(field);
            const initialValue = field.name in locals
                ? locals[field.name]
                : this.exec(defaultValue, new Frame(defaultValue, instance));
            instance.set(field.name, initialValue);
        }
        yield* this.send(constants_1.INITIALIZE_METHOD, instance);
        if (!instance.module.name || instance.module.is(model_1.Describe))
            for (const field of instance.module.allFields)
                instance.get(field.name);
    }
}
exports.Evaluation = Evaluation;
//# sourceMappingURL=runtimeModel.js.map