# Do not edit this file directly. It has been autogenerated from
# src/strawchemy/strawberry/repository/_async.py
from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING, Any, TypeVar

from strawchemy.sqlalchemy.repository import SQLAlchemyGraphQLSyncRepository
from strawchemy.strawberry._utils import default_session_getter, dto_model_from_type, strawberry_contained_user_type

from ._base import GraphQLResult, StrawchemyRepository

if TYPE_CHECKING:
    from sqlalchemy import Select
    from strawberry import Info
    from strawchemy.sqlalchemy.typing import AnySyncSession
    from strawchemy.strawberry.dto import BooleanFilterDTO, EnumDTO, OrderByDTO
    from strawchemy.strawberry.mutation.input import Input, InputModel
    from strawchemy.strawberry.typing import SyncSessionGetter

__all__ = ()

T = TypeVar("T")


@dataclass
class StrawchemySyncRepository(StrawchemyRepository[T]):
    type: type[T]
    info: Info[Any, Any]

    # sqlalchemy related settings
    session_getter: SyncSessionGetter = default_session_getter
    session: AnySyncSession | None = None
    filter_statement: Select[tuple[Any]] | None = None
    execution_options: dict[str, Any] | None = None
    deterministic_ordering: bool = False

    def graphql_repository(self) -> SQLAlchemyGraphQLSyncRepository[Any]:
        return SQLAlchemyGraphQLSyncRepository(
            model=dto_model_from_type(strawberry_contained_user_type(self.type)),
            session=self.session or self.session_getter(self.info),
            statement=self.filter_statement,
            execution_options=self.execution_options,
            deterministic_ordering=self.deterministic_ordering,
        )

    def get_one_or_none(
        self,
        filter_input: BooleanFilterDTO | None = None,
        order_by: list[OrderByDTO] | None = None,
        distinct_on: list[EnumDTO] | None = None,
        limit: int | None = None,
        offset: int | None = None,
    ) -> GraphQLResult[Any, T]:
        query_results = self.graphql_repository().get_one(
            selection=self._tree,
            dto_filter=filter_input or None,
            order_by=list(order_by or []),
            distinct_on=distinct_on,
            limit=limit,
            offset=offset,
            query_hooks=self._query_hooks,
        )
        return GraphQLResult(query_results, self._tree)

    def get_one(
        self,
        filter_input: BooleanFilterDTO | None = None,
        order_by: list[OrderByDTO] | None = None,
        distinct_on: list[EnumDTO] | None = None,
        limit: int | None = None,
        offset: int | None = None,
    ) -> GraphQLResult[Any, T]:
        query_results = self.graphql_repository().get_one(
            selection=self._tree,
            dto_filter=filter_input or None,
            order_by=list(order_by or []),
            distinct_on=distinct_on,
            limit=limit,
            offset=offset,
            query_hooks=self._query_hooks,
        )
        return GraphQLResult(query_results, self._tree)

    def get_by_id(self, **kwargs: Any) -> GraphQLResult[Any, T]:
        query_results = self.graphql_repository().get_by_id(
            selection=self._tree, query_hooks=self._query_hooks, **kwargs
        )
        return GraphQLResult(query_results, self._tree)

    def list(
        self,
        filter_input: BooleanFilterDTO | None = None,
        order_by: list[OrderByDTO] | None = None,
        distinct_on: list[EnumDTO] | None = None,
        limit: int | None = None,
        offset: int | None = None,
    ) -> GraphQLResult[Any, T]:
        query_results = self.graphql_repository().list(
            selection=self._tree,
            dto_filter=filter_input or None,
            order_by=list(order_by or []),
            distinct_on=distinct_on,
            limit=limit,
            offset=offset,
            query_hooks=self._query_hooks,
        )
        return GraphQLResult(query_results, self._tree)

    def create(self, data: Input[InputModel]) -> GraphQLResult[InputModel, T]:
        query_results = self.graphql_repository().create(data, self._tree)
        return GraphQLResult(query_results, self._tree)

    def upsert(
        self,
        data: Input[InputModel],
        filter_input: BooleanFilterDTO | None = None,
        update_fields: list[EnumDTO] | None = None,
        conflict_fields: EnumDTO | None = None,
    ) -> GraphQLResult[InputModel, T]:
        query_results = self.graphql_repository().upsert(data, self._tree, update_fields, conflict_fields, filter_input)
        return GraphQLResult(query_results, self._tree)

    def update_by_id(self, data: Input[InputModel]) -> GraphQLResult[InputModel, T]:
        query_results = self.graphql_repository().update_by_ids(data, self._tree)
        return GraphQLResult(query_results, self._tree)

    def update_by_filter(self, data: Input[InputModel], filter_input: BooleanFilterDTO) -> GraphQLResult[InputModel, T]:
        query_results = self.graphql_repository().update_by_filter(data, filter_input, self._tree)
        return GraphQLResult(query_results, self._tree)

    def delete(self, filter_input: BooleanFilterDTO | None) -> GraphQLResult[Any, T]:
        query_results = self.graphql_repository().delete(self._tree, filter_input or None)
        return GraphQLResult(query_results, self._tree)
