import pytest
from unittest.mock import mock_open, patch
from vibedir.vibedir import load_config, build_prompt, save_output
import yaml
import logging
from io import StringIO

@pytest.fixture
def sample_config_content():
    return {
        "logging": {"level": "INFO"},
        "prompt_template": """
You are a code modification assistant. Below is the content of a prepped_dir.txt file generated by prepdir, listing files and additional commands for a project. Your task is to apply the following changes: {user_request}. Return the modified content in a file named modified_prepped_dir.txt, preserving the original format, including delimiters (e.g., =-=, ===---===), file markers (Begin File, End File), and additional commands section. Ensure filenames in Begin File and End File markers match exactly, and only include valid code changes.

=== prepped_dir.txt Content ===
{prepped_dir_content}
=== End prepped_dir.txt Content ===

Output the modified content as modified_prepped_dir.txt with the same structure.
"""
    }

@pytest.fixture
def capture_log():
    """Capture logging output."""
    log_output = StringIO()
    handler = logging.StreamHandler(log_output)
    logging.getLogger().setLevel(logging.INFO)
    logging.getLogger().addHandler(handler)
    yield log_output
    logging.getLogger().handlers = []
    logging.getLogger().setLevel(logging.NOTSET)

def test_load_config(sample_config_content):
    """Test loading configuration from YAML file."""
    config_yaml = yaml.dump(sample_config_content)
    with patch("builtins.open", mock_open(read_data=config_yaml)):
        config = load_config("dummy_config.yaml")
    
    assert config["logging"]["level"] == "INFO"
    assert "modified_prepped_dir.txt" in config["prompt_template"]

def test_load_config_missing_file(capture_log):
    """Test handling missing config file."""
    with patch("builtins.open", side_effect=FileNotFoundError):
        config = load_config("dummy_config.yaml")
    
    assert config == {}
    log_output = capture_log.getvalue()
    assert "Failed to load config from dummy_config.yaml" in log_output

def test_build_prompt():
    """Test building a prompt from prepped_dir.txt and user request."""
    prepped_content = "=-= Begin File: 'test_file.py' =-=\nprint('Hello')\n=-= End File: 'test_file.py' =-="
    with patch("builtins.open", mock_open(read_data=prepped_content)):
        prompt = build_prompt("dummy_path.txt", "Add async", {})
    
    assert "apply the following changes: Add async" in prompt
    assert prepped_content in prompt
    assert "modified_prepped_dir.txt" in prompt

def test_build_prompt_missing_file(capture_log):
    """Test handling missing prepped_dir.txt."""
    with patch("builtins.open", side_effect=FileNotFoundError):
        with pytest.raises(FileNotFoundError):
            build_prompt("dummy_path.txt", "Add async", {})
    
    log_output = capture_log.getvalue()
    assert "Failed to read dummy_path.txt" in log_output

def test_save_output(tmp_path):
    """Test saving output to a file."""
    output_path = tmp_path / "modified_prepped_dir.txt"
    content = "Test content"
    save_output(content, str(output_path))
    
    assert output_path.read_text() == "Test content"

def test_save_output_failure(tmp_path, capture_log):
    """Test handling save output failure."""
    output_path = tmp_path / "nonexistent/dir/output.txt"
    with pytest.raises(OSError):
        save_output("Test content", str(output_path))
    
    log_output = capture_log.getvalue()
    assert f"Failed to save output to {output_path}" in log_output