import argparse
import csv
import json
import os
from dataclasses import dataclass
from datetime import datetime
from typing import List, Dict, Optional
import requests
import re

@dataclass
class Vulnerability:
    cve_id: str
    description: str
    severity: str
    score: float
    version_range: str
    published: str
    last_modified: str

@dataclass
class ScanResult:
    package: str
    version: str
    vulnerabilities: List[Vulnerability]

class CVEScanner:
    def __init__(self, api_key: str, cache_dir: str = "cache"):
        self.api_key = api_key
        self.base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.cache_dir = cache_dir
        os.makedirs(cache_dir, exist_ok=True)

    def _normalize_version(self, version_str: str) -> Optional[List[int]]:
        """將版本字串轉換為可比較的數字列表"""
        try:
            # 處理無效或特殊版本
            if not version_str or version_str in ['*', '-']:
                return None
                
            # 處理帶有前綴的版本號
            if version_str.startswith('v'):
                version_str = version_str[1:]
                
            # 移除 build metadata
            if '+' in version_str:
                version_str = version_str.split('+')[0]
                
            # 預發布版本映射
            prerelease_map = {
                'alpha': -30,
                'beta': -20,
                'rc': -10,
                'patch': 0  # patch 視為正式版本的修補
            }
            
            # 分析主版本號和預發布/patch 信息
            if '-' in version_str:
                main_version, extra = version_str.split('-', 1)
            else:
                main_version, extra = version_str, ''
                
            # 處理主版本號
            version_parts = []
            for part in main_version.split('.'):
                if part.isdigit():
                    version_parts.append(int(part))
                elif len(part) > 0 and part[-1].isalpha():  # OpenSSL 風格
                    num_part = part[:-1]
                    letter_part = part[-1].lower()
                    if num_part.isdigit():
                        version_parts.append(int(num_part))
                        version_parts.append(ord(letter_part) - ord('a') + 1)
                else:
                    if not any(c.isdigit() for c in version_str):
                        return None  # 完全無效的版本號
                    continue
                    
            # 處理預發布/patch 版本
            if extra:
                # 提取預發布類型
                for prefix in prerelease_map:
                    if extra.lower().startswith(prefix):
                        version_parts.append(prerelease_map[prefix])
                        # 提取版本號（如果有）
                        remaining = extra[len(prefix):].strip('.').strip()
                        if remaining.isdigit():
                            version_parts.append(int(remaining))
                        break
                else:
                    # 如果是純數字（如 patch1）
                    nums = ''.join(filter(str.isdigit, extra))
                    if nums:
                        version_parts.append(0)  # patch 標記
                        version_parts.append(int(nums))
                        
            return version_parts if version_parts else None
            
        except (ValueError, AttributeError):
            return None  # 任何解析錯誤都返回 None

    def _compare_versions(self, v1: str, v2: str) -> int:
        """比較兩個版本號"""
        v1_parts = self._normalize_version(v1)
        v2_parts = self._normalize_version(v2)
        
        # 處理無效版本
        if v1_parts is None and v2_parts is None:
            return 0
        if v1_parts is None:
            return 0  # 無效版本視為相等
        if v2_parts is None:
            return 0  # 無效版本視為相等
            
        # 預發布版本的特殊處理
        v1_is_prerelease = any(x < 0 for x in v1_parts)
        v2_is_prerelease = any(x < 0 for x in v2_parts)
        
        # 如果一個是預發布版本，一個是正式版本
        if v1_is_prerelease != v2_is_prerelease:
            if v1_is_prerelease:
                return -1
            return 1
            
        # 補齊長度
        max_length = max(len(v1_parts), len(v2_parts))
        v1_parts.extend([0] * (max_length - len(v1_parts)))
        v2_parts.extend([0] * (max_length - len(v2_parts)))
        
        # 比較各部分
        for i, j in zip(v1_parts, v2_parts):
            if i < j:
                return -1
            if i > j:
                return 1
        return 0
    
    def _is_version_affected(self, target: str, start: Optional[str] = None, end: Optional[str] = None) -> bool:
        """判斷版本是否在受影響範圍內"""
        if start and start not in ['*', '-'] and self._compare_versions(target, start) < 0:
            return False
        if end and end not in ['*', '-'] and self._compare_versions(target, end) > 0:
            return False
        return True

    def _get_cached_data(self, package: str) -> Optional[Dict]:
        """從快取獲取資料"""
        cache_file = os.path.join(self.cache_dir, f'debug_{package.lower()}.json')
        try:
            if os.path.exists(cache_file):
                with open(cache_file, 'r') as f:
                    print(f"Loading cached data for {package}")
                    return json.load(f)
        except Exception as e:
            print(f"Cache read error: {e}")
        return None

    def _save_to_cache(self, package: str, data: Dict) -> None:
        """保存資料到快取"""
        cache_file = os.path.join(self.cache_dir, f'debug_{package.lower()}.json')
        try:
            with open(cache_file, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            print(f"Cache write error: {e}")

    def _process_cve_data(self, data: Dict, package: str, version: str) -> List[Vulnerability]:
        """處理 CVE 資料"""
        vulnerabilities = []
        for vuln in data.get('vulnerabilities', []):
            cve = vuln.get('cve', {})
            
            # 檢查配置
            for config in cve.get('configurations', []):
                for node in config.get('nodes', []):
                    for cpe_match in node.get('cpeMatch', []):
                        if package.lower() not in cpe_match.get('criteria', '').lower():
                            continue
                            
                        # 檢查版本範圍
                        start_ver = cpe_match.get('versionStartIncluding') or cpe_match.get('versionStartExcluding')
                        end_ver = cpe_match.get('versionEndIncluding') or cpe_match.get('versionEndExcluding')
                        
                        if not self._is_version_affected(version, start_ver, end_ver):
                            continue
                            
                        # 獲取 CVSS 資訊
                        metrics = cve.get('metrics', {})
                        cvss_v3 = next(iter(metrics.get('cvssMetricV31', []) or metrics.get('cvssMetricV30', [])), {}).get('cvssData', {})
                        
                        vuln_info = Vulnerability(
                            cve_id=cve.get('id', ''),
                            description=next((d['value'] for d in cve.get('descriptions', []) 
                                         if d.get('lang') == 'en'), ''),
                            severity=cvss_v3.get('baseSeverity', 'UNKNOWN'),
                            score=cvss_v3.get('baseScore', 0.0),
                            version_range=f"{start_ver or '*'} to {end_ver or '*'}",
                            published=cve.get('published', ''),
                            last_modified=cve.get('lastModified', '')
                        )
                        
                        if vuln_info not in vulnerabilities:
                            vulnerabilities.append(vuln_info)
                            
        return vulnerabilities

    def fetch_vulnerabilities(self, package: str, version: str) -> List[Vulnerability]:
        """獲取漏洞資訊"""
        print(f"\nScanning {package} version {version}")
        
        # 先檢查快取
        cached_data = self._get_cached_data(package)
        if cached_data is not None:
            return self._process_cve_data(cached_data, package, version)
        
        # 從 API 獲取資料
        try:
            response = requests.get(
                self.base_url,
                headers={'apiKey': self.api_key},
                params={'keywordSearch': package, 'resultsPerPage': 100},
                timeout=30
            )
            
            if response.status_code != 200:
                print(f"API Error: {response.status_code}")
                print(f"Response: {response.text}")
                return []
                
            try:
                data = response.json()
                self._save_to_cache(package, data)
                return self._process_cve_data(data, package, version)
            except ValueError as e:
                print(f"JSON parsing error: {e}")
                return []
                
        except Exception as e:
            print(f"Request error: {e}")
            return []

    def scan_packages(self, packages_file: str) -> List[ScanResult]:
        """掃描多個套件"""
        results = []
        try:
            with open(packages_file, 'r') as f:
                reader = csv.reader(f)
                next(reader)  # 跳過標題行
                for row in reader:
                    if len(row) >= 2:
                        vulnerabilities = self.fetch_vulnerabilities(row[0].strip(), row[1].strip())
                        results.append(ScanResult(
                            package=row[0].strip(),
                            version=row[1].strip(),
                            vulnerabilities=vulnerabilities
                        ))
        except Exception as e:
            print(f"Error reading CSV file: {e}")
        return results

def generate_report(results: List[ScanResult], output_file: str) -> None:
    """生成報告"""
    severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3, 'UNKNOWN': 4}
    
    with open(output_file, 'w') as f:
        f.write("# Security Vulnerability Report\n")
        f.write(f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        
        for result in results:
            f.write(f"## {result.package} {result.version}\n\n")
            
            if result.vulnerabilities:
                # 按嚴重程度排序
                sorted_vulns = sorted(result.vulnerabilities, 
                                    key=lambda x: (severity_order.get(x.severity, 999), -x.score))
                
                for vuln in sorted_vulns:
                    f.write(f"### {vuln.cve_id}\n")
                    f.write(f"Severity: {vuln.severity}\n")
                    f.write(f"CVSS Score: {vuln.score}\n")
                    f.write(f"Version Range: {vuln.version_range}\n")
                    f.write(f"Published: {vuln.published}\n")
                    f.write(f"Last Modified: {vuln.last_modified}\n")
                    f.write(f"Description: {vuln.description}\n\n")
            else:
                f.write("No vulnerabilities found.\n\n")
            
            f.write("---\n\n")

def main() -> None:
    parser = argparse.ArgumentParser(description='Scan packages for security vulnerabilities')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-f', '--file', help='CSV file containing packages and versions')
    group.add_argument('-p', '--package', help='Single package name to scan')
    parser.add_argument('-v', '--version', help='Package version (required with -p)')
    parser.add_argument('-o', '--output', default='vulnerability_report.md',
                      help='Output report file name (default: vulnerability_report.md)')
    parser.add_argument('--force-update', action='store_true',
                      help='Force update cache and fetch new data from API')
    
    args = parser.parse_args()
    
    # 驗證環境變數
    api_key = os.getenv('NVD_API_KEY')
    if not api_key:
        print("Error: NVD_API_KEY environment variable not set")
        return
    
    # 初始化掃描器
    scanner = CVEScanner(api_key)
    
    # 處理強制更新
    if args.force_update:
        print("Force update enabled, clearing cache...")
        for f in os.listdir(scanner.cache_dir):
            if f.startswith('debug_') and f.endswith('.json'):
                os.remove(os.path.join(scanner.cache_dir, f))
    
    # 執行掃描
    if args.file:
        if not os.path.exists(args.file):
            print(f"Error: File {args.file} not found")
            return
        results = scanner.scan_packages(args.file)
    else:
        if not args.version:
            print("Error: Version is required when scanning a single package")
            return
        results = [ScanResult(
            package=args.package,
            version=args.version,
            vulnerabilities=scanner.fetch_vulnerabilities(args.package, args.version)
        )]
    
    # 生成報告
    generate_report(results, args.output)
    print(f"\nScan complete. Report generated in {args.output}")

if __name__ == "__main__":
    main()
