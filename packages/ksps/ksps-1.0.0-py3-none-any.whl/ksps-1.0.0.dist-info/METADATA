Metadata-Version: 2.4
Name: ksps
Version: 1.0.0
Summary: KPS - Ksmux Pub Sub: Client Python ultra-performant pour syst√®me pub/sub bas√© sur ksmux
Project-URL: Homepage, https://github.com/kamalshkeir/bbus
Project-URL: Repository, https://github.com/kamalshkeir/bbus
Project-URL: Documentation, https://github.com/kamalshkeir/bbus/blob/main/README.md
Author-email: Kamal Shkeir <kamalshkeir@gmail.com>
License: MIT
License-File: LICENSE
Keywords: asyncio,kamal,ksmux,ksps,messaging,pubsub,realtime,websocket
Classifier: Development Status :: 5 - Production/Stable
Classifier: Framework :: AsyncIO
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Internet :: WWW/HTTP :: Dynamic Content
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: System :: Networking
Requires-Python: >=3.11
Requires-Dist: orjson>=3.9.10
Requires-Dist: uvloop>=0.19.0; sys_platform != 'win32'
Requires-Dist: websockets>=12.0
Provides-Extra: all
Requires-Dist: aiofiles>=23.2.1; extra == 'all'
Requires-Dist: asyncio-mqtt>=0.16.1; extra == 'all'
Requires-Dist: black>=23.0.0; extra == 'all'
Requires-Dist: mypy>=1.5.0; extra == 'all'
Requires-Dist: pytest-asyncio>=0.21.0; extra == 'all'
Requires-Dist: pytest>=7.4.0; extra == 'all'
Requires-Dist: ruff>=0.1.0; extra == 'all'
Provides-Extra: dev
Requires-Dist: black>=23.0.0; extra == 'dev'
Requires-Dist: mypy>=1.5.0; extra == 'dev'
Requires-Dist: pytest-asyncio>=0.21.0; extra == 'dev'
Requires-Dist: pytest>=7.4.0; extra == 'dev'
Requires-Dist: ruff>=0.1.0; extra == 'dev'
Provides-Extra: files
Requires-Dist: aiofiles>=23.2.1; extra == 'files'
Provides-Extra: mqtt
Requires-Dist: asyncio-mqtt>=0.16.1; extra == 'mqtt'
Description-Content-Type: text/markdown

# üêç KPS - Ksmux Pub Sub Client Ultra-Performant

Client Python ultra-rapide pour le syst√®me pub/sub **KPS** (Ksmux Pub Sub) avec **asyncio**, **uvloop**, et **orjson**.

## üöÄ Installation Rapide avec UV

### Pr√©requis
- Python 3.11+
- [uv](https://github.com/astral-sh/uv) install√©

```bash
# Installer uv si pas d√©j√† fait
curl -LsSf https://astral.sh/uv/install.sh | sh

# Setup complet automatique
python setup.py setup
```

### Installation Manuelle
```bash
# Cr√©er l'environnement virtuel
uv venv

# Installer les d√©pendances
uv pip install websockets orjson uvloop

# D√©pendances de d√©veloppement (optionnel)
uv pip install pytest pytest-asyncio black ruff mypy
```

## ‚ö° Performance

### Optimisations Int√©gr√©es
- **asyncio** natif pour concurrence maximale
- **uvloop** pour 2-3x plus de performance (Linux/macOS)
- **orjson** pour JSON ultra-rapide (5-10x plus rapide)
- **WebSocket** optimis√© sans compression
- **ThreadPoolExecutor** pour callbacks utilisateur
- **Queue asynchrone** avec buffer 1024

### Benchmarks
```
üìä Publication: ~10,000 msg/s
üìä ACK System: ~5,000 ACK/s
üìä Latence: <1ms local, <10ms r√©seau
```

## üéØ API Identique

Le client Python a **exactement la m√™me API** que les clients Go et JavaScript :

```python
import asyncio
from client import Client

async def main():
    # Cr√©er le client
    client = await Client.NewClient(
        Id="my-python-app",
        Address="localhost:9313",
        Autorestart=True,
        OnId=lambda data, unsub: print(f"Direct: {data}"),
        OnDataWs=lambda data, conn: print(f"Message: {data}")
    )
    
    # Souscrire √† un topic
    unsub = await client.Subscribe("events", 
        lambda data, unsub: print(f"Re√ßu: {data}"))
    
    # Publier des messages
    await client.Publish("events", "Hello World!")
    await client.PublishToID("target-client", {"type": "direct"})
    await client.PublishToServer("remote:9313", {"relay": True})
    
    # Syst√®me ACK complet
    ack = await client.PublishWithAck("events", "Important!", 5.0)
    responses = await ack.Wait()  # Attendre tous les ACK
    
    ack2 = await client.PublishToIDWithAck("client-id", "Direct ACK", 3.0)
    response, ok = await ack2.WaitAny()  # Premier ACK
    
    # Gestion ACK avanc√©e
    status = await ack.GetStatus()  # Statut en temps r√©el
    complete = await ack.IsComplete()  # Tous re√ßus ?
    await ack.Cancel()  # Annuler l'attente
    
    await client.Close()

# Lancer avec uvloop automatique
asyncio.run(main())
```

## üß™ Tests et D√©veloppement

### Lancer les Tests
```bash
# Test complet avec le serveur Go
python test_python_client.py

# Ou avec uv
uv run python test_python_client.py
```

### Outils de D√©veloppement
```bash
# Formater le code
uv run black .

# Linter
uv run ruff check .

# Type checking
uv run mypy .

# Tests unitaires
uv run pytest
```

### Script de Setup Automatique
```bash
# Setup complet
python setup.py all

# Ou √©tape par √©tape
python setup.py setup    # Installation
python setup.py format   # Formatage
python setup.py test     # Tests
```

## üìã M√©thodes Disponibles

### Client
```python
# Connexion
client = await Client.NewClient(**options)
await client.Close()

# Pub/Sub basique
await client.Subscribe(topic, callback)
await client.Unsubscribe(topic)
await client.Publish(topic, data)

# Messages directs
await client.PublishToID(target_id, data)
await client.PublishToServer(addr, data, secure=False)

# Syst√®me ACK
ack = await client.PublishWithAck(topic, data, timeout)
ack = await client.PublishToIDWithAck(target_id, data, timeout)
```

### ClientAck
```python
# Attendre les r√©ponses
responses = await ack.Wait()           # Tous les ACK
response, ok = await ack.WaitAny()     # Premier ACK

# Gestion avanc√©e
status = await ack.GetStatus()         # Statut temps r√©el
complete = await ack.IsComplete()      # Tous re√ßus ?
await ack.Cancel()                     # Annuler
```

## üîß Configuration Avanc√©e

### Options de Connexion
```python
client = await Client.NewClient(
    Id="unique-client-id",           # ID du client
    Address="localhost:9313",        # Serveur
    Secure=False,                    # WSS si True
    Path="/ws/bus",                  # Chemin WebSocket
    Autorestart=True,                # Reconnexion auto
    RestartEvery=10.0,               # Intervalle (secondes)
    OnDataWs=callback_all_messages,  # Tous les messages
    OnId=callback_direct_messages,   # Messages directs
    OnClose=callback_on_close        # Fermeture
)
```

### Callbacks
```python
def handle_message(data, unsub_fn):
    """Callback pour messages de topic"""
    print(f"Re√ßu: {data}")
    # unsub_fn() pour se d√©sabonner

def handle_direct(data, subscriber):
    """Callback pour messages directs"""
    print(f"Direct: {data}")

def handle_all(data, conn):
    """Callback pour tous les messages WebSocket"""
    print(f"WS: {data}")
```

## üêõ Debugging

### Logs D√©taill√©s
```python
import logging
logging.basicConfig(level=logging.DEBUG)

# Le client affichera tous les d√©tails
client = await Client.NewClient(...)
```

### Monitoring Performance
```python
import time

start = time.time()
await client.Publish("test", "data")
print(f"Publish: {(time.time() - start)*1000:.2f}ms")
```

## üîó Int√©gration

### Avec FastAPI
```python
from fastapi import FastAPI
from client import Client

app = FastAPI()
client = None

@app.on_event("startup")
async def startup():
    global client
    client = await Client.NewClient(Address="localhost:9313")

@app.post("/publish/{topic}")
async def publish(topic: str, data: dict):
    await client.Publish(topic, data)
    return {"status": "published"}
```

### Avec Django Channels
```python
from channels.generic.websocket import AsyncWebsocketConsumer
from client import Client

class BusConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.client = await Client.NewClient(
            Address="localhost:9313",
            OnId=self.handle_bus_message
        )
        await self.accept()
    
    async def handle_bus_message(self, data, unsub):
        await self.send_json(data)
```

## üì¶ Distribution

### Build avec uv
```bash
# Build du package
uv build

# Publier sur PyPI
uv publish
```

### Docker
```dockerfile
FROM python:3.12-slim

# Installer uv
RUN pip install uv

# Copier les fichiers
COPY . /app
WORKDIR /app

# Installer les d√©pendances
RUN uv pip install --system .

# Lancer l'application
CMD ["python", "test_python_client.py"]
```

## ü§ù Compatibilit√©

- ‚úÖ **Python 3.11+**
- ‚úÖ **Linux** (uvloop optimal)
- ‚úÖ **macOS** (uvloop optimal)  
- ‚úÖ **Windows** (asyncio standard)
- ‚úÖ **Docker/Kubernetes**
- ‚úÖ **FastAPI/Django/Flask**

## üìà Roadmap

- [ ] Support MQTT bridge
- [ ] M√©triques Prometheus
- [ ] Clustering automatique
- [ ] Compression adaptative
- [ ] Rate limiting int√©gr√©

---

**Le client Python le plus rapide pour KPS (Ksmux Pub Sub) !** üöÄüêç 