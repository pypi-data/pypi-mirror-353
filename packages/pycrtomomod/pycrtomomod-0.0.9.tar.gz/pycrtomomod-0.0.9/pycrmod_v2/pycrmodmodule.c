/* File: pycrmodmodule.c
 * This file is auto-generated with f2py (version:2.2.4).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date: Thu May 22 11:28:43 2025
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PY_SSIZE_T_CLEAN
#define PY_SSIZE_T_CLEAN
#endif /* PY_SSIZE_T_CLEAN */

/* Unconditionally included */
#include <Python.h>
#include <numpy/npy_os.h>

/*********************** See f2py2e/cfuncs.py: includes ***********************/
#include "fortranobject.h"
/*need_includes0*/

/**************** See f2py2e/rules.py: mod_rules['modulebody'] ****************/
static PyObject *pycrmod_error;
static PyObject *pycrmod_module;

/*********************** See f2py2e/cfuncs.py: typedefs ***********************/
/*need_typedefs*/

/****************** See f2py2e/cfuncs.py: typedefs_generated ******************/
/*need_typedefs_generated*/

/********************** See f2py2e/cfuncs.py: cppmacros **********************/

#ifdef DEBUGCFUNCS
#define CFUNCSMESS(mess) fprintf(stderr,"debug-capi:"mess);
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) \
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");
#else
#define CFUNCSMESS(mess)
#define CFUNCSMESSPY(mess,obj)
#endif


#ifndef max
#define max(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a < b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b) ((a < b) ? (a) : (b))
#endif


#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F
#else
#define F_FUNC(f,F) _##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F##_
#else
#define F_FUNC(f,F) _##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F
#else
#define F_FUNC(f,F) f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F##_
#else
#define F_FUNC(f,F) f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_)
#else
#define F_FUNC_US(f,F) F_FUNC(f,F)
#endif


/************************ See f2py2e/cfuncs.py: cfuncs ************************/
/*need_cfuncs*/

/********************* See f2py2e/cfuncs.py: userincludes *********************/
/*need_userincludes*/

/********************* See f2py2e/capi_rules.py: usercode *********************/


/* See f2py2e/rules.py */
/*eof externroutines*/

/******************** See f2py2e/capi_rules.py: usercode1 ********************/


/******************* See f2py2e/cb_rules.py: buildcallback *******************/
/*need_callbacks*/

/*********************** See f2py2e/rules.py: buildapi ***********************/

/**************************** forward_calculation ****************************/
static char doc_f2py_rout_pycrmod_fem_pyw_forward_calculation[] = "\
return_value = forward_calculation()\n\nWrapper for ``forward_calculation``.\
\n\nReturns\n-------\n"
"return_value : int";
/*  */
static PyObject *f2py_rout_pycrmod_fem_pyw_forward_calculation(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    int return_value = 0;
    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:pycrmod.fem_pyw.forward_calculation",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
    /* Processing variable return_value */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
                (*f2py_func)(&return_value);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("i",return_value);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    /* End of cleaning variable return_value */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of forward_calculation *************************/
/*eof body*/

/******************* See f2py2e/f90mod_rules.py: buildhooks *******************/

static FortranDataDef f2py_elemmod_def[] = {
  {"sanz",0,{{-1}},NPY_INT, 1},
  {"typanz",0,{{-1}},NPY_INT, 1},
  {"mb",0,{{-1}},NPY_INT, 1},
  {"typ",1,{{-1}},NPY_INT, 1},
  {"nelanz",1,{{-1}},NPY_INT, 1},
  {"selanz",1,{{-1}},NPY_INT, 1},
  {"snr",1,{{-1}},NPY_INT, 1},
  {"sx",1,{{-1}},NPY_DOUBLE, 1},
  {"sy",1,{{-1}},NPY_DOUBLE, 1},
  {"espx",1,{{-1}},NPY_DOUBLE, 1},
  {"espy",1,{{-1}},NPY_DOUBLE, 1},
  {"nachbar",2,{{-1,-1}},NPY_INT, 1},
  {"nrel",2,{{-1,-1}},NPY_INT, 1},
  {"elanz",0,{{-1}},NPY_INT, 1},
  {"relanz",0,{{-1}},NPY_INT, 1},
  {"rnr",1,{{-1}},NPY_INT, 1},
  {"max_nr_element_nodes",0,{{-1}},NPY_INT, 1},
  {"esp_min",0,{{-1}},NPY_DOUBLE, 1},
  {"esp_max",0,{{-1}},NPY_DOUBLE, 1},
  {"esp_mit",0,{{-1}},NPY_DOUBLE, 1},
  {"esp_med",0,{{-1}},NPY_DOUBLE, 1},
  {"esp_std",0,{{-1}},NPY_DOUBLE, 1},
  {"grid_min",0,{{-1}},NPY_DOUBLE, 1},
  {"grid_max",0,{{-1}},NPY_DOUBLE, 1},
  {"grid_minx",0,{{-1}},NPY_DOUBLE, 1},
  {"grid_miny",0,{{-1}},NPY_DOUBLE, 1},
  {"grid_maxx",0,{{-1}},NPY_DOUBLE, 1},
  {"grid_maxy",0,{{-1}},NPY_DOUBLE, 1},
  {"lsink",0,{{-1}},NPY_INT, 1},
  {"nsink",0,{{-1}},NPY_INT, 1},
  {"lrandb2",0,{{-1}},NPY_INT, 1},
  {"sytop",0,{{-1}},NPY_DOUBLE, 1},
  {"xk",1,{{-1}},NPY_DOUBLE, 1},
  {"yk",1,{{-1}},NPY_DOUBLE, 1},
  {"elmam",2,{{-1,-1}},NPY_DOUBLE, 1},
  {"elmas",2,{{-1,-1}},NPY_DOUBLE, 1},
  {"elve",1,{{-1}},NPY_DOUBLE, 1},
  {"decexi",0,{{-1}},NPY_INT, 1},
  {"edecoup",2,{{-1,-1}},NPY_INT, 1},
  {"edecstr",1,{{-1}},NPY_DOUBLE, 1},
  {"decanz",0,{{-1}},NPY_INT, 1},
  {"nr_elec_capacitances",0,{{-1}},NPY_INT, 1},
  {"elec_caps_file_exists",0,{{-1}},NPY_INT, 1},
  {"electrode_capacitances",1,{{-1}},NPY_DOUBLE, 1},
  {NULL}
};

static void f2py_setup_elemmod(char *sanz,char *typanz,char *mb,void (*typ)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*nelanz)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*selanz)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*snr)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*sx)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*sy)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*espx)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*espy)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*nachbar)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*nrel)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char *elanz,char *relanz,void (*rnr)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char *max_nr_element_nodes,char *esp_min,char *esp_max,char *esp_mit,char *esp_med,char *esp_std,char *grid_min,char *grid_max,char *grid_minx,char *grid_miny,char *grid_maxx,char *grid_maxy,char *lsink,char *nsink,char *lrandb2,char *sytop,void (*xk)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*yk)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*elmam)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*elmas)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*elve)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char *decexi,void (*edecoup)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*edecstr)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char *decanz,char *nr_elec_capacitances,char *elec_caps_file_exists,void (*electrode_capacitances)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)) {
  int i_f2py=0;
  f2py_elemmod_def[i_f2py++].data = sanz;
  f2py_elemmod_def[i_f2py++].data = typanz;
  f2py_elemmod_def[i_f2py++].data = mb;
  f2py_elemmod_def[i_f2py++].func = typ;
  f2py_elemmod_def[i_f2py++].func = nelanz;
  f2py_elemmod_def[i_f2py++].func = selanz;
  f2py_elemmod_def[i_f2py++].func = snr;
  f2py_elemmod_def[i_f2py++].func = sx;
  f2py_elemmod_def[i_f2py++].func = sy;
  f2py_elemmod_def[i_f2py++].func = espx;
  f2py_elemmod_def[i_f2py++].func = espy;
  f2py_elemmod_def[i_f2py++].func = nachbar;
  f2py_elemmod_def[i_f2py++].func = nrel;
  f2py_elemmod_def[i_f2py++].data = elanz;
  f2py_elemmod_def[i_f2py++].data = relanz;
  f2py_elemmod_def[i_f2py++].func = rnr;
  f2py_elemmod_def[i_f2py++].data = max_nr_element_nodes;
  f2py_elemmod_def[i_f2py++].data = esp_min;
  f2py_elemmod_def[i_f2py++].data = esp_max;
  f2py_elemmod_def[i_f2py++].data = esp_mit;
  f2py_elemmod_def[i_f2py++].data = esp_med;
  f2py_elemmod_def[i_f2py++].data = esp_std;
  f2py_elemmod_def[i_f2py++].data = grid_min;
  f2py_elemmod_def[i_f2py++].data = grid_max;
  f2py_elemmod_def[i_f2py++].data = grid_minx;
  f2py_elemmod_def[i_f2py++].data = grid_miny;
  f2py_elemmod_def[i_f2py++].data = grid_maxx;
  f2py_elemmod_def[i_f2py++].data = grid_maxy;
  f2py_elemmod_def[i_f2py++].data = lsink;
  f2py_elemmod_def[i_f2py++].data = nsink;
  f2py_elemmod_def[i_f2py++].data = lrandb2;
  f2py_elemmod_def[i_f2py++].data = sytop;
  f2py_elemmod_def[i_f2py++].func = xk;
  f2py_elemmod_def[i_f2py++].func = yk;
  f2py_elemmod_def[i_f2py++].func = elmam;
  f2py_elemmod_def[i_f2py++].func = elmas;
  f2py_elemmod_def[i_f2py++].func = elve;
  f2py_elemmod_def[i_f2py++].data = decexi;
  f2py_elemmod_def[i_f2py++].func = edecoup;
  f2py_elemmod_def[i_f2py++].func = edecstr;
  f2py_elemmod_def[i_f2py++].data = decanz;
  f2py_elemmod_def[i_f2py++].data = nr_elec_capacitances;
  f2py_elemmod_def[i_f2py++].data = elec_caps_file_exists;
  f2py_elemmod_def[i_f2py++].func = electrode_capacitances;
}
extern void F_FUNC(f2pyinitelemmod,F2PYINITELEMMOD)(void (*)(char*,char*,char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char*,char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char*,char*,char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)));
static void f2py_init_elemmod(void) {
  F_FUNC(f2pyinitelemmod,F2PYINITELEMMOD)(f2py_setup_elemmod);
}


static FortranDataDef f2py_alloci_def[] = {
  {"a",1,{{-1}},NPY_CFLOAT, 1},
  {"kpot",3,{{-1,-1,-1}},NPY_CFLOAT, 1},
  {"hpot",2,{{-1,-1}},NPY_CFLOAT, 1},
  {"sens",2,{{-1,-1}},NPY_CFLOAT, 1},
  {"csens",1,{{-1}},NPY_DOUBLE, 1},
  {"adc",1,{{-1}},NPY_DOUBLE, 1},
  {"kpotdc",3,{{-1,-1,-1}},NPY_DOUBLE, 1},
  {"hpotdc",2,{{-1,-1}},NPY_DOUBLE, 1},
  {"sensdc",2,{{-1,-1}},NPY_DOUBLE, 1},
  {"cov_d",2,{{-1,-1}},NPY_DOUBLE, 1},
  {"smatm",2,{{-1,-1}},NPY_DOUBLE, 1},
  {"rnd_r",1,{{-1}},NPY_DOUBLE, 1},
  {"rnd_p",1,{{-1}},NPY_DOUBLE, 1},
  {"ata",2,{{-1,-1}},NPY_DOUBLE, 1},
  {"ata_reg",2,{{-1,-1}},NPY_DOUBLE, 1},
  {"cov_m",2,{{-1,-1}},NPY_DOUBLE, 1},
  {NULL}
};

static void f2py_setup_alloci(void (*a)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*kpot)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*hpot)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*sens)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*csens)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*adc)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*kpotdc)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*hpotdc)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*sensdc)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*cov_d)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*smatm)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*rnd_r)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*rnd_p)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*ata)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*ata_reg)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*cov_m)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)) {
  int i_f2py=0;
  f2py_alloci_def[i_f2py++].func = a;
  f2py_alloci_def[i_f2py++].func = kpot;
  f2py_alloci_def[i_f2py++].func = hpot;
  f2py_alloci_def[i_f2py++].func = sens;
  f2py_alloci_def[i_f2py++].func = csens;
  f2py_alloci_def[i_f2py++].func = adc;
  f2py_alloci_def[i_f2py++].func = kpotdc;
  f2py_alloci_def[i_f2py++].func = hpotdc;
  f2py_alloci_def[i_f2py++].func = sensdc;
  f2py_alloci_def[i_f2py++].func = cov_d;
  f2py_alloci_def[i_f2py++].func = smatm;
  f2py_alloci_def[i_f2py++].func = rnd_r;
  f2py_alloci_def[i_f2py++].func = rnd_p;
  f2py_alloci_def[i_f2py++].func = ata;
  f2py_alloci_def[i_f2py++].func = ata_reg;
  f2py_alloci_def[i_f2py++].func = cov_m;
}
extern void F_FUNC(f2pyinitalloci,F2PYINITALLOCI)(void (*)(void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)));
static void f2py_init_alloci(void) {
  F_FUNC(f2pyinitalloci,F2PYINITALLOCI)(f2py_setup_alloci);
}


static FortranDataDef f2py_tic_toc_def[] = {
  {"fix_f2py",0,{{-1}},NPY_INT, 1},
  {NULL}
};

static void f2py_setup_tic_toc(char *fix_f2py) {
  int i_f2py=0;
  f2py_tic_toc_def[i_f2py++].data = fix_f2py;
}
extern void F_FUNC_US(f2pyinittic_toc,F2PYINITTIC_TOC)(void (*)(char*));
static void f2py_init_tic_toc(void) {
  F_FUNC_US(f2pyinittic_toc,F2PYINITTIC_TOC)(f2py_setup_tic_toc);
}


static FortranDataDef f2py_femmod_def[] = {
  {"pot",1,{{-1}},NPY_CFLOAT, 1},
  {"pota",1,{{-1}},NPY_CFLOAT, 1},
  {"b",1,{{-1}},NPY_CFLOAT, 1},
  {"bdc",1,{{-1}},NPY_DOUBLE, 1},
  {"fak",1,{{-1}},NPY_DOUBLE, 1},
  {"elbg",3,{{-1,-1,-1}},NPY_DOUBLE, 1},
  {"relbg",2,{{-1,-1}},NPY_DOUBLE, 1},
  {"kg",3,{{-1,-1,-1}},NPY_DOUBLE, 1},
  {"lbeta",0,{{-1}},NPY_INT, 1},
  {"lrandb",0,{{-1}},NPY_INT, 1},
  {"lsr",0,{{-1}},NPY_INT, 1},
  {"ldc",0,{{-1}},NPY_INT, 1},
  {NULL}
};

static void f2py_setup_femmod(void (*pot)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*pota)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*b)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*bdc)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*fak)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*elbg)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*relbg)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*kg)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char *lbeta,char *lrandb,char *lsr,char *ldc) {
  int i_f2py=0;
  f2py_femmod_def[i_f2py++].func = pot;
  f2py_femmod_def[i_f2py++].func = pota;
  f2py_femmod_def[i_f2py++].func = b;
  f2py_femmod_def[i_f2py++].func = bdc;
  f2py_femmod_def[i_f2py++].func = fak;
  f2py_femmod_def[i_f2py++].func = elbg;
  f2py_femmod_def[i_f2py++].func = relbg;
  f2py_femmod_def[i_f2py++].func = kg;
  f2py_femmod_def[i_f2py++].data = lbeta;
  f2py_femmod_def[i_f2py++].data = lrandb;
  f2py_femmod_def[i_f2py++].data = lsr;
  f2py_femmod_def[i_f2py++].data = ldc;
}
extern void F_FUNC(f2pyinitfemmod,F2PYINITFEMMOD)(void (*)(void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char*,char*,char*,char*));
static void f2py_init_femmod(void) {
  F_FUNC(f2pyinitfemmod,F2PYINITFEMMOD)(f2py_setup_femmod);
}


static FortranDataDef f2py_datmod_def[] = {
  {"nanz",0,{{-1}},NPY_INT, 1},
  {"strnr",1,{{-1}},NPY_INT, 1},
  {"strom",1,{{-1}},NPY_DOUBLE, 1},
  {"vnr",1,{{-1}},NPY_INT, 1},
  {"volt",1,{{-1}},NPY_CFLOAT, 1},
  {"sigmaa",1,{{-1}},NPY_CFLOAT, 1},
  {"sgmaa2",1,{{-1}},NPY_CFLOAT, 1},
  {"kfak",1,{{-1}},NPY_DOUBLE, 1},
  {"wmatdp",1,{{-1}},NPY_DOUBLE, 1},
  {"wmatdr",1,{{-1}},NPY_DOUBLE, 1},
  {"wmatd_cri",1,{{-1}},NPY_DOUBLE, 1},
  {"stabw0",0,{{-1}},NPY_DOUBLE, 1},
  {"stabm0",0,{{-1}},NPY_DOUBLE, 1},
  {"stabp0",0,{{-1}},NPY_DOUBLE, 1},
  {"stabpa1",0,{{-1}},NPY_DOUBLE, 1},
  {"stabpb",0,{{-1}},NPY_DOUBLE, 1},
  {"stabpa2",0,{{-1}},NPY_DOUBLE, 1},
  {"lindiv",0,{{-1}},NPY_INT, 1},
  {"lratio",0,{{-1}},NPY_INT, 1},
  {"lpol",0,{{-1}},NPY_INT, 1},
  {"lnse",0,{{-1}},NPY_INT, 1},
  {"lnse2",0,{{-1}},NPY_INT, 1},
  {"iseed",0,{{-1}},NPY_INT, 1},
  {"nstabw0",0,{{-1}},NPY_DOUBLE, 1},
  {"nstabm0",0,{{-1}},NPY_DOUBLE, 1},
  {"nstabpb",0,{{-1}},NPY_DOUBLE, 1},
  {"nstabpa1",0,{{-1}},NPY_DOUBLE, 1},
  {"nstabpa2",0,{{-1}},NPY_DOUBLE, 1},
  {"nstabp0",0,{{-1}},NPY_DOUBLE, 1},
  {"npol",0,{{-1}},NPY_INT, 1},
  {NULL}
};

static void f2py_setup_datmod(char *nanz,void (*strnr)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*strom)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*vnr)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*volt)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*sigmaa)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*sgmaa2)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*kfak)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*wmatdp)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*wmatdr)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*wmatd_cri)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char *stabw0,char *stabm0,char *stabp0,char *stabpa1,char *stabpb,char *stabpa2,char *lindiv,char *lratio,char *lpol,char *lnse,char *lnse2,char *iseed,char *nstabw0,char *nstabm0,char *nstabpb,char *nstabpa1,char *nstabpa2,char *nstabp0,char *npol) {
  int i_f2py=0;
  f2py_datmod_def[i_f2py++].data = nanz;
  f2py_datmod_def[i_f2py++].func = strnr;
  f2py_datmod_def[i_f2py++].func = strom;
  f2py_datmod_def[i_f2py++].func = vnr;
  f2py_datmod_def[i_f2py++].func = volt;
  f2py_datmod_def[i_f2py++].func = sigmaa;
  f2py_datmod_def[i_f2py++].func = sgmaa2;
  f2py_datmod_def[i_f2py++].func = kfak;
  f2py_datmod_def[i_f2py++].func = wmatdp;
  f2py_datmod_def[i_f2py++].func = wmatdr;
  f2py_datmod_def[i_f2py++].func = wmatd_cri;
  f2py_datmod_def[i_f2py++].data = stabw0;
  f2py_datmod_def[i_f2py++].data = stabm0;
  f2py_datmod_def[i_f2py++].data = stabp0;
  f2py_datmod_def[i_f2py++].data = stabpa1;
  f2py_datmod_def[i_f2py++].data = stabpb;
  f2py_datmod_def[i_f2py++].data = stabpa2;
  f2py_datmod_def[i_f2py++].data = lindiv;
  f2py_datmod_def[i_f2py++].data = lratio;
  f2py_datmod_def[i_f2py++].data = lpol;
  f2py_datmod_def[i_f2py++].data = lnse;
  f2py_datmod_def[i_f2py++].data = lnse2;
  f2py_datmod_def[i_f2py++].data = iseed;
  f2py_datmod_def[i_f2py++].data = nstabw0;
  f2py_datmod_def[i_f2py++].data = nstabm0;
  f2py_datmod_def[i_f2py++].data = nstabpb;
  f2py_datmod_def[i_f2py++].data = nstabpa1;
  f2py_datmod_def[i_f2py++].data = nstabpa2;
  f2py_datmod_def[i_f2py++].data = nstabp0;
  f2py_datmod_def[i_f2py++].data = npol;
}
extern void F_FUNC(f2pyinitdatmod,F2PYINITDATMOD)(void (*)(char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_datmod(void) {
  F_FUNC(f2pyinitdatmod,F2PYINITDATMOD)(f2py_setup_datmod);
}


static FortranDataDef f2py_sigmamod_def[] = {
  {"sigma0",0,{{-1}},NPY_CFLOAT, 1},
  {"sigma",1,{{-1}},NPY_CFLOAT, 1},
  {"sigma2",1,{{-1}},NPY_CFLOAT, 1},
  {"bet0",0,{{-1}},NPY_DOUBLE, 1},
  {"pha0",0,{{-1}},NPY_DOUBLE, 1},
  {"lrho0",0,{{-1}},NPY_INT, 1},
  {"lstart",0,{{-1}},NPY_INT, 1},
  {"iseedpri",0,{{-1}},NPY_INT, 1},
  {"modl_stdn",0,{{-1}},NPY_DOUBLE, 1},
  {NULL}
};

static void f2py_setup_sigmamod(char *sigma0,void (*sigma)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*sigma2)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char *bet0,char *pha0,char *lrho0,char *lstart,char *iseedpri,char *modl_stdn) {
  int i_f2py=0;
  f2py_sigmamod_def[i_f2py++].data = sigma0;
  f2py_sigmamod_def[i_f2py++].func = sigma;
  f2py_sigmamod_def[i_f2py++].func = sigma2;
  f2py_sigmamod_def[i_f2py++].data = bet0;
  f2py_sigmamod_def[i_f2py++].data = pha0;
  f2py_sigmamod_def[i_f2py++].data = lrho0;
  f2py_sigmamod_def[i_f2py++].data = lstart;
  f2py_sigmamod_def[i_f2py++].data = iseedpri;
  f2py_sigmamod_def[i_f2py++].data = modl_stdn;
}
extern void F_FUNC(f2pyinitsigmamod,F2PYINITSIGMAMOD)(void (*)(char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char*,char*,char*,char*,char*,char*));
static void f2py_init_sigmamod(void) {
  F_FUNC(f2pyinitsigmamod,F2PYINITSIGMAMOD)(f2py_setup_sigmamod);
}


static FortranDataDef f2py_electrmod_def[] = {
  {"eanz",0,{{-1}},NPY_INT, 1},
  {"enr",1,{{-1}},NPY_INT, 1},
  {NULL}
};

static void f2py_setup_electrmod(char *eanz,void (*enr)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)) {
  int i_f2py=0;
  f2py_electrmod_def[i_f2py++].data = eanz;
  f2py_electrmod_def[i_f2py++].func = enr;
}
extern void F_FUNC(f2pyinitelectrmod,F2PYINITELECTRMOD)(void (*)(char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)));
static void f2py_init_electrmod(void) {
  F_FUNC(f2pyinitelectrmod,F2PYINITELECTRMOD)(f2py_setup_electrmod);
}


static FortranDataDef f2py_modelmod_def[] = {
  {"manz",0,{{-1}},NPY_INT, 1},
  {"mnr",1,{{-1}},NPY_INT, 1},
  {"w_ref_re",1,{{-1}},NPY_DOUBLE, 1},
  {"w_ref_im",1,{{-1}},NPY_DOUBLE, 1},
  {"ind_ref_grad",1,{{-1}},NPY_INT, 1},
  {NULL}
};

static void f2py_setup_modelmod(char *manz,void (*mnr)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*w_ref_re)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*w_ref_im)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*ind_ref_grad)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)) {
  int i_f2py=0;
  f2py_modelmod_def[i_f2py++].data = manz;
  f2py_modelmod_def[i_f2py++].func = mnr;
  f2py_modelmod_def[i_f2py++].func = w_ref_re;
  f2py_modelmod_def[i_f2py++].func = w_ref_im;
  f2py_modelmod_def[i_f2py++].func = ind_ref_grad;
}
extern void F_FUNC(f2pyinitmodelmod,F2PYINITMODELMOD)(void (*)(char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)));
static void f2py_init_modelmod(void) {
  F_FUNC(f2pyinitmodelmod,F2PYINITMODELMOD)(f2py_setup_modelmod);
}


static FortranDataDef f2py_make_noise_def[] = {
  {"f2py_fix",0,{{-1}},NPY_INT, 1},
  {NULL}
};

static void f2py_setup_make_noise(char *f2py_fix) {
  int i_f2py=0;
  f2py_make_noise_def[i_f2py++].data = f2py_fix;
}
extern void F_FUNC_US(f2pyinitmake_noise,F2PYINITMAKE_NOISE)(void (*)(char*));
static void f2py_init_make_noise(void) {
  F_FUNC_US(f2pyinitmake_noise,F2PYINITMAKE_NOISE)(f2py_setup_make_noise);
}


static FortranDataDef f2py_invmod_def[] = {
  {"dat",1,{{-1}},NPY_CFLOAT, 1},
  {"par",1,{{-1}},NPY_CFLOAT, 1},
  {"dpar",1,{{-1}},NPY_CFLOAT, 1},
  {"dpar2",1,{{-1}},NPY_CFLOAT, 1},
  {"d0",1,{{-1}},NPY_CFLOAT, 1},
  {"m0",1,{{-1}},NPY_CFLOAT, 1},
  {"fm0",1,{{-1}},NPY_CFLOAT, 1},
  {"m_ref",1,{{-1}},NPY_CFLOAT, 1},
  {"wmatd",1,{{-1}},NPY_DOUBLE, 1},
  {"wmatd2",1,{{-1}},NPY_DOUBLE, 1},
  {"par_vari",0,{{-1}},NPY_DOUBLE, 1},
  {"wdfak",1,{{-1}},NPY_INT, 1},
  {"lfpi",0,{{-1}},NPY_INT, 1},
  {"wmfak",1,{{-1}},NPY_INT, 1},
  {NULL}
};

static void f2py_setup_invmod(void (*dat)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*par)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*dpar)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*dpar2)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*d0)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*m0)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*fm0)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*m_ref)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*wmatd)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*wmatd2)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char *par_vari,void (*wdfak)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char *lfpi,void (*wmfak)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)) {
  int i_f2py=0;
  f2py_invmod_def[i_f2py++].func = dat;
  f2py_invmod_def[i_f2py++].func = par;
  f2py_invmod_def[i_f2py++].func = dpar;
  f2py_invmod_def[i_f2py++].func = dpar2;
  f2py_invmod_def[i_f2py++].func = d0;
  f2py_invmod_def[i_f2py++].func = m0;
  f2py_invmod_def[i_f2py++].func = fm0;
  f2py_invmod_def[i_f2py++].func = m_ref;
  f2py_invmod_def[i_f2py++].func = wmatd;
  f2py_invmod_def[i_f2py++].func = wmatd2;
  f2py_invmod_def[i_f2py++].data = par_vari;
  f2py_invmod_def[i_f2py++].func = wdfak;
  f2py_invmod_def[i_f2py++].data = lfpi;
  f2py_invmod_def[i_f2py++].func = wmfak;
}
extern void F_FUNC(f2pyinitinvmod,F2PYINITINVMOD)(void (*)(void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)));
static void f2py_init_invmod(void) {
  F_FUNC(f2pyinitinvmod,F2PYINITINVMOD)(f2py_setup_invmod);
}


static FortranDataDef f2py_wavenmod_def[] = {
  {"kwnanz",0,{{-1}},NPY_INT, 1},
  {"swrtr",0,{{-1}},NPY_INT, 1},
  {"kwn",1,{{-1}},NPY_DOUBLE, 1},
  {"kwnwi",1,{{-1}},NPY_DOUBLE, 1},
  {"amin",0,{{-1}},NPY_DOUBLE, 1},
  {"amax",0,{{-1}},NPY_DOUBLE, 1},
  {NULL}
};

static void f2py_setup_wavenmod(char *kwnanz,char *swrtr,void (*kwn)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*kwnwi)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char *amin,char *amax) {
  int i_f2py=0;
  f2py_wavenmod_def[i_f2py++].data = kwnanz;
  f2py_wavenmod_def[i_f2py++].data = swrtr;
  f2py_wavenmod_def[i_f2py++].func = kwn;
  f2py_wavenmod_def[i_f2py++].func = kwnwi;
  f2py_wavenmod_def[i_f2py++].data = amin;
  f2py_wavenmod_def[i_f2py++].data = amax;
}
extern void F_FUNC(f2pyinitwavenmod,F2PYINITWAVENMOD)(void (*)(char*,char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char*,char*));
static void f2py_init_wavenmod(void) {
  F_FUNC(f2pyinitwavenmod,F2PYINITWAVENMOD)(f2py_setup_wavenmod);
}


static FortranDataDef f2py_randbmod_def[] = {
  {"rwdanz",0,{{-1}},NPY_INT, 1},
  {"rwdnr",1,{{-1}},NPY_INT, 1},
  {"rwddc",1,{{-1}},NPY_DOUBLE, 1},
  {"rwd",1,{{-1}},NPY_CFLOAT, 1},
  {"rwdbnr",0,{{-1}},NPY_INT, 1},
  {"rwnanz",0,{{-1}},NPY_INT, 1},
  {"rwndc",1,{{-1}},NPY_DOUBLE, 1},
  {"rwn",1,{{-1}},NPY_CFLOAT, 1},
  {NULL}
};

static void f2py_setup_randbmod(char *rwdanz,void (*rwdnr)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*rwddc)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*rwd)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char *rwdbnr,char *rwnanz,void (*rwndc)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*rwn)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)) {
  int i_f2py=0;
  f2py_randbmod_def[i_f2py++].data = rwdanz;
  f2py_randbmod_def[i_f2py++].func = rwdnr;
  f2py_randbmod_def[i_f2py++].func = rwddc;
  f2py_randbmod_def[i_f2py++].func = rwd;
  f2py_randbmod_def[i_f2py++].data = rwdbnr;
  f2py_randbmod_def[i_f2py++].data = rwnanz;
  f2py_randbmod_def[i_f2py++].func = rwndc;
  f2py_randbmod_def[i_f2py++].func = rwn;
}
extern void F_FUNC(f2pyinitrandbmod,F2PYINITRANDBMOD)(void (*)(char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),char*,char*,void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)));
static void f2py_init_randbmod(void) {
  F_FUNC(f2pyinitrandbmod,F2PYINITRANDBMOD)(f2py_setup_randbmod);
}


static FortranDataDef f2py_errmod_def[] = {
  {"errnr",0,{{-1}},NPY_INT, 1},
  {"fperr",0,{{-1}},NPY_INT, 1},
  {"fprun",0,{{-1}},NPY_INT, 1},
  {"fpinv",0,{{-1}},NPY_INT, 1},
  {"fpcjg",0,{{-1}},NPY_INT, 1},
  {"fpeps",0,{{-1}},NPY_INT, 1},
  {"fpcfg",0,{{-1}},NPY_INT, 1},
  {"errflag",0,{{-1}},NPY_INT, 1},
  {"fetxt",0,{{-1}},NPY_STRING, 256},
  {NULL}
};

static void f2py_setup_errmod(char *errnr,char *fperr,char *fprun,char *fpinv,char *fpcjg,char *fpeps,char *fpcfg,char *errflag,char *fetxt) {
  int i_f2py=0;
  f2py_errmod_def[i_f2py++].data = errnr;
  f2py_errmod_def[i_f2py++].data = fperr;
  f2py_errmod_def[i_f2py++].data = fprun;
  f2py_errmod_def[i_f2py++].data = fpinv;
  f2py_errmod_def[i_f2py++].data = fpcjg;
  f2py_errmod_def[i_f2py++].data = fpeps;
  f2py_errmod_def[i_f2py++].data = fpcfg;
  f2py_errmod_def[i_f2py++].data = errflag;
  f2py_errmod_def[i_f2py++].data = fetxt;
}
extern void F_FUNC(f2pyiniterrmod,F2PYINITERRMOD)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_errmod(void) {
  F_FUNC(f2pyiniterrmod,F2PYINITERRMOD)(f2py_setup_errmod);
}


static FortranDataDef f2py_konvmod_def[] = {
  {"lam",0,{{-1}},NPY_DOUBLE, 1},
  {"lammax",0,{{-1}},NPY_DOUBLE, 1},
  {"lam_cri",0,{{-1}},NPY_DOUBLE, 1},
  {"lamnull_cri",0,{{-1}},NPY_DOUBLE, 1},
  {"lamnull_fpi",0,{{-1}},NPY_DOUBLE, 1},
  {"lam_ref",0,{{-1}},NPY_DOUBLE, 1},
  {"lam_ref_sw",0,{{-1}},NPY_INT, 1},
  {"lamfix",0,{{-1}},NPY_DOUBLE, 1},
  {"dlam",0,{{-1}},NPY_DOUBLE, 1},
  {"dlalt",0,{{-1}},NPY_DOUBLE, 1},
  {"nlam",0,{{-1}},NPY_INT, 1},
  {"alam",0,{{-1}},NPY_DOUBLE, 1},
  {"fstart",0,{{-1}},NPY_DOUBLE, 1},
  {"fstop",0,{{-1}},NPY_DOUBLE, 1},
  {"step",0,{{-1}},NPY_DOUBLE, 1},
  {"stpalt",0,{{-1}},NPY_DOUBLE, 1},
  {"stpmin",0,{{-1}},NPY_DOUBLE, 1},
  {"llam",0,{{-1}},NPY_INT, 1},
  {"lstep",0,{{-1}},NPY_INT, 1},
  {"ldlami",0,{{-1}},NPY_INT, 1},
  {"ldlamf",0,{{-1}},NPY_INT, 1},
  {"llamf",0,{{-1}},NPY_INT, 1},
  {"lfstep",0,{{-1}},NPY_INT, 1},
  {"nrmsd",0,{{-1}},NPY_DOUBLE, 1},
  {"rmsalt",0,{{-1}},NPY_DOUBLE, 1},
  {"rmsreg",0,{{-1}},NPY_DOUBLE, 1},
  {"rmssum",0,{{-1}},NPY_DOUBLE, 1},
  {"betrms",0,{{-1}},NPY_DOUBLE, 1},
  {"pharms",0,{{-1}},NPY_DOUBLE, 1},
  {"rough",0,{{-1}},NPY_DOUBLE, 1},
  {"nrmsdm",0,{{-1}},NPY_DOUBLE, 1},
  {"mqrms",0,{{-1}},NPY_DOUBLE, 1},
  {"l1min",0,{{-1}},NPY_DOUBLE, 1},
  {"l1rat",0,{{-1}},NPY_DOUBLE, 1},
  {"bdpar",0,{{-1}},NPY_DOUBLE, 1},
  {"bdmin",0,{{-1}},NPY_DOUBLE, 1},
  {"nx",0,{{-1}},NPY_INT, 1},
  {"nz",0,{{-1}},NPY_INT, 1},
  {"itmax",0,{{-1}},NPY_INT, 1},
  {"it",0,{{-1}},NPY_INT, 1},
  {"itr",0,{{-1}},NPY_INT, 1},
  {"alfx",0,{{-1}},NPY_DOUBLE, 1},
  {"alfz",0,{{-1}},NPY_DOUBLE, 1},
  {"betamgs",0,{{-1}},NPY_DOUBLE, 1},
  {"lrobust",0,{{-1}},NPY_INT, 1},
  {"ldiff",0,{{-1}},NPY_INT, 1},
  {"lphi0",0,{{-1}},NPY_INT, 1},
  {"lfphai",0,{{-1}},NPY_INT, 1},
  {"lffhom",0,{{-1}},NPY_INT, 1},
  {"ltri",0,{{-1}},NPY_INT, 1},
  {"lprior",0,{{-1}},NPY_INT, 1},
  {"lw_ref",0,{{-1}},NPY_INT, 1},
  {"lnsepri",0,{{-1}},NPY_INT, 1},
  {"lsens",0,{{-1}},NPY_INT, 1},
  {"lres",0,{{-1}},NPY_INT, 1},
  {"lcov1",0,{{-1}},NPY_INT, 1},
  {"lcov2",0,{{-1}},NPY_INT, 1},
  {"mswitch",0,{{-1}},NPY_INT, 1},
  {"lgauss",0,{{-1}},NPY_INT, 1},
  {"lvario",0,{{-1}},NPY_INT, 1},
  {"lverb",0,{{-1}},NPY_INT, 1},
  {"lverb_dat",0,{{-1}},NPY_INT, 1},
  {"lsytop",0,{{-1}},NPY_INT, 1},
  {"lelerr",0,{{-1}},NPY_INT, 1},
  {NULL}
};

static void f2py_setup_konvmod(char *lam,char *lammax,char *lam_cri,char *lamnull_cri,char *lamnull_fpi,char *lam_ref,char *lam_ref_sw,char *lamfix,char *dlam,char *dlalt,char *nlam,char *alam,char *fstart,char *fstop,char *step,char *stpalt,char *stpmin,char *llam,char *lstep,char *ldlami,char *ldlamf,char *llamf,char *lfstep,char *nrmsd,char *rmsalt,char *rmsreg,char *rmssum,char *betrms,char *pharms,char *rough,char *nrmsdm,char *mqrms,char *l1min,char *l1rat,char *bdpar,char *bdmin,char *nx,char *nz,char *itmax,char *it,char *itr,char *alfx,char *alfz,char *betamgs,char *lrobust,char *ldiff,char *lphi0,char *lfphai,char *lffhom,char *ltri,char *lprior,char *lw_ref,char *lnsepri,char *lsens,char *lres,char *lcov1,char *lcov2,char *mswitch,char *lgauss,char *lvario,char *lverb,char *lverb_dat,char *lsytop,char *lelerr) {
  int i_f2py=0;
  f2py_konvmod_def[i_f2py++].data = lam;
  f2py_konvmod_def[i_f2py++].data = lammax;
  f2py_konvmod_def[i_f2py++].data = lam_cri;
  f2py_konvmod_def[i_f2py++].data = lamnull_cri;
  f2py_konvmod_def[i_f2py++].data = lamnull_fpi;
  f2py_konvmod_def[i_f2py++].data = lam_ref;
  f2py_konvmod_def[i_f2py++].data = lam_ref_sw;
  f2py_konvmod_def[i_f2py++].data = lamfix;
  f2py_konvmod_def[i_f2py++].data = dlam;
  f2py_konvmod_def[i_f2py++].data = dlalt;
  f2py_konvmod_def[i_f2py++].data = nlam;
  f2py_konvmod_def[i_f2py++].data = alam;
  f2py_konvmod_def[i_f2py++].data = fstart;
  f2py_konvmod_def[i_f2py++].data = fstop;
  f2py_konvmod_def[i_f2py++].data = step;
  f2py_konvmod_def[i_f2py++].data = stpalt;
  f2py_konvmod_def[i_f2py++].data = stpmin;
  f2py_konvmod_def[i_f2py++].data = llam;
  f2py_konvmod_def[i_f2py++].data = lstep;
  f2py_konvmod_def[i_f2py++].data = ldlami;
  f2py_konvmod_def[i_f2py++].data = ldlamf;
  f2py_konvmod_def[i_f2py++].data = llamf;
  f2py_konvmod_def[i_f2py++].data = lfstep;
  f2py_konvmod_def[i_f2py++].data = nrmsd;
  f2py_konvmod_def[i_f2py++].data = rmsalt;
  f2py_konvmod_def[i_f2py++].data = rmsreg;
  f2py_konvmod_def[i_f2py++].data = rmssum;
  f2py_konvmod_def[i_f2py++].data = betrms;
  f2py_konvmod_def[i_f2py++].data = pharms;
  f2py_konvmod_def[i_f2py++].data = rough;
  f2py_konvmod_def[i_f2py++].data = nrmsdm;
  f2py_konvmod_def[i_f2py++].data = mqrms;
  f2py_konvmod_def[i_f2py++].data = l1min;
  f2py_konvmod_def[i_f2py++].data = l1rat;
  f2py_konvmod_def[i_f2py++].data = bdpar;
  f2py_konvmod_def[i_f2py++].data = bdmin;
  f2py_konvmod_def[i_f2py++].data = nx;
  f2py_konvmod_def[i_f2py++].data = nz;
  f2py_konvmod_def[i_f2py++].data = itmax;
  f2py_konvmod_def[i_f2py++].data = it;
  f2py_konvmod_def[i_f2py++].data = itr;
  f2py_konvmod_def[i_f2py++].data = alfx;
  f2py_konvmod_def[i_f2py++].data = alfz;
  f2py_konvmod_def[i_f2py++].data = betamgs;
  f2py_konvmod_def[i_f2py++].data = lrobust;
  f2py_konvmod_def[i_f2py++].data = ldiff;
  f2py_konvmod_def[i_f2py++].data = lphi0;
  f2py_konvmod_def[i_f2py++].data = lfphai;
  f2py_konvmod_def[i_f2py++].data = lffhom;
  f2py_konvmod_def[i_f2py++].data = ltri;
  f2py_konvmod_def[i_f2py++].data = lprior;
  f2py_konvmod_def[i_f2py++].data = lw_ref;
  f2py_konvmod_def[i_f2py++].data = lnsepri;
  f2py_konvmod_def[i_f2py++].data = lsens;
  f2py_konvmod_def[i_f2py++].data = lres;
  f2py_konvmod_def[i_f2py++].data = lcov1;
  f2py_konvmod_def[i_f2py++].data = lcov2;
  f2py_konvmod_def[i_f2py++].data = mswitch;
  f2py_konvmod_def[i_f2py++].data = lgauss;
  f2py_konvmod_def[i_f2py++].data = lvario;
  f2py_konvmod_def[i_f2py++].data = lverb;
  f2py_konvmod_def[i_f2py++].data = lverb_dat;
  f2py_konvmod_def[i_f2py++].data = lsytop;
  f2py_konvmod_def[i_f2py++].data = lelerr;
}
extern void F_FUNC(f2pyinitkonvmod,F2PYINITKONVMOD)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_konvmod(void) {
  F_FUNC(f2pyinitkonvmod,F2PYINITKONVMOD)(f2py_setup_konvmod);
}


static FortranDataDef f2py_get_ver_def[] = {
  {"version",1,{{5}},NPY_STRING, 256},
  {NULL}
};

static void f2py_setup_get_ver(char *version) {
  int i_f2py=0;
  f2py_get_ver_def[i_f2py++].data = version;
}
extern void F_FUNC_US(f2pyinitget_ver,F2PYINITGET_VER)(void (*)(char*));
static void f2py_init_get_ver(void) {
  F_FUNC_US(f2pyinitget_ver,F2PYINITGET_VER)(f2py_setup_get_ver);
}


static FortranDataDef f2py_ompmod_def[] = {
  {"tid",0,{{-1}},NPY_INT, 1},
  {"nthreads",0,{{-1}},NPY_INT, 1},
  {"chunk_0",0,{{-1}},NPY_INT, 1},
  {"chunk_1",0,{{-1}},NPY_INT, 1},
  {"chunk_2",0,{{-1}},NPY_INT, 1},
  {"chunk_3",0,{{-1}},NPY_INT, 1},
  {NULL}
};

static void f2py_setup_ompmod(char *tid,char *nthreads,char *chunk_0,char *chunk_1,char *chunk_2,char *chunk_3) {
  int i_f2py=0;
  f2py_ompmod_def[i_f2py++].data = tid;
  f2py_ompmod_def[i_f2py++].data = nthreads;
  f2py_ompmod_def[i_f2py++].data = chunk_0;
  f2py_ompmod_def[i_f2py++].data = chunk_1;
  f2py_ompmod_def[i_f2py++].data = chunk_2;
  f2py_ompmod_def[i_f2py++].data = chunk_3;
}
extern void F_FUNC(f2pyinitompmod,F2PYINITOMPMOD)(void (*)(char*,char*,char*,char*,char*,char*));
static void f2py_init_ompmod(void) {
  F_FUNC(f2pyinitompmod,F2PYINITOMPMOD)(f2py_setup_ompmod);
}


static FortranDataDef f2py_output_fempy_def[] = {
  {"out_ab",1,{{-1}},NPY_INT, 1},
  {"out_mn",1,{{-1}},NPY_INT, 1},
  {"out_rmag",1,{{-1}},NPY_DOUBLE, 1},
  {"out_rpha_mrad",1,{{-1}},NPY_DOUBLE, 1},
  {"out_sx",1,{{-1}},NPY_DOUBLE, 1},
  {"out_dy",1,{{-1}},NPY_DOUBLE, 1},
  {"out_potmag",1,{{-1}},NPY_DOUBLE, 1},
  {"out_potrpha",1,{{-1}},NPY_DOUBLE, 1},
  {"out_sens_rmag",2,{{-1,-1}},NPY_DOUBLE, 1},
  {NULL}
};

static void f2py_setup_output_fempy(void (*out_ab)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*out_mn)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*out_rmag)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*out_rpha_mrad)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*out_sx)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*out_dy)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*out_potmag)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*out_potrpha)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*out_sens_rmag)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)) {
  int i_f2py=0;
  f2py_output_fempy_def[i_f2py++].func = out_ab;
  f2py_output_fempy_def[i_f2py++].func = out_mn;
  f2py_output_fempy_def[i_f2py++].func = out_rmag;
  f2py_output_fempy_def[i_f2py++].func = out_rpha_mrad;
  f2py_output_fempy_def[i_f2py++].func = out_sx;
  f2py_output_fempy_def[i_f2py++].func = out_dy;
  f2py_output_fempy_def[i_f2py++].func = out_potmag;
  f2py_output_fempy_def[i_f2py++].func = out_potrpha;
  f2py_output_fempy_def[i_f2py++].func = out_sens_rmag;
}
extern void F_FUNC_US(f2pyinitoutput_fempy,F2PYINITOUTPUT_FEMPY)(void (*)(void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*),void (*)(int*,npy_intp*,void(*)(char*,npy_intp*),int*)));
static void f2py_init_output_fempy(void) {
  F_FUNC_US(f2pyinitoutput_fempy,F2PYINITOUTPUT_FEMPY)(f2py_setup_output_fempy);
}


static FortranDataDef f2py_fem_pyw_def[] = {
  {"forward_calculation",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pycrmod_fem_pyw_forward_calculation,doc_f2py_rout_pycrmod_fem_pyw_forward_calculation},
  {NULL}
};

static void f2py_setup_fem_pyw(char *forward_calculation) {
  int i_f2py=0;
  f2py_fem_pyw_def[i_f2py++].data = forward_calculation;
}
extern void F_FUNC_US(f2pyinitfem_pyw,F2PYINITFEM_PYW)(void (*)(char *));
static void f2py_init_fem_pyw(void) {
  F_FUNC_US(f2pyinitfem_pyw,F2PYINITFEM_PYW)(f2py_setup_fem_pyw);
}

/*need_f90modhooks*/

/************** See f2py2e/rules.py: module_rules['modulebody'] **************/

/******************* See f2py2e/common_rules.py: buildhooks *******************/

/*need_commonhooks*/

/**************************** See f2py2e/rules.py ****************************/

static FortranDataDef f2py_routine_defs[] = {

/*eof routine_defs*/
    {NULL}
};

static PyMethodDef f2py_module_methods[] = {

    {NULL,NULL}
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    "pycrmod",
    NULL,
    -1,
    f2py_module_methods,
    NULL,
    NULL,
    NULL,
    NULL
};

PyMODINIT_FUNC PyInit_pycrmod(void) {
    int i;
    PyObject *m,*d, *s, *tmp;
    m = pycrmod_module = PyModule_Create(&moduledef);
    Py_SET_TYPE(&PyFortran_Type, &PyType_Type);
    import_array();
    if (PyErr_Occurred())
        {PyErr_SetString(PyExc_ImportError, "can't initialize module pycrmod (failed to import numpy)"); return m;}
    d = PyModule_GetDict(m);
    s = PyUnicode_FromString("2.2.4");
    PyDict_SetItemString(d, "__version__", s);
    Py_DECREF(s);
    s = PyUnicode_FromString(
        "This module 'pycrmod' is auto-generated with f2py (version:2.2.4).\nFunctions:\n"
"Fortran 90/95 modules:\n""  elemmod --- sanz,typanz,mb,typ,nelanz,selanz,snr,sx,sy,espx,espy,nachbar,nrel,elanz,relanz,rnr,max_nr_element_nodes,esp_min,esp_max,esp_mit,esp_med,esp_std,grid_min,grid_max,grid_minx,grid_miny,grid_maxx,grid_maxy,lsink,nsink,lrandb2,sytop,xk,yk,elmam,elmas,elve,decexi,edecoup,edecstr,decanz,nr_elec_capacitances,elec_caps_file_exists,electrode_capacitances""  alloci --- a,kpot,hpot,sens,csens,adc,kpotdc,hpotdc,sensdc,cov_d,smatm,rnd_r,rnd_p,ata,ata_reg,cov_m""  tic_toc --- fix_f2py""  femmod --- pot,pota,b,bdc,fak,elbg,relbg,kg,lbeta,lrandb,lsr,ldc""  datmod --- nanz,strnr,strom,vnr,volt,sigmaa,sgmaa2,kfak,wmatdp,wmatdr,wmatd_cri,stabw0,stabm0,stabp0,stabpa1,stabpb,stabpa2,lindiv,lratio,lpol,lnse,lnse2,iseed,nstabw0,nstabm0,nstabpb,nstabpa1,nstabpa2,nstabp0,npol""  sigmamod --- sigma0,sigma,sigma2,bet0,pha0,lrho0,lstart,iseedpri,modl_stdn""  electrmod --- eanz,enr""  modelmod --- manz,mnr,w_ref_re,w_ref_im,ind_ref_grad""  make_noise --- f2py_fix""  invmod --- dat,par,dpar,dpar2,d0,m0,fm0,m_ref,wmatd,wmatd2,par_vari,wdfak,lfpi,wmfak""  wavenmod --- kwnanz,swrtr,kwn,kwnwi,amin,amax""  randbmod --- rwdanz,rwdnr,rwddc,rwd,rwdbnr,rwnanz,rwndc,rwn""  errmod --- errnr,fperr,fprun,fpinv,fpcjg,fpeps,fpcfg,errflag,fetxt""  konvmod --- lam,lammax,lam_cri,lamnull_cri,lamnull_fpi,lam_ref,lam_ref_sw,lamfix,dlam,dlalt,nlam,alam,fstart,fstop,step,stpalt,stpmin,llam,lstep,ldlami,ldlamf,llamf,lfstep,nrmsd,rmsalt,rmsreg,rmssum,betrms,pharms,rough,nrmsdm,mqrms,l1min,l1rat,bdpar,bdmin,nx,nz,itmax,it,itr,alfx,alfz,betamgs,lrobust,ldiff,lphi0,lfphai,lffhom,ltri,lprior,lw_ref,lnsepri,lsens,lres,lcov1,lcov2,mswitch,lgauss,lvario,lverb,lverb_dat,lsytop,lelerr""  get_ver --- version""  ompmod --- tid,nthreads,chunk_0,chunk_1,chunk_2,chunk_3""  output_fempy --- out_ab,out_mn,out_rmag,out_rpha_mrad,out_sx,out_dy,out_potmag,out_potrpha,out_sens_rmag""  fem_pyw --- forward_calculation()"".");
    PyDict_SetItemString(d, "__doc__", s);
    Py_DECREF(s);
    s = PyUnicode_FromString("2.2.4");
    PyDict_SetItemString(d, "__f2py_numpy_version__", s);
    Py_DECREF(s);
    pycrmod_error = PyErr_NewException ("pycrmod.error", NULL, NULL);
    /*
     * Store the error object inside the dict, so that it could get deallocated.
     * (in practice, this is a module, so it likely will not and cannot.)
     */
    PyDict_SetItemString(d, "_pycrmod_error", pycrmod_error);
    Py_DECREF(pycrmod_error);
    for(i=0;f2py_routine_defs[i].name!=NULL;i++) {
        tmp = PyFortranObject_NewAsAttr(&f2py_routine_defs[i]);
        PyDict_SetItemString(d, f2py_routine_defs[i].name, tmp);
        Py_DECREF(tmp);
    }

/*eof initf2pywraphooks*/
  PyDict_SetItemString(d, "fem_pyw", PyFortranObject_New(f2py_fem_pyw_def,f2py_init_fem_pyw));
  PyDict_SetItemString(d, "output_fempy", PyFortranObject_New(f2py_output_fempy_def,f2py_init_output_fempy));
  PyDict_SetItemString(d, "ompmod", PyFortranObject_New(f2py_ompmod_def,f2py_init_ompmod));
  PyDict_SetItemString(d, "get_ver", PyFortranObject_New(f2py_get_ver_def,f2py_init_get_ver));
  PyDict_SetItemString(d, "konvmod", PyFortranObject_New(f2py_konvmod_def,f2py_init_konvmod));
  PyDict_SetItemString(d, "errmod", PyFortranObject_New(f2py_errmod_def,f2py_init_errmod));
  PyDict_SetItemString(d, "randbmod", PyFortranObject_New(f2py_randbmod_def,f2py_init_randbmod));
  PyDict_SetItemString(d, "wavenmod", PyFortranObject_New(f2py_wavenmod_def,f2py_init_wavenmod));
  PyDict_SetItemString(d, "invmod", PyFortranObject_New(f2py_invmod_def,f2py_init_invmod));
  PyDict_SetItemString(d, "make_noise", PyFortranObject_New(f2py_make_noise_def,f2py_init_make_noise));
  PyDict_SetItemString(d, "modelmod", PyFortranObject_New(f2py_modelmod_def,f2py_init_modelmod));
  PyDict_SetItemString(d, "electrmod", PyFortranObject_New(f2py_electrmod_def,f2py_init_electrmod));
  PyDict_SetItemString(d, "sigmamod", PyFortranObject_New(f2py_sigmamod_def,f2py_init_sigmamod));
  PyDict_SetItemString(d, "datmod", PyFortranObject_New(f2py_datmod_def,f2py_init_datmod));
  PyDict_SetItemString(d, "femmod", PyFortranObject_New(f2py_femmod_def,f2py_init_femmod));
  PyDict_SetItemString(d, "tic_toc", PyFortranObject_New(f2py_tic_toc_def,f2py_init_tic_toc));
  PyDict_SetItemString(d, "alloci", PyFortranObject_New(f2py_alloci_def,f2py_init_alloci));
  PyDict_SetItemString(d, "elemmod", PyFortranObject_New(f2py_elemmod_def,f2py_init_elemmod));
/*eof initf90modhooks*/

/*eof initcommonhooks*/


#if Py_GIL_DISABLED
    // signal whether this module supports running with the GIL disabled
    PyUnstable_Module_SetGIL(m , Py_MOD_GIL_USED);
#endif

#ifdef F2PY_REPORT_ATEXIT
    if (! PyErr_Occurred())
        on_exit(f2py_report_on_exit,(void*)"pycrmod");
#endif

    if (PyType_Ready(&PyFortran_Type) < 0) {
        return NULL;
    }

    return m;
}
#ifdef __cplusplus
}
#endif
