"""MkDocs hook script for rendering custom badges in Markdown.

This script provides a MkDocs hook (`on_page_markdown`) that finds
special comments in Markdown files matching the standard HTML comment pattern
and replaces them with styled HTML `<span>` elements representing badges.

It handles 'version', 'product', and 'companion' badge types, applying
appropriate icons (via :icon-name: syntax for pymdownx.emoji) and hover text.
Badges generated by this script do not contain hyperlinks.

Inspired by the badge rendering functionality in Material for MkDocs.
https://github.com/squidfunk/mkdocs-material/blob/99fefe8dfbc9352086adebb2ca92a1c706237dd9/src/overrides/hooks/shortcodes.py

Requires:
    - Python 3.10 or later.
    - MkDocs
    - pymdownx.emoji extension enabled in mkdocs.yml for icon rendering.
"""

from __future__ import annotations

import re
from html import escape
from re import Match

from mkdocs.config.defaults import MkDocsConfig
from mkdocs.structure.files import Files
from mkdocs.structure.pages import Page


def on_page_markdown(
    markdown: str, *, page: Page, config: MkDocsConfig, files: Files
) -> str:
    """Process Markdown content to replace badge comments with HTML.

    This function is designed to be used as a MkDocs hook. It searches the
    Markdown content for comments matching the standard HTML comment pattern
    and replaces them using the `_badge`
    helper function via specific type handlers.

    Args:
        markdown: The raw Markdown content of the page.
        page: The MkDocs Page object (unused in this simplified version).
        config: The MkDocs configuration object (unused in this simplified version).
        files: The MkDocs Files collection object (unused in this simplified version).

    Returns:
        The processed Markdown content with badge comments replaced by HTML.

    """

    def replace(match: Match) -> str:
        """Handle the replacement for a single matched badge comment.

        Args:
            match: The regex Match object containing captured groups.

        Returns:
            The generated HTML string for the badge, or the original
            comment if the type is unknown, args are missing, or an
            error occurs during processing.

        """
        try:
            matched_string = match.group(0)
            groups = match.groups()
        except Exception as e:
            print(f"DEBUG: Error retrieving info for match: {match} - Error: {e}")
            return match.group(0) if match else ""

        if len(groups) != 2:
            print(
                f"ERROR: Regex pattern matched '{matched_string}', but "
                f"captured {len(groups)} groups instead of the expected 2. "
                "Skipping replacement for this instance."
            )
            return matched_string

        type_name: str
        args: str
        type_name, args = groups
        args = args.strip()

        if not args:
            print(
                "Warning: Badge comment found with type but no arguments:"
                f"{matched_string}"
            )
            return matched_string

        type_lower = type_name.lower()
        if type_lower == "version":
            return _badge_for_version(args)
        elif type_lower == "product":
            return _badge_for_product(args)
        elif type_lower == "companion":
            return _badge_for_companion(args)

        print(f"Warning: Unknown badge type '{type_name}' in comment: {matched_string}")
        return matched_string

    try:
        processed_markdown: str = re.sub(
            r"<!--\s*badge:(\w+)\s+(.*?)\s*-->",
            replace,
            markdown,
            flags=re.IGNORECASE | re.MULTILINE,
        )
    except Exception as e:
        print(
            f"ERROR: An unexpected error occurred during re.sub processing in hook: {e}"
        )
        return markdown
    else:
        return processed_markdown


def _badge(text: str, title: str, icon_name: str = "", type_suffix: str = "") -> str:
    """Generate the HTML `<span>` for a badge.

    Args:
        text: The text content to display within the badge.
        title: The hover text (tooltip) for the badge (HTML title attribute).
        icon_name: The Material icon name (e.g., "material-tag-outline").
                   If empty, no icon span is generated. Relies on :icon-name:
                   syntax processed by pymdownx.emoji.
        type_suffix: A suffix added to the CSS class (e.g., "version" results
                     in "mdx-badge--version").

    Returns:
        An HTML string representing the badge.

    """
    safe_title: str = escape(title, quote=True)
    classes: str = f"mdx-badge mdx-badge--{type_suffix}" if type_suffix else "mdx-badge"

    html_parts: list[str] = [f'<span class="{classes}" title="{safe_title}">']

    # Add icon span only if icon_name is provided
    if icon_name:
        # Note: :icon-name: syntax requires pymdownx.emoji configured in mkdocs.yml
        html_parts.append(f'<span class="mdx-badge__icon">:{icon_name}:</span>')

    # Add text span (always include text)
    safe_text: str = escape(text)  # Escape text for safety
    # Corrected list extension for clarity
    html_parts.extend((f'<span class="mdx-badge__text">{safe_text}</span>', "</span>"))
    return "".join(html_parts)


def _badge_for_version(version_text: str) -> str:
    """Create an HTML badge specifically for version information."""
    icon: str = "material-api"
    hover_text: str = f"Minimum Real-Time API version: {version_text}"
    return _badge(
        text=version_text, title=hover_text, icon_name=icon, type_suffix="version"
    )


def _badge_for_product(product_name: str) -> str:
    """Create an HTML badge specifically for product names."""
    icon: str = "material-tag-outline"
    hover_text: str = f"Only available for: {product_name}"
    return _badge(
        text=product_name, title=hover_text, icon_name=icon, type_suffix="product"
    )


def _badge_for_companion(companion_name: str) -> str:
    """Create an HTML badge specifically for companion tools/apps."""
    icon: str = "material-cellphone"
    hover_text: str = f"Companion App version: {companion_name}"
    return _badge(
        text=companion_name, title=hover_text, icon_name=icon, type_suffix="companion"
    )
