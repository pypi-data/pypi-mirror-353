<style>
    .container {
        width: 100%;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }

    .toolbar {
        text-align: center;
        padding: 20px 30px;
        background: #f8f9fa;
        border-bottom: 1px solid #e9ecef;
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        align-items: center;
    }

    .graph-container {
        height: 70vh;
        min-height: 400px;
        position: relative;
        background: #ffffff;
        overflow: hidden;
    }

    .graph-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform-origin: 0 0;
    }

    .task-node {
        position: absolute;
        width: 200px;
        min-height: 100px;
        background: white;
        border: 2px solid #ddd;
        border-radius: 12px;
        padding: 15px;
        cursor: move;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
        z-index: 10;
    }

    .task-node:hover {
        transform: scale(1.05);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    .task-node.selected {
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
    }

    .task-node.pending {
        border-color: #ffc107;
        background: linear-gradient(135deg, #fff8e1, #ffffff);
    }

    .task-node.running {
        border-color: #17a2b8;
        background: linear-gradient(135deg, #e0f7ff, #ffffff);
    }

    .task-node.success,
    .task-node.completed {
        border-color: #28a745;
        background: linear-gradient(135deg, #e8f5e8, #ffffff);
    }

    .task-node.failed {
        border-color: #dc3545;
        background: linear-gradient(135deg, #ffeaea, #ffffff);
    }

    .task-title {
        font-weight: bold;
        font-size: 14px;
        margin-bottom: 8px;
        color: #2c3e50;
    }

    .task-status {
        font-size: 12px;
        padding: 4px 8px;
        border-radius: 20px;
        display: inline-block;
        margin-bottom: 8px;
        font-weight: 600;
    }

    .status-pending { background: #ffc107; color: #000; }
    .status-running { background: #17a2b8; color: white; }
    .status-success,
    .status-completed { background: #28a745; color: white; }
    .status-failed { background: #dc3545; color: white; }

    .task-worker {
        font-size: 11px;
        color: #666;
        margin-bottom: 5px;
    }

    .task-duration {
        font-size: 11px;
        color: #666;
    }

    .task-id {
        font-size: 11px;
        color: #666;
        margin-bottom: 5px;
        word-break: break-all;
    }

    .dependency-line {
        position: absolute;
        height: 3px;
        background: linear-gradient(90deg, #667eea, #764ba2);
        z-index: 1;
        border-radius: 2px;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .dependency-line:hover {
        height: 4px;
        background: linear-gradient(90deg, #5a6fd8, #6c42a3);
        filter: drop-shadow(0 2px 8px rgba(102, 126, 234, 0.4));
    }

    .dependency-arrow {
        position: absolute;
        right: -10px;
        top: -6px;
        width: 0;
        height: 0;
        border-left: 12px solid #764ba2;
        border-top: 6px solid transparent;
        border-bottom: 6px solid transparent;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    }

    .dependency-line:hover .dependency-arrow {
        border-left-color: #667eea;
        transform: scale(1.2);
        transition: all 0.2s ease;
    }

    .legend {
        display: flex;
        gap: 20px;
        margin: 10px 30px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
    }

    .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        border: 2px solid;
    }

    .zoom-controls {
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        z-index: 20;
    }

    .zoom-btn {
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 50%;
        background: rgba(102, 126, 234, 0.9);
        color: white;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
    }

    .zoom-btn:hover {
        background: rgba(102, 126, 234, 1);
        transform: scale(1.1);
    }

    @media (max-width: 768px) {
        .toolbar {
            flex-direction: column;
            align-items: stretch;
        }

        .legend {
            justify-content: center;
        }
    }
</style>

<div class="container">
    <div class="toolbar">
        <button class="btn btn-primary" onclick="autoLayout()">Auto Layout</button>
        <button class="btn btn-secondary" onclick="resetZoom()">Reset Zoom</button>
    </div>

    <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomIn()">+</button>
        <button class="zoom-btn" onclick="zoomOut()">âˆ’</button>
    </div>

    <div class="graph-container" id="graphContainer">
        <div class="graph-canvas" id="graphCanvas"></div>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="border-color: #ffc107; background: linear-gradient(135deg, #fff8e1, #ffffff);"></div>
            <span>Pending</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="border-color: #17a2b8; background: linear-gradient(135deg, #e0f7ff, #ffffff);"></div>
            <span>Running</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="border-color: #28a745; background: linear-gradient(135deg, #e8f5e8, #ffffff);"></div>
            <span>Success/Completed</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="border-color: #dc3545; background: linear-gradient(135deg, #ffeaea, #ffffff);"></div>
            <span>Failed</span>
        </div>
    </div>
</div>

<script>
    const nodes = {{ nodes_json|tojson }};
    const edges = {{ edges_json|tojson }};

    let currentZoom = 1;
    let canvasOffset = {x: 0, y: 0};
    let tasks = [], dependencies = [], draggedTask = null, dragOffset = { x: 0, y: 0 };

    function initFromInput() {
        tasks = nodes.map(n => ({
            id: n.id,
            name: n.label,
            worker: n.info.worker || 'unknown',
            status: n.info.status,
            duration: n.info.duration || '0s',
            detail_url: n.detail_url,
            x: Math.random()*400+50,
            y: Math.random()*300+50
        }));
        dependencies = [];
        nodes.forEach(n => {
            if (n.info.parents) {
                n.info.parents.forEach(p => dependencies.push({ from: p, to: n.id }));
            }
        });
        edges.forEach(e => dependencies.push({ from: e.source, to: e.target }));

        // Remove duplicates
        dependencies = dependencies.filter((dep, index, self) =>
            index === self.findIndex(d => d.from === dep.from && d.to === dep.to)
        );

        autoLayout(); // Auto layout on initialization
        renderGraph();
    }

    function renderGraph() {
        const c = document.getElementById('graphCanvas');
        c.innerHTML = '';
        dependencies.forEach(d => {
            const f = tasks.find(t => t.id===d.from), t = tasks.find(t => t.id===d.to);
            if(f&&t) createDependencyLine(f,t);
        });
        tasks.forEach(createTaskNode);
    }

    function createTaskNode(task) {
        const c = document.getElementById('graphCanvas');
        const n = document.createElement('div');
        n.className = `task-node ${task.status}`;
        n.style.left = task.x+'px';
        n.style.top = task.y+'px';
        n.dataset.taskId = task.id;

        n.innerHTML = `
            <div class="task-title">${task.name}</div>
            <div class="task-status status-${task.status}">${task.status.toUpperCase()}</div>
            <div class="task-id">Task ID: ${task.id.substring(0, 8)}...</div>
            <div class="task-worker">Worker: ${task.worker}</div>
            <div class="task-duration">Duration: ${task.duration}</div>
        `;

        n.addEventListener('mousedown', startDrag);
        n.addEventListener('click', () => handleNodeClick(task));
        if (task.detail_url) {
            n.addEventListener('dblclick', () => window.open(task.detail_url, '_blank'));
            n.title = 'Double-click to view details';
        }

        c.appendChild(n);
    }

    function handleNodeClick(node) {
        console.log('Node clicked:', node);
        if (node.detail_url) {
            console.log('Detail URL:', node.detail_url);
        }
    }

    function resetZoom() {
        currentZoom = 1;
        canvasOffset = {x: 0, y: 0};
        const canvas = document.getElementById('graphContainer');
        canvas.style.transform = 'scale(1) translate(0, 0)';
    }

    function zoomIn() {
        currentZoom = Math.min(currentZoom * 1.2, 3);
        applyZoom();
    }

    function zoomOut() {
        currentZoom = Math.max(currentZoom / 1.2, 0.3);
        applyZoom();
    }

    function applyZoom() {
        const canvas = document.getElementById('graphContainer');
        // Apply translate first, then scale to ensure proper scaling behavior
        canvas.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${currentZoom})`;
        canvas.style.transformOrigin = '0 0';
    }

    function createDependencyLine(f, t) {
        const c = document.getElementById('graphCanvas');
        const fx = f.x + 100, fy = f.y + 50, tx = t.x + 100, ty = t.y + 50;
        const dx = tx - fx, dy = ty - fy, len = Math.sqrt(dx*dx + dy*dy);
        const ang = Math.atan2(dy, dx) * 180 / Math.PI;

        const l = document.createElement('div');
        l.className = 'dependency-line';
        l.style.width = len + 'px';
        l.style.left = fx + 'px';
        l.style.top = fy + 'px';
        l.style.transformOrigin = '0 50%';
        l.style.transform = `rotate(${ang}deg)`;

        const a = document.createElement('div');
        a.className = 'dependency-arrow';
        l.appendChild(a);
        c.appendChild(l);
    }

    function startDrag(e) {
        e.preventDefault();
        draggedTask = tasks.find(t => t.id == e.currentTarget.dataset.taskId);
        const r = e.currentTarget.getBoundingClientRect();
        const cr = document.getElementById('graphContainer').getBoundingClientRect();

        // Account for zoom when calculating offset
        dragOffset.x = (e.clientX - r.left) / currentZoom;
        dragOffset.y = (e.clientY - r.top) / currentZoom;

        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', stopDrag);
    }

    function drag(e) {
        if(!draggedTask) return;
        const cr = document.getElementById('graphContainer').getBoundingClientRect();

        // Calculate position in the unscaled coordinate system
        const nx = (e.clientX - cr.left - canvasOffset.x) / currentZoom - dragOffset.x;
        const ny = (e.clientY - cr.top - canvasOffset.y) / currentZoom - dragOffset.y;

        // Allow larger movement area when zoomed out
        const virtualWidth = Math.max(cr.width / currentZoom, 1000);
        const virtualHeight = Math.max(cr.height / currentZoom, 800);

        draggedTask.x = Math.max(-200, Math.min(virtualWidth - 200, nx));
        draggedTask.y = Math.max(-100, Math.min(virtualHeight - 100, ny));
        renderGraph();
    }

    function stopDrag() {
        draggedTask = null;
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', stopDrag);
    }

    function autoLayout() {
        const levels = {};
        const visited = new Set();

        function getLevel(id) {
            if(visited.has(id)) return levels[id] || 0;
            visited.add(id);
            const parents = dependencies.filter(d => d.to === id);
            if (parents.length === 0) {
                levels[id] = 0;
                return 0;
            }
            const maxParentLevel = Math.max(...parents.map(d => getLevel(d.from)));
            levels[id] = maxParentLevel + 1;
            return levels[id];
        }

        tasks.forEach(t => getLevel(t.id));
        const byLevel = {};

        tasks.forEach(task => {
            const level = levels[task.id] || 0;
            if (!byLevel[level]) byLevel[level] = [];
            byLevel[level].push(task);
        });

        const containerRect = document.getElementById('graphContainer').getBoundingClientRect();
        const containerWidth = containerRect.width;
        const containerHeight = containerRect.height;

        Object.entries(byLevel).forEach(([level, taskArray]) => {
            const levelNum = parseInt(level);
            const y = levelNum * 150 + 50;
            const spacing = Math.min(250, Math.max(220, containerWidth / (taskArray.length + 1)));

            taskArray.forEach((task, i) => {
                task.x = (i + 1) * spacing - 100;
                task.y = y;
            });
        });

        renderGraph();
    }

    // API function for external updates
    window.updateGraphData = function(newNodes, newEdges) {
        nodes.length = 0;
        edges.length = 0;
        nodes.push(...newNodes);
        edges.push(...newEdges);
        initFromInput();
    };

    // Initialize
    initFromInput();
</script>